[{"title":"cahr 和 wchar_t","date":"2024-02-19T04:59:59.000Z","path":"2024/02/19/cpp/tip/char/","text":"char和wchar_tchar 和 wchar_t 都是 C++ 中的字符类型，但它们之间有一些区别。char 是一个字节（8 位）长，而 wchar_t 是两个字节（16 位）或四个字节（32 位）长，具体取决于编译器和操作系统。因此，wchar_t 可以表示更多的字符，包括 Unicode 字符。在 Windows 操作系统中，许多 API 函数都使用 wchar_t 类型的字符串参数。如果需要处理 Unicode 字符或调用这些函数，则应使用 wchar_t 类型。否则，可以使用 char 类型。为了使程序适配多语言场景，不建议在代码中使用char或wchar_t，可直接使用TCHAR类型定义字符（串），需要包含对应头文件&lt;TCHAR.H&gt;（在包含了Windows.h时则不需要）。TCHAR在源码中的定义如下：12345#ifdef _UNICODE typedef wchar_t TCHAR;#else typedef char TCHAR;#endif 同理，在涉及到字符串操作的接口时，也推荐使用支持多语言场景的接口_tcscpy、_tcslen、_tcscat，而不是strcpy_s、strlen_s、strcat_s或wcscpy、wcslen、wcscat。头文件&lt;TCHAR.H&gt;中有很多类似的宏定义。前缀L 和 前缀_T通常，我们使用双引号标识ANSI字符串，比如：”I’m an example. “ 这种类型的字符串，每个字符占用一个字节。当我们想要标识UNICODE字符串时，需要添加前缀L，比如：L”I’m an example. “ 。这种类型的字符串，每个字符占用两个字节。当然，为了适配多语言场景，也设计了一个通用的字符串前缀，即_T（或TEXT），这个前缀也是宏定义，其在源码中的定义如下：1234567#ifdef _UNICODE #define _T(c) L##c #define TEXT(c) L##c#else #define _T(c) c #define TEXT(c) c#endif WCHAR LPCTSTR LPSTR LPWSTRWCHAR是一种Unicode编码类型，其在源码中的定义如下：12345#if !defined(_NATIVE_WCHAR_T_DEFINED) typedef unsigned short WCHAR;#else typedef wchar_t WCHAR;#endif LPCTSTR是一种指针类型，该类型名可按照如下方式解读：LP - Pointer, C - Constant, T - TCHAR, STR - String.根据我们创建工程时的配置，LPCTSTR会映射为LPCSTR（ANSI）或LPCWSTR（Unicode）。LPSTR是一种指针类型，可能指向的数据编码类型为 ANSI 或 UTF-8，具体由protocol文件决定。LPSTR在源码中的定义如下：typedef char* PSTR, *LPSTR;LPWSTR也是一种指针类型，它用32位字符表示16位的Unicode字符，其在源码中的定义如下：1typedef wchar_t* LPWSTR, *PWSTR; _stprintf_s_stprintf_s() 函数的第一个参数是要格式化的字符串，第二个参数是要插入到字符串中的值。1234#ifdef UNICODE#define _stprintf_s swprintf_s#else#define _stprintf_s sprintf_s 12TCHAR str[256];_stprintf_s(str, _T(&quot;(%f,%f,%f)&quot;), pt[0], pt[1], pt[2]);","comments":true,"tags":[{"name":"tip","slug":"tip","permalink":"https://kettycode.github.io/tags/tip/"}]},{"title":"哈希表小知识点及引申","date":"2024-02-19T04:59:59.000Z","path":"2024/02/19/cpp/tip/hash/","text":"unordered_map中的小知识unordered_map 将 key的某种类型 通过哈希函数映射成 size_t 即可 等价成数组例如：unordered_map&lt;string,int&gt; map中的键（key）string 通过hash函数转化成特定的size_t(unsigned int)类型，即和vector没太大区别对某些没有默认哈希函数的类型可以自定义哈希函数，例如下列函数：12345678// 通过 对int类型的默认哈希函数 自定义 对array&lt;int, 26&gt; 类型的哈希函数auto arrayHash = [fn = hash&lt;int&gt;&#123;&#125;] (const array&lt;int, 26&gt;&amp; arr) -&gt; size_t &#123; return accumulate(arr.begin(), arr.end(), 0u, [&amp;](size_t acc, int num) &#123; return (acc &lt;&lt; 1) ^ fn(num); &#125;);&#125;;unordered_map&lt;array&lt;int, 26&gt;, vector&lt;string&gt;, decltype(arrayHash)&gt; mp(0, arrayHash); 上述函数用到的lambda表达式lambda:lambda本质上是一个普通的函数，只是它不像普通函数这样声明，它是我们的代码在过程中生成的，用完即弃的函数，不算一个真正的函数，是匿名函数 。格式：[] ({形参表}) {函数内容} &#x2F; -&gt;返回类型{函数内容}中括号表示的是捕获，作用是如何传递变量 lambda使用外部（相对）的变量时，就要使用捕获。如果使用捕获,则：添加头文件： #include&lt; functional &gt;捕获[]使用方式：[&#x3D;]，则是将所有变量值传递到lambda中[&amp;]，则是将所有变量引用传递到lambda中[a]是将变量a通过值传递，如果是[&amp;a]就是将变量a引用传递它可以有0个或者多个捕获","comments":true,"tags":[{"name":"tip","slug":"tip","permalink":"https://kettycode.github.io/tags/tip/"}]},{"title":"cmake学习从0开始","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cmake/cmake1/","text":"step 1 : a basic starting pointExercise 1 - building a basic project12345678910# MakeLists.txt#cmake版本最低要求cmake_minimum_required(VERSION 3.0)#项目名称project(MyProject)#添加项目所需的源代码文件add_executable(MyProject main.cpp) Exercise 2 - spacifying the C++ Standard12345678910111213141516# MakeLists.txt#cmake版本最低要求cmake_minimum_required(VERSION 3.0)#设置C++标准set(CMAKE_CXX_STANDARD 11)#设置C++标准为必须set(CAMKE_CXX_STANDARD_REQUIRED True)#项目名称project(MyProject)#添加项目所需的源代码文件add_executable(MyProject main.cpp) Exercise 3 - adding a version number and configured header file1234567891011121314# MakeLists.txt#cmake版本最低要求cmake_minimum_required(VERSION 3.0)#项目名称project(MyProject Version 1.0)configure_file(MyProjectConfig.h.in MyProjectConfig.h)target_include_directories(MyProject PUBLIC $&#123;PROJECT_BINARY_DIR&#125;)#添加项目所需的源代码文件add_executable(MyProject main.cpp) 1234# MyProjectConfig.h.in#define VERSION_MAJOR @MyProject_VERSION_MAJOR@#define VERSION_MINOR @MyProject_VERSION_MINOR@ 1234567891011# main.cpp#inlcude &lt;MyProjectconfig.h&gt;if (argc &lt; 2)&#123; std::cout &lt;&lt; argv[0] &lt;&lt; &quot; Version &quot; &lt;&lt; VERSION_MAJOR &lt;&lt; &quot; . &quot; &lt;&lt; VERSION_MINOR &lt;&lt; std::endl; std::cout &lt;&lt; &quot; Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; number &quot; &lt;&lt; std:: endl; return 1;&#125;","comments":true,"tags":[{"name":"cmake","slug":"cmake","permalink":"https://kettycode.github.io/tags/cmake/"}]},{"title":"cmake学习从0开始","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cmake/cmake2/","text":"Step 2:adding a libraryExercise 1 - creating a library12345678910add_library(MathFunctions MathFunctions.cxx mysqrt.cxx)add_subdirectory(MathFunctions)target_link_libraries(Tutorial PUBLIC MathFunctions)target_include_directories(Tutorial PUBLIC &quot;$&#123;PROJECT_BINARY_DIR&#125;&quot; &quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot; ) Exercise 2 - adding an option123456789101112# MathFunctions/CMakeLists.txtoption(USE_MYMATH &quot;Use tutorialc provided math implementation&quot; ON)if(USE_MYMATH) target_compile_definitions(MathFunctions PRIVATE &quot;USE_MYmATH&quot;) add_library(SqrtLibrary STATIC mysqrt.cxx ) target_link_libraries(MathFunctions PRIVATE SqrtLibrary)endif()add_library(MathFunction MathFunctions.cxx) 12345678910111213# MathFunctions/MathFunctions.cxx#ifdef USE_MYMATH return detail::mysqrt(x);#else return std::sqrt(x);#endif#ifdef USE_MYMATH# include &quot;mysqrt.h&quot;#endif#include &lt;cmath&gt;","comments":true,"tags":[{"name":"cmake","slug":"cmake","permalink":"https://kettycode.github.io/tags/cmake/"}]},{"title":"git学习从0开始","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/git/git/","text":"1 初始化配置1.1 配置用户名和邮箱git config –global user.name ketty(“ketty master”)git config –global user.email &#x6b;&#101;&#116;&#x74;&#121;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;参数含义：省略(local) : 本地配置，只对本地仓库有效–global : 全局配置，对所有仓库有效–system : 系统配置，对所有用户有效 1.2 保存用户名和密码git config –global credential.helper store 1.3 查看git的配置信息git config –glabal –list 2 新建仓库2.1 创建一个仓库git initgit init my-repo 2.2 克隆一个仓库git clone 3 工作区域和文件状态3.1 工作区域工作区(Working Directory) : 实际操作的目录暂存区(Staging Area&#x2F;Index) : 中间区域,临时存放即将提交的修改内容本地仓库(Local Repository) : git存储代码和版本信息的主要位置git add : 工作区 -&gt; 暂存区git commit : 暂存区 -&gt; 本地仓库 3.2 git中的文件状态未跟踪(Untrack)未修改(Unmodified)已暂存(Modified)已提交(Staged) 4 添加和提交文件git status &#x2F;&#x2F;查看仓库状态git add &#x2F;&#x2F;添加到暂存区git add .&#x2F;&#x2F;添加所有文件git commit -m “描述”&#x2F;&#x2F;提交git commit -am “描述” &#x2F;&#x2F;工作区-&gt;本地仓库git log &#x2F;&#x2F;打印git记录 ,– oneline 查看简洁的提交记录git rm –cached … &#x2F;&#x2F;将提交到暂存的文件移除出来 5 回退版本git reset –soft &#x2F;&#x2F;回退到某个版本，保留工作区和暂存区的所有修改内容git reset –hard &#x2F;&#x2F;回退到某个版本，丢弃工作区和暂存区的所有修改内容git reset –mixed &#x2F;&#x2F;回退到某个版本，只保留工作区的修改内容 6 查看差异git diff &#x2F;&#x2F; 工作区 vs 暂存区git diff HEAD &#x2F;&#x2F;工作区 + 暂存区 vs 本地仓库git diff cached &#x2F;&#x2F;暂存区 vs 本地仓库git diff staged &#x2F;&#x2F;暂存区 vs 本地仓库git diff &#x2F;&#x2F;提交之间的差异git diff HEAD~HEAD &#x2F;&#x2F;提交之间的差异git diff &#x2F;&#x2F;分支之间的差异 7 删除文件&#x2F;&#x2F;删除之后记得提交rm file ; gti add file &#x2F;&#x2F;删除工作区的文件，然后暂存删除文件git rm &#x2F;&#x2F;把文件从工作区和暂存区同时删除git rm –cached &#x2F;&#x2F;把文件从暂存区删除git rm -r* &#x2F;&#x2F;递归删除某个目录下的所有子目录和文件 8 忽略文件.gitignore文件 9 SSH配置和克隆仓库ssh-keygen -t rsa -b 4096&#x2F;&#x2F;私匙文件：id_rsa&#x2F;&#x2F;公匙文件：id_rsa.pub git push &#x2F;&#x2F;推送更新内容git pull &#x2F;&#x2F;拉取更新内容 10 关联本地仓库和远程仓库&#x2F;&#x2F;添加远程仓库1.git remote add &lt;远程仓库别名&gt; &lt;远程仓库地址&gt;2.git push -u &lt;远程仓库别名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; git remote -v &#x2F;&#x2F;查看远程仓库git pull &lt;远程仓库别名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; &#x2F;&#x2F;拉取远程仓库内容(相同可省略冒号及后面的部分) 分支基本操作git branch &#x2F;&#x2F;查看分支列表git branch &lt;新分支名&gt; &#x2F;&#x2F;创建新分支git checkout &lt;新分支名&gt; &#x2F;&#x2F;切换新分支git switch &lt;新分支名&gt; &#x2F;&#x2F;切换新分支git merge &lt;新分支名&gt; &#x2F;&#x2F;合并分支git branch -d &lt;新分支名&gt; &#x2F;&#x2F;删除已合并分支git branch -D &lt;新分支名&gt; &#x2F;&#x2F;删除未合并分支 分支合并冲突手动更改文件解决合并冲突git merge –about &#x2F;&#x2F;终止合并 回退和rebasegit rebase &lt;分支名&gt;","comments":true,"tags":[{"name":"git","slug":"git","permalink":"https://kettycode.github.io/tags/git/"}]},{"title":"linux网络编程基础知识","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/linux网络编程/base1/","text":"1.分层模型及典型协议应用层 常见的协议有HTTP协议，FTP协议。传输层 常见协议有TCP&#x2F;UDP协议。网络层 常见协议有IP协议、ICMP协议、IGMP协议。网络接口层 常见协议有ARP协议、RARP协议。TCP传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。UDP用户数据报协议（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。HTTP超文本传输协议（Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议。FTP文件传输协议（File Transfer Protocol）IP协议是因特网互联协议（Internet Protocol）ICMP协议是Internet控制报文协议（Internet Control Message Protocol）它是TCP&#x2F;IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。ARP协议是正向地址解析协议（Address Resolution Protocol），通过已知的IP，寻找对应主机的MAC地址。RARP是反向地址转换协议，通过MAC地址确定IP地址。 网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。 2.TCP和UDPTCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。 应用程序所看到的数据是一个整体，或说是一个流（stream），在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。 3.tcp建立连接和断开连接-三次握手、四次挥手 建立连接（三次握手）的过程：1.客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。客户端发出段1，SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况，另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。2.服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。3.客户必须再次回应服务器端一个ACK报文，这是报文段3。客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为“三方握手（three-way-handshake）”。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。 关闭连接（四次握手）的过程：由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。1.客户端发出，FIN位表示关闭连接的请求。2.服务器发出，应答客户端的关闭连接请求。3.服务器发出，其中也包含FIN位，向客户端发送关闭连接请求。4.客户端发出，应答服务器的关闭连接请求。建立连接的过程是三方握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。 4.滑动窗口滑动窗口:随着应用程序提走数据，虚线框（接收缓冲区）是向右滑动的，因此称为滑动窗口。 5.tcp 状态转换CLOSED：表示初始状态。LISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。SYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。ESTABLISHED：表示连接已经建立。FIN_WAIT_1: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。CLOSING: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。CLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。LAST_ACK: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。 6.路由器和交换机路由和交换之间的主要区别就是交换发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换在移动信息的过程 中需使用不同的控制信息，所以两者实现各自功能的方式是不同的。 7.半关闭当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。从程序的角度，可以使用API来控制实现半连接状态。#include &lt;sys&#x2F;socket.h&gt;int shutdown(int sockfd, int how);sockfd: 需要关闭的socket的描述符how: 允许为shutdown操作选择以下几种方式: SHUT_RD(0)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。 该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。 SHUT_WR(1): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。 SHUT_RDWR(2): 关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。shutdown不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。注意:1.如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。2.在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但，如果一个进程close(sfd)将不会影响到其它进程。","comments":true,"tags":[{"name":"linux网络编程","slug":"linux网络编程","permalink":"https://kettycode.github.io/tags/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"Socket编程","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/linux网络编程/socket编程1/","text":"#socketSocket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。 在TCP&#x2F;IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。 在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。 #socket API##为TCP&#x2F;IP协议设计的应用层编程接口 TCP&#x2F;IP协议规定，网络数据流应采用大端字节序，即低地址高字节为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。h表示host，n表示network，l表示32位长整数，s表示16位短整数。如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。 123456#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort); #IP地址转换函数 12345678//早期，只能处理IPv4的ip地址，不可重入函数#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int inet_aton(const char *cp, struct in_addr *inp);in_addr_t inet_addr(const char *cp);char *inet_ntoa(struct in_addr in); 123456//支持IPv4和IPv6，可重入函数，其中inet_pton和inet_ntop不仅可以转换IPv4的//in_addr，还可以转换IPv6的in6_addr。因此函数接口是void *addrptr。#include &lt;arpa/inet.h&gt;int inet_pton(int af, const char *src, void *dst);const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); #sockaddr数据结构 123456789101112131415161718192021222324252627282930313233343536373839404142struct sockaddr &#123; sa_family_t sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */&#125;;struct sockaddr_in &#123; __kernel_sa_family_t sin_family; /* Address family */ 地址结构类型 __be16 sin_port; /* Port number */ 端口号 struct in_addr sin_addr; /* Internet address */ IP地址 /* Pad to size of `struct sockaddr&#x27;. */ unsigned char __pad[__SOCK_SIZE__ - sizeof(short int) - sizeof(unsigned short int) - sizeof(struct in_addr)];&#125;;struct in_addr &#123; /* Internet address. */ __be32 s_addr;&#125;;struct sockaddr_in6 &#123; unsigned short int sin6_family; /* AF_INET6 */ __be16 sin6_port; /* Transport layer port # */ __be32 sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ __u32 sin6_scope_id; /* scope id (new in RFC2553) */&#125;;struct in6_addr &#123; union &#123; __u8 u6_addr8[16]; __be16 u6_addr16[8]; __be32 u6_addr32[4]; &#125; in6_u; #define s6_addr in6_u.u6_addr8 #define s6_addr16 in6_u.u6_addr16 #define s6_addr32 in6_u.u6_addr32&#125;;#define UNIX_PATH_MAX 108 struct sockaddr_un &#123; __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */&#125;; Pv4和IPv6的地址格式定义在netinet&#x2F;in.h中，IPv4地址用sockaddr_in结构体表示，包括16位端口号和32位IP地址，IPv6地址用sockaddr_in6结构体表示，包括16位端口号、128位IP地址和一些控制字段 因此，socket API可以接受各种类型的sockaddr结构体指针做参数，例如bind、accept、connect等函数，这些函数的参数应该设计成void *类型以便接受各种类型的指针，但是sock API的实现早于ANSI C标准化，那时还没有void *类型，因此这些函数的参数都用struct sockaddr *类型表示，在传递参数之前要强制类型转换一下，例如： 12struct sockaddr_in servaddr;bind(listen_fd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); /* initialize servaddr */ TCP客户端：socket() -&gt; connect() -&gt; write() &lt;-&gt; read() -&gt; close()TCP服务端：socket() -&gt; bind() -&gt; listen() -&gt; accept() -&gt; 阻塞直到有客户端连接 -&gt; read() &lt;-&gt; write() -&gt; read() -&gt; close() ##socket函数 123456789101112131415161718#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);domain: AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址 AF_INET6 与上面类似，不过是来用IPv6的地址 AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用type: SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。 SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。 SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。 SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议） SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序protocol: 传0 表示使用默认协议。返回值： 成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read&#x2F;write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。 ##bind函数 123456789101112#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);sockfd： socket文件描述符addr: 构造出IP地址加端口号addrlen: sizeof(addr)长度返回值： 成功返回0，失败返回-1, 设置errno 服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。 bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。如： 12345struct sockaddr_in servaddr;bzero(&amp;servaddr, sizeof(servaddr));servaddr.sin_family = AF_INET;servaddr.sin_addr.s_addr = htonl(INADDR_ANY);servaddr.sin_port = htons(6666); ##listen函数 1234567#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);sockfd: socket文件描述符backlog: 排队建立3次握手队列和刚刚建立3次握手队列的链接数和 典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。 ##accept函数 123456789101112#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);sockdf: socket文件描述符addr: 传出参数，返回链接客户端地址信息，含IP地址和端口号addrlen: 传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小返回值： 成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno 三次握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。 1234567while (1) &#123; cliaddr_len = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len); n = read(connfd, buf, MAXLINE); ...... close(connfd);&#125; 我们的服务器程序结构整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭listenfd，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回-1 ##connect函数 123456789101112#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);sockdf: socket文件描述符addr: 传入参数，指定服务器端地址信息，含IP地址和端口号addrlen: 传入参数,传入sizeof(addr)大小返回值： 成功返回0，失败返回-1，设置errno 客户端需要调用connect()连接服务器，connect和bind的参数形式一致，区别在于bind的参数是自己的地址，而connect的参数是对方的地址。connect()成功返回0，出错返回-1。 服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于监听端口的状态，客户端调用socket()初始化后，调用connect()发出SYN段并阻塞等待服务器应答，服务器应答一个SYN-ACK段，客户端收到后从connect()返回，同时应答一个ACK段，服务器收到后从accept()返回。数据传输的过程：建立连接后，TCP协议提供全双工的通信服务，但是一般的客户端&#x2F;服务器程序的流程是由客户端主动发起请求，服务器被动处理请求，一问一答的方式。因此，服务器从accept()返回后立刻调用read()，读socket就像读管道一样，如果没有数据到达就阻塞等待，这时客户端调用write()发送请求给服务器，服务器收到后从read()返回，对客户端的请求进行处理，在此期间客户端调用read()阻塞等待服务器的应答，服务器调用write()将处理结果发回给客户端，再次调用read()阻塞等待下一条请求，客户端收到后从read()返回，发送下一条请求，如此循环下去。如果客户端没有更多的请求了，就调用close()关闭连接，就像写端关闭的管道一样，服务器的read()返回0，这样服务器就知道客户端关闭了连接，也调用close()关闭连接。注意，任何一方调用close()后，连接的两个传输方向都关闭，不能再发送数据了。如果一方调用shutdown()则连接处于半关闭状态，仍可接收对方发来的数据。在学习socket API时要注意应用程序和TCP协议层是如何交互的： 应用程序调用某个socket函数时TCP协议层完成什么动作，比如调用connect()会发出SYN段 应用程序如何知道TCP协议层的状态变化，比如从某个阻塞的socket函数返回就表明TCP协议收到了某些段，再比如read()返回0就表明收到了FIN段 ##最简单的客户端&#x2F;服务器程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Server#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#define MAXLINE 80#define SERV_PORT 6666int main(void)&#123; struct sockaddr_in servaddr, cliaddr; socklen_t cliaddr_len; int listenfd, connfd; char buf[MAXLINE]; char str[INET_ADDRSTRLEN]; int i, n; listenfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); listen(listenfd, 20); printf(&quot;Accepting connections ...\\n&quot;); while (1) &#123; cliaddr_len = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len); n = read(connfd, buf, MAXLINE); printf(&quot;received from %s at PORT %d\\n&quot;, inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); for (i = 0; i &lt; n; i++) buf[i] = toupper(buf[i]); write(connfd, buf, n); close(connfd); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142//Client#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define MAXLINE 80#define SERV_PORT 6666int main(int argc, char *argv[])&#123; struct sockaddr_in servaddr; char buf[MAXLINE]; int sockfd, n;char *str; if (argc != 2) &#123; fputs(&quot;usage: ./client message\\n&quot;, stderr); exit(1); &#125;str = argv[1]; sockfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr); servaddr.sin_port = htons(SERV_PORT); connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); write(sockfd, str, strlen(str)); n = read(sockfd, buf, MAXLINE); printf(&quot;Response from server:\\n&quot;); write(STDOUT_FILENO, buf, n); close(sockfd); return 0;&#125; ##出错封装函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166//wrap.c#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;void perr_exit(const char *s)&#123; perror(s); exit(1);&#125;int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)&#123; int n; again: if ( (n = accept(fd, sa, salenptr)) &lt; 0) &#123; if ((errno == ECONNABORTED) || (errno == EINTR)) goto again; else perr_exit(&quot;accept error&quot;); &#125; return n;&#125;int Bind(int fd, const struct sockaddr *sa, socklen_t salen)&#123; int n; if ((n = bind(fd, sa, salen)) &lt; 0) perr_exit(&quot;bind error&quot;); return n;&#125;int Connect(int fd, const struct sockaddr *sa, socklen_t salen)&#123; int n; if ((n = connect(fd, sa, salen)) &lt; 0) perr_exit(&quot;connect error&quot;); return n;&#125;int Listen(int fd, int backlog)&#123; int n; if ((n = listen(fd, backlog)) &lt; 0) perr_exit(&quot;listen error&quot;); return n;&#125;int Socket(int family, int type, int protocol)&#123; int n; if ( (n = socket(family, type, protocol)) &lt; 0) perr_exit(&quot;socket error&quot;); return n;&#125;ssize_t Read(int fd, void *ptr, size_t nbytes)&#123; ssize_t n;again: if ( (n = read(fd, ptr, nbytes)) == -1) &#123; if (errno == EINTR) goto again; else return -1; &#125; return n;&#125;ssize_t Write(int fd, const void *ptr, size_t nbytes)&#123; ssize_t n;again: if ( (n = write(fd, ptr, nbytes)) == -1) &#123; if (errno == EINTR) goto again; else return -1; &#125; return n;&#125;int Close(int fd)&#123; int n; if ((n = close(fd)) == -1) perr_exit(&quot;close error&quot;); return n;&#125;ssize_t Readn(int fd, void *vptr, size_t n)&#123; size_t nleft; ssize_t nread; char *ptr; ptr = vptr; nleft = n; while (nleft &gt; 0) &#123; if ( (nread = read(fd, ptr, nleft)) &lt; 0) &#123; if (errno == EINTR) nread = 0; else return -1; &#125; else if (nread == 0) break; nleft -= nread; ptr += nread; &#125; return n - nleft;&#125;ssize_t Writen(int fd, const void *vptr, size_t n)&#123; size_t nleft; ssize_t nwritten; const char *ptr; ptr = vptr; nleft = n; while (nleft &gt; 0) &#123; if ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) &#123; if (nwritten &lt; 0 &amp;&amp; errno == EINTR) nwritten = 0; else return -1; &#125; nleft -= nwritten; ptr += nwritten; &#125; return n;&#125;static ssize_t my_read(int fd, char *ptr)&#123; static int read_cnt; static char *read_ptr; static char read_buf[100]; if (read_cnt &lt;= 0) &#123;again: if ((read_cnt = read(fd, read_buf, sizeof(read_buf))) &lt; 0) &#123; if (errno == EINTR) goto again; return -1; &#125; else if (read_cnt == 0) return 0; read_ptr = read_buf; &#125; read_cnt--; *ptr = *read_ptr++; return 1;&#125;ssize_t Readline(int fd, void *vptr, size_t maxlen)&#123; ssize_t n, rc; char c, *ptr; ptr = vptr; for (n = 1; n &lt; maxlen; n++) &#123; if ( (rc = my_read(fd, &amp;c)) == 1) &#123; *ptr++ = c; if (c == &#x27;\\n&#x27;) break; &#125; else if (rc == 0) &#123; *ptr = 0; return n - 1; &#125; else return -1; &#125; *ptr = 0; return n;&#125; 12345678910111213141516#ifndef __WRAP_H_#define __WRAP_H_void perr_exit(const char *s);int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr);int Bind(int fd, const struct sockaddr *sa, socklen_t salen);int Connect(int fd, const struct sockaddr *sa, socklen_t salen);int Listen(int fd, int backlog);int Socket(int family, int type, int protocol);ssize_t Read(int fd, void *ptr, size_t nbytes);ssize_t Write(int fd, const void *ptr, size_t nbytes);int Close(int fd);ssize_t Readn(int fd, void *vptr, size_t n);ssize_t Writen(int fd, const void *vptr, size_t n);ssize_t my_read(int fd, char *ptr);ssize_t Readline(int fd, void *vptr, size_t maxlen);#endif ##多进程并发服务器 使用多进程并发服务器时要考虑以下几点：1.父进程最大文件描述个数(父进程中需要close关闭accept返回的新文件描述符)2.系统内创建进程个数(与内存大小相关)3.进程创建过多是否降低整体服务性能(进程调度) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Server.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &quot;wrap.h&quot;#define MAXLINE 80#define SERV_PORT 800void do_sigchild(int num)&#123; while (waitpid(0, NULL, WNOHANG) &gt; 0) ;&#125;int main(void)&#123; struct sockaddr_in servaddr, cliaddr; socklen_t cliaddr_len; int listenfd, connfd; char buf[MAXLINE]; char str[INET_ADDRSTRLEN]; int i, n; pid_t pid; struct sigaction newact; newact.sa_handler = do_sigchild; sigemptyset(&amp;newact.sa_mask); newact.sa_flags = 0; sigaction(SIGCHLD, &amp;newact, NULL); listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); Bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); Listen(listenfd, 20); printf(&quot;Accepting connections ...\\n&quot;); while (1) &#123; cliaddr_len = sizeof(cliaddr); connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len); pid = fork(); if (pid == 0) &#123; Close(listenfd); while (1) &#123; n = Read(connfd, buf, MAXLINE); if (n == 0) &#123; printf(&quot;the other side has been closed.\\n&quot;); break; &#125; printf(&quot;received from %s at PORT %d\\n&quot;, inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); for (i = 0; i &lt; n; i++) buf[i] = toupper(buf[i]); Write(connfd, buf, n); &#125; Close(connfd); return 0; &#125; else if (pid &gt; 0) &#123; Close(connfd); &#125; else perr_exit(&quot;fork&quot;); &#125; Close(listenfd); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738//Client.c/* client.c */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;netinet/in.h&gt;#include &quot;wrap.h&quot;#define MAXLINE 80#define SERV_PORT 6666int main(int argc, char *argv[])&#123; struct sockaddr_in servaddr; char buf[MAXLINE]; int sockfd, n; sockfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr); servaddr.sin_port = htons(SERV_PORT); Connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); while (fgets(buf, MAXLINE, stdin) != NULL) &#123; Write(sockfd, buf, strlen(buf)); n = Read(sockfd, buf, MAXLINE); if (n == 0) &#123; printf(&quot;the other side has been closed.\\n&quot;); break; &#125; else Write(STDOUT_FILENO, buf, n); &#125; Close(sockfd); return 0;&#125; 在使用线程模型开发服务器时需考虑以下问题：1.调整进程内最大文件描述符上限2.线程如有共享数据，考虑线程同步3.服务于客户端线程退出时，退出处理。（退出值，分离态）4.系统负载，随着链接客户端增加，导致其它线程不能及时得到CPU 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* server.c */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;pthread.h&gt;#include &quot;wrap.h&quot;#define MAXLINE 80#define SERV_PORT 6666struct s_info &#123; struct sockaddr_in cliaddr; int connfd;&#125;;void *do_work(void *arg)&#123; int n,i; struct s_info *ts = (struct s_info*)arg; char buf[MAXLINE]; char str[INET_ADDRSTRLEN]; /* 可以在创建线程前设置线程创建属性,设为分离态,哪种效率高内？ */ pthread_detach(pthread_self()); while (1) &#123; n = Read(ts-&gt;connfd, buf, MAXLINE); if (n == 0) &#123; printf(&quot;the other side has been closed.\\n&quot;); break; &#125; printf(&quot;received from %s at PORT %d\\n&quot;, inet_ntop(AF_INET, &amp;(*ts).cliaddr.sin_addr, str, sizeof(str)), ntohs((*ts).cliaddr.sin_port)); for (i = 0; i &lt; n; i++) buf[i] = toupper(buf[i]); Write(ts-&gt;connfd, buf, n); &#125; Close(ts-&gt;connfd);&#125;int main(void)&#123; struct sockaddr_in servaddr, cliaddr; socklen_t cliaddr_len; int listenfd, connfd; int i = 0; pthread_t tid; struct s_info ts[256]; listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); Bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); Listen(listenfd, 20); printf(&quot;Accepting connections ...\\n&quot;); while (1) &#123; cliaddr_len = sizeof(cliaddr); connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len); ts[i].cliaddr = cliaddr; ts[i].connfd = connfd; /* 达到线程最大数时，pthread_create出错处理, 增加服务器稳定性 */ pthread_create(&amp;tid, NULL, do_work, (void*)&amp;ts[i]); i++; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334/* client.c */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;netinet/in.h&gt;#include &quot;wrap.h&quot;#define MAXLINE 80#define SERV_PORT 6666int main(int argc, char *argv[])&#123; struct sockaddr_in servaddr; char buf[MAXLINE]; int sockfd, n; sockfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr); servaddr.sin_port = htons(SERV_PORT); Connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); while (fgets(buf, MAXLINE, stdin) != NULL) &#123; Write(sockfd, buf, strlen(buf)); n = Read(sockfd, buf, MAXLINE); if (n == 0) printf(&quot;the other side has been closed.\\n&quot;); else Write(STDOUT_FILENO, buf, n); &#125; Close(sockfd); return 0;&#125; ##多路I&#x2F;O转接服务器","comments":true,"tags":[{"name":"linux网络编程","slug":"linux网络编程","permalink":"https://kettycode.github.io/tags/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++并发编程学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/并发编程/atomic/","text":"std::atomicstd::atomic_flag构造函数std::atomic_flag 只有默认构造函数，拷贝构造函数已被禁用，因此不能从其他的 std::atomic_flag 对象构造一个新的 std::atomic_flag 对象。 如果在初始化时没有明确使用 ATOMIC_FLAG_INIT初始化，那么新创建的 std::atomic_flag 对象的状态是未指定的（unspecified）（既没有被 set 也没有被 clear。）另外，atomic_flag不能被拷贝，也不能 move 赋值。 ATOMIC_FLAG_INIT: 如果某个 std::atomic_flag 对象使用该宏初始化，那么可以保证该 std::atomic_flag 对象在创建时处于 clear 状态。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt; // std::cout#include &lt;atomic&gt; // std::atomic, std::atomic_flag, ATOMIC_FLAG_INIT#include &lt;thread&gt; // std::thread, std::this_thread::yield#include &lt;vector&gt; // std::vectorstd::atomic&lt;bool&gt; ready(false); // can be checked without being setstd::atomic_flag winner = ATOMIC_FLAG_INIT; // always set when checkedvoid count1m(int id)&#123; while (!ready) &#123; std::this_thread::yield(); &#125; // 等待主线程中设置 ready 为 true. for (int i = 0; i &lt; 1000000; ++i) &#123; &#125; // 计数. // 如果某个线程率先执行完上面的计数过程，则输出自己的 ID. // 此后其他线程执行 test_and_set 是 if 语句判断为 false， // 因此不会输出自身 ID. if (!winner.test_and_set()) &#123; std::cout &lt;&lt; &quot;thread #&quot; &lt;&lt; id &lt;&lt; &quot; won!\\n&quot;; &#125;&#125;;int main()&#123; std::vector&lt;std::thread&gt; threads; std::cout &lt;&lt; &quot;spawning 10 threads that count to 1 million...\\n&quot;; for (int i = 1; i &lt;= 10; ++i) threads.push_back(std::thread(count1m, i)); ready = true; for (auto &amp; th:threads) th.join(); return 0;&#125; std::atomic_flag::text_and_settest_and_set() 函数检查 std::atomic_flag 标志，如果 std::atomic_flag 之前没有被设置过，则设置 std::atomic_flag 的标志，并返回先前该 std::atomic_flag 对象是否被设置过，如果之前 std::atomic_flag 对象已被设置，则返回 true，否则返回 false。 test-and-set 操作是原子的（因此 test-and-set 是原子 read-modify-write （RMW）操作）。 std::atomic_flag::clear清除 std::atomic_flag 对象的标志位，即设置 atomic_flag 的值为 false 自旋锁结合 std::atomic_flag::test_and_set() 和 std::atomic_flag::clear()，std::atomic_flag 对象可以当作一个简单的自旋锁使用 123456789101112131415161718192021222324252627#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;atomic&gt;std::atomic_flag lock = ATOMIC_FLAG_INIT;void f(int n)&#123; for (int cnt = 0; cnt &lt; 100; ++cnt) &#123; while (lock.test_and_set(std::memory_order_acquire)) // acquire lock ; // spin std::cout &lt;&lt; &quot;Output from thread &quot; &lt;&lt; n &lt;&lt; &#x27;\\n&#x27;; lock.clear(std::memory_order_release); // release lock &#125;&#125;int main()&#123; std::vector&lt;std::thread&gt; v; for (int n = 0; n &lt; 10; ++n) &#123; v.emplace_back(f, n); &#125; for (auto&amp; t : v) &#123; t.join(); &#125;&#125; 在上面的程序中，std::atomic_flag 对象 lock 的上锁操作可以理解为 lock.test_and_set(std::memory_order_acquire); (此处指定了 Memory Order，更多有关 Memory Order 的概念，我会在后续的文章中介绍)，解锁操作相当与 lock.clear(std::memory_order_release)。 在上锁的时候，如果 lock.test_and_set 返回 false，则表示上锁成功（此时 while 不会进入自旋状态），因为此前 lock 的标志位为 false(即没有线程对 lock 进行上锁操作)，但调用 test_and_set 后 lock 的标志位为 true，说明某一线程已经成功获得了 lock 锁。 如果在该线程解锁（即调用 lock.clear(std::memory_order_release)） 之前，另外一个线程也调用 lock.test_and_set(std::memory_order_acquire) 试图获得锁，则 test_and_set(std::memory_order_acquire) 返回 true，则 while 进入自旋状态。如果获得锁的线程解锁（即调用了 lock.clear(std::memory_order_release)）之后，某个线程试图调用 lock.test_and_set(std::memory_order_acquire) 并且返回 false，则 while 不会进入自旋，此时表明该线程成功地获得了锁。 按照上面的分析，我们知道在某种情况下 std::atomic_flag 对象可以当作一个简单的自旋锁使用。 std::atomicstd::atomic 是模板类，一个模板类型为 T 的原子对象中封装了一个类型为 T 的值: template struct atomic;原子类型对象的主要特点就是从不同线程访问不会导致数据竞争(data race)。因此从不同线程访问某个原子对象是良性 (well-defined) 行为，而通常对于非原子类型而言，并发访问某个对象（如果不做任何同步操作）会导致未定义 (undifined) 行为发生。 构造函数默认构造函数，由默认构造函数创建的 std::atomic 对象处于未初始化(uninitialized)状态，对处于未初始化(uninitialized)状态 std::atomic对象可以由 atomic_init 函数进行初始化。初始化构造函数，由类型 T初始化一个 std::atomic对象。拷贝构造函数被禁用 std::atomic::operator&#x3D;()普通的赋值拷贝操作已经被禁用。但是一个类型为 T 的变量可以赋值给相应的原子类型变量（相当与隐式转换），该操作是原子的，内存序(Memory Order) 默认为顺序一致性(std::memory_order_seq_cst)，如果需要指定其他的内存序，需使用 std::atomic::store()。 is_lock_free12bool is_lock_free() const volatile noexcept;bool is_lock_free() const noexcept; 判断该 std::atomic 对象是否具备 lock-free 的特性。如果某个对象满足 lock-free 特性，在多个线程访问该对象时不会导致线程阻塞。(可能使用某种事务内存transactional memory 方法实现 lock-free 的特性)。 store12void store (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;void store (T val, memory_order sync = memory_order_seq_cst) noexcept; 修改被封装的值，std::atomic::store 函数将类型为 T 的参数 val 复制给原子对象所封装的值。T 是 std::atomic 类模板参数。另外参数 sync 指定内存序(Memory Order) load12T load (memory_order sync = memory_order_seq_cst) const volatile noexcept;T load (memory_order sync = memory_order_seq_cst) const noexcept; 读取被封装的值，参数 sync 设置内存序(Memory Order) operator T12operator T() const volatile noexcept;operator T() const noexcept; 与 load 功能类似，也是读取被封装的值，operator T() 是类型转换(type-cast)操作，默认的内存序是 std::memory_order_seq_cst exchange12T exchange (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;T exchange (T val, memory_order sync = memory_order_seq_cst) noexcept; 读取并修改被封装的值，exchange 会将 val 指定的值替换掉之前该原子对象封装的值，并返回之前该原子对象封装的值，整个过程是原子的(因此exchange 操作也称为 read-modify-write 操作)。sync参数指定内存序(Memory Order) compare_exchange_weak12345678bool compare_exchange_weak (T&amp; expected, T val, memory_order sync = memory_order_seq_cst) volatile noexcept;bool compare_exchange_weak (T&amp; expected, T val, memory_order sync = memory_order_seq_cst) noexcept;bool compare_exchange_weak (T&amp; expected, T val, memory_order success, memory_order failure) volatile noexcept;bool compare_exchange_weak (T&amp; expected, T val, memory_order success, memory_order failure) noexcept; 比较并交换被封装的值(weak)与参数 expected 所指定的值是否相等，如果：相等，则用 val 替换原子对象的旧值。不相等，则用原子对象的旧值替换 expected ，因此调用该函数之后，如果被该原子对象封装的值与参数 expected 所指定的值不相等，expected 中的内容就是原子对象的旧值。该函数通常会读取原子对象封装的值，如果比较为 true(即原子对象的值等于 expected)，则替换原子对象的旧值，但整个操作是原子的，在某个线程读取和修改该原子对象时，另外的线程不能对读取和修改该原子对象。 在第(2)种情况下，内存序（Memory Order）的选择取决于比较操作结果，如果比较结果为 true(即原子对象的值等于 expected)，则选择参数 success 指定的内存序，否则选择参数 failure 所指定的内存序。 注意，该函数直接比较原子对象所封装的值与参数 expected 的物理内容，所以某些情况下，对象的比较操作在使用 operator&#x3D;&#x3D;() 判断时相等，但 compare_exchange_weak 判断时却可能失败，因为对象底层的物理内容中可能存在位对齐或其他逻辑表示相同但是物理表示不同的值(比如 true 和 2 或 3，它们在逻辑上都表示”真”，但在物理上两者的表示并不相同)。 与compare_exchange_strong 不同, weak 版本的 compare-and-exchange 操作允许(spuriously 地)返回 false(即原子对象所封装的值与参数 expected 的物理内容相同，但却仍然返回 false)，不过在某些需要循环操作的算法下这是可以接受的，并且在一些平台下 compare_exchange_weak 的性能更好 。如果 compare_exchange_weak 的判断确实发生了伪失败(spurious failures)——即使原子对象所封装的值与参数 expected 的物理内容相同，但判断操作的结果却为 false，compare_exchange_weak函数返回 false，并且参数 expected 的值不会改变。 对于某些不需要采用循环操作的算法而言, 通常采用compare_exchange_strong 更好。 std::atomic特化版本的成员函数fetch_add1234567if T is integral (1):T fetch_add (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;T fetch_add (T val, memory_order sync = memory_order_seq_cst) noexcept;if T is pointer (2) :T fetch_add (ptrdiff_t val, memory_order sync = memory_order_seq_cst) volatile noexcept;T fetch_add (ptrdiff_t val, memory_order sync = memory_order_seq_cst) noexcept; 将原子对象的封装值加 val，并返回原子对象的旧值（适用于整形和指针类型的 std::atomic 特化版本），整个过程是原子的。另外，如果第二个参数不指定（取默认参数 memory_order_seq_cst），则 fetch_add 相当与 std::atomic::operator+&#x3D;。 fetch_sub1234567if T is integral (1):T fetch_sub (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;T fetch_sub (T val, memory_order sync = memory_order_seq_cst) noexcept;if T is pointer (2):T fetch_sub (ptrdiff_t val, memory_order sync = memory_order_seq_cst) volatile noexcept;T fetch_sub (ptrdiff_t val, memory_order sync = memory_order_seq_cst) noexcept; 将原子对象的封装值减 val，并返回原子对象的旧值（适用于整形和指针类型的 std::atomic 特化版本），整个过程是原子的,另外，如果第二个参数不指定（取默认参数 memory_order_seq_cst），则 fetch_sub 相当与 std::atomic::operator-&#x3D;。 fetch_and12T fetch_and (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;T fetch_and (T val, memory_order sync = memory_order_seq_cst) noexcept; 将原子对象的封装值按位与 val，并返回原子对象的旧值（只适用于整型的 std::atomic 特化版本），整个过程是原子的,另外，如果第二个参数不指定（取默认参数 memory_order_seq_cst），则 fetch_and 相当与 std::atomic::operator&amp;&#x3D; fetch_or12T fetch_or (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;T fetch_or (T val, memory_order sync = memory_order_seq_cst) noexcept; 将原子对象的封装值按位或 val，并返回原子对象的旧值（只适用于整型的 std::atomic 特化版本），整个过程是原子的,另外，如果第二个参数不指定（取默认参数 memory_order_seq_cst），则 fetch_or 相当与 std::atomic::operator|&#x3D; fetch_xoroperator++operator–operator(comp.assign.)","comments":true,"tags":[{"name":"c++并发","slug":"c-并发","permalink":"https://kettycode.github.io/tags/c-%E5%B9%B6%E5%8F%91/"}]},{"title":"C++并发编程学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/并发编程/base/","text":"并发编程基础知识并发和并行并发：单个cpu在同一时间段内，多个任务同时执行，偏向于多个任务交替执行，在某一时刻其实只有一个任务在执行（单个CPU就可并发，比如时间片轮转机制）。指单个cpu同时处理多个线程任务，cpu在反复切换任务线程，实际还是串行化的。并行：同一时刻，多个任务同时执行（并行需要有多个CPU）。指多个cpu同时处理多个线程任务，cpu可以同时处理不同的任务，异步处理。 进程和线程进程，一个可执行程序运行起来就创建了一个进程。进程就是一个运行起来的可执行程序。进程是一个程序及其数据在处理机上顺序执行时所发生的活动。进程是具有独立功能的程序在一个数据集合上运行过程，它是系统进行资源分配和调度的一个独立单位。 在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”。一切进程至少都有一个执行线程。线程在进程内部运行，本质是在进程地址空间内运行。在Linux系统中，在CPU眼中，看到的PCB都要比传统的进程更加轻量化。透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程执行流。 与多线程编程相关的头文件: std::atomic和std::atomic_flag: std::thread和std::this_thread: std::mutex、std::lock_guard、std::unique_lock: std::condition_variable、std::condition_variable_any: std::promise、std::package_task、std::future、std::shared_future、std::async() 简单的程序std::thread “Hello World”1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::threadvoid thread_task() &#123; std::cout &lt;&lt; &quot;hello thread&quot; &lt;&lt; std::endl;&#125;/* * === FUNCTION ========================================================= * Name: main * Description: program entry routine. * ======================================================================== */int main(int argc, const char *argv[])&#123; std::thread t(thread_task); t.join(); return EXIT_SUCCESS;&#125;","comments":true,"tags":[{"name":"c++并发","slug":"c-并发","permalink":"https://kettycode.github.io/tags/c-%E5%B9%B6%E5%8F%91/"}]},{"title":"C++并发编程学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/并发编程/condition_variable/","text":"std::condition_variable当 std::condition_variable 对象的某个 wait 函数被调用的时候，它使用 std::unique_lock(通过 std::mutex) 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的 std::condition_variable 对象上调用了 notification 函数来唤醒当前线程。 std::condition_variable 对象通常使用 std::unique_lockstd::mutex 来等待，如果需要使用另外的 lockable 类型，可以使用 std::condition_variable_any 类，本文后面会讲到 std::condition_variable_any 的用法。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutex, std::unique_lock#include &lt;condition_variable&gt; // std::condition_variablestd::mutex mtx; // 全局互斥锁.std::condition_variable cv; // 全局条件变量.bool ready = false; // 全局标志位.void do_print_id(int id)&#123; std::unique_lock &lt;std::mutex&gt; lck(mtx); while (!ready) // 如果标志位不为 true, 则等待... cv.wait(lck); // 当前线程被阻塞, 当全局标志位变为 true 之后, // 线程被唤醒, 继续往下执行打印线程编号id. std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; id &lt;&lt; &#x27;\\n&#x27;;&#125;void go()&#123; std::unique_lock &lt;std::mutex&gt; lck(mtx); ready = true; // 设置全局标志位为 true. cv.notify_all(); // 唤醒所有线程.&#125;int main()&#123; std::thread threads[10]; // spawn 10 threads: for (int i = 0; i &lt; 10; ++i) threads[i] = std::thread(do_print_id, i); std::cout &lt;&lt; &quot;10 threads ready to race...\\n&quot;; go(); // go! for (auto &amp; th:threads) th.join(); return 0;&#125; std::condition_variable 构造函数std::condition_variable 的拷贝构造函数被禁用，只提供了默认构造函数 std::condition_variable::wait1.void wait(unique_lock&amp; lck);2.template void wait (unique_lock&amp; lck, Predicate pred);td::condition_variable 提供了两种 wait() 函数。 第一种情况，当前线程调用 wait() 后将被阻塞(此时当前线程应该获得了锁（mutex），不妨设获得锁 lck)，直到另外某个线程调用 notify_* 唤醒了当前线程。 在线程被阻塞时，该函数会自动调用 lck.unlock() 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知(notified，通常是另外某个线程调用 notify_* 唤醒了当前线程)，wait() 函数也是自动调用 lck.lock()，使得 lck 的状态和 wait 函数被调用时相同。 在第二种情况下（即设置了 Predicate），只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞。 类似while (!pred()) wait(lck); 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread, std::this_thread::yield#include &lt;mutex&gt; // std::mutex, std::unique_lock#include &lt;condition_variable&gt; // std::condition_variablestd::mutex mtx;std::condition_variable cv;int cargo = 0;bool shipment_available()&#123; return cargo != 0;&#125;// 消费者线程.void consume(int n)&#123; for (int i = 0; i &lt; n; ++i) &#123; std::unique_lock &lt;std::mutex&gt; lck(mtx); cv.wait(lck, shipment_available); std::cout &lt;&lt; cargo &lt;&lt; &#x27;\\n&#x27;; cargo = 0; &#125;&#125;int main()&#123; std::thread consumer_thread(consume, 10); // 消费者线程. // 主线程为生产者线程, 生产 10 个物品. for (int i = 0; i &lt; 10; ++i) &#123; while (shipment_available()) std::this_thread::yield(); std::unique_lock &lt;std::mutex&gt; lck(mtx); cargo = i + 1; cv.notify_one(); &#125; consumer_thread.join(); return 0;&#125; std::condition_variable::wait_for与std::condition_variable::wait类似 std::condition_variable::wait_until与std::condition_variable::wait_until类似 std::condition_variable::notify_one唤醒某个等待(wait)线程。如果当前没有等待线程，则该函数什么也不做，如果同时存在多个等待线程，则唤醒某个线程是不确定的(unspecified)。 std::condition_variable::notify_all唤醒所有的等待(wait)线程。如果当前没有等待线程，则该函数什么也不做。 std::condition_variable_any与 std::condition_variable 类似，只不过 std::condition_variable_any 的 wait 函数可以接受任何 lockable 参数，而 std::condition_variable 只能接受 std::unique_lockstd::mutex 类型的参数，除此以外，和 std::condition_variable 几乎完全一样。 std::cv_status枚举类cv_status::no_timeout: wait_for 或者 wait_until 没有超时，即在规定的时间段内线程收到了通知。cv_status::timeout: wait_for 或者 wait_until 超时。 std::notify_all_at_thread_exit123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutex, std::unique_lock#include &lt;condition_variable&gt; // std::condition_variablestd::mutex mtx;std::condition_variable cv;bool ready = false;void print_id (int id) &#123; std::unique_lock&lt;std::mutex&gt; lck(mtx); while (!ready) cv.wait(lck); // ... std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; id &lt;&lt; &#x27;\\n&#x27;;&#125;void go() &#123; std::unique_lock&lt;std::mutex&gt; lck(mtx); std::notify_all_at_thread_exit(cv,std::move(lck)); ready = true;&#125;int main ()&#123; std::thread threads[10]; // spawn 10 threads: for (int i=0; i&lt;10; ++i) threads[i] = std::thread(print_id,i); std::cout &lt;&lt; &quot;10 threads ready to race...\\n&quot;; std::thread(go).detach(); // go! for (auto&amp; th : threads) th.join(); return 0;&#125;","comments":true,"tags":[{"name":"c++并发","slug":"c-并发","permalink":"https://kettycode.github.io/tags/c-%E5%B9%B6%E5%8F%91/"}]},{"title":"C++并发编程学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/并发编程/future/","text":"std::futurestd::promise类promise 对象可以保存某一类型 T 的值，该值可被 future 对象读取（可能在另外一个线程中），因此 promise 也提供了一种线程同步的手段。在 promise 对象构造时可以和一个共享状态（通常是std::future）相关联，并可以在相关联的共享状态(std::future)上保存一个类型为 T 的值。 可以通过 get_future 来获取与该 promise 对象相关联的 future 对象，调用该函数之后，两个对象共享相同的共享状态(shared state) promise 对象是异步 Provider，它可以在某一时刻设置共享状态的值。future 对象可以异步返回共享状态的值，或者在必要的情况下阻塞调用者并等待共享状态标志变为 ready，然后才能获取共享状态的值 12345678910111213141516171819#include &lt;iostream&gt; // std::cout#include &lt;functional&gt; // std::ref#include &lt;thread&gt; // std::thread#include &lt;future&gt; // std::promise, std::futurevoid print_int(std::future&lt;int&gt;&amp; fut) &#123; int x = fut.get(); // 获取共享状态的值. std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; x &lt;&lt; &#x27;\\n&#x27;; // 打印 value: 10.&#125;int main ()&#123; std::promise&lt;int&gt; prom; // 生成一个 std::promise&lt;int&gt; 对象. std::future&lt;int&gt; fut = prom.get_future(); // 和 future 关联. std::thread t(print_int, std::ref(fut)); // 将 future 交给另外一个线程t. prom.set_value(10); // 设置共享状态的值, 此处和线程t保持同步. t.join(); return 0;&#125; std::promise构造函数默认构造函数，初始化一个空的共享状态。带自定义内存分配器的构造函数，与默认构造函数类似，但是使用自定义分配器来分配共享状态。拷贝构造函数，被禁用。移动构造函数。 另外，std::promise 的 operator&#x3D; 没有拷贝语义，即 std::promise 普通的赋值操作被禁用，operator&#x3D; 只有 move 语义，所以 std::promise 对象是禁止拷贝的 1234567891011121314151617181920212223242526#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;future&gt; // std::promise, std::futurestd::promise&lt;int&gt; prom;void print_global_promise () &#123; std::future&lt;int&gt; fut = prom.get_future(); int x = fut.get(); std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; x &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; std::thread th1(print_global_promise); prom.set_value(10); th1.join(); prom = std::promise&lt;int&gt;(); // prom 被move赋值为一个新的 promise 对象. std::thread th2 (print_global_promise); prom.set_value (20); th2.join(); return 0;&#125; std::packaged_task类std::packaged_task 包装一个可调用的对象，并且允许异步获取该可调用对象产生的结果，从包装可调用对象意义上来讲，std::packaged_task 与 std::function 类似，只不过 std::packaged_task 将其包装的可调用对象的执行结果传递给一个 std::future 对象（该对象通常在另外一个线程中获取 std::packaged_task 任务的执行结果）。 std::packaged_task 对象内部包含了两个最基本元素，一、被包装的任务(stored task)，任务(task)是一个可调用的对象，如函数指针、成员函数指针或者函数对象，二、共享状态(shared state)，用于保存任务的返回值，可以通过 std::future 对象来达到异步访问共享状态的效果。 可以通过 std::packged_task::get_future 来获取与共享状态相关联的 std::future 对象。在调用该函数之后，两个对象共享相同的共享状态，具体解释如下： std::packaged_task 对象是异步 Provider，它在某一时刻通过调用被包装的任务来设置共享状态的值。std::future 对象是一个异步返回对象，通过它可以获得共享状态的值，当然在必要的时候需要等待共享状态标志变为 ready.std::packaged_task 的共享状态的生命周期一直持续到最后一个与之相关联的对象被释放或者销毁为止。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt; // std::cout#include &lt;future&gt; // std::packaged_task, std::future#include &lt;chrono&gt; // std::chrono::seconds#include &lt;thread&gt; // std::thread, std::this_thread::sleep_for// count down taking a second for each value:int countdown (int from, int to) &#123; for (int i=from; i!=to; --i) &#123; std::cout &lt;&lt; i &lt;&lt; &#x27;\\n&#x27;; std::this_thread::sleep_for(std::chrono::seconds(1)); &#125; std::cout &lt;&lt; &quot;Finished!\\n&quot;; return from - to;&#125;int main ()&#123; std::packaged_task&lt;int(int,int)&gt; task(countdown); // 设置 packaged_task std::future&lt;int&gt; ret = task.get_future(); // 获得与 packaged_task 共享状态相关联的 future 对象. std::thread th(std::move(task), 10, 0); //创建一个新线程完成计数任务. int value = ret.get(); // 等待任务完成并获取结果. std::cout &lt;&lt; &quot;The countdown lasted for &quot; &lt;&lt; value &lt;&lt; &quot; seconds.\\n&quot;; th.join(); return 0;&#125; std::packaged_task构造函数std::packaged_task 构造函数共有 5 中形式，不过拷贝构造已经被禁用了。下面简单地介绍一下几种构造函数的语义： 默认构造函数，初始化一个空的共享状态，并且该 packaged_task 对象无包装任务。初始化一个共享状态，并且被包装任务由参数 fn 指定。带自定义内存分配器的构造函数，与默认构造函数类似，但是使用自定义分配器来分配共享状态。拷贝构造函数，被禁用。移动构造函数 123456789101112131415161718192021222324#include &lt;iostream&gt; // std::cout#include &lt;utility&gt; // std::move#include &lt;future&gt; // std::packaged_task, std::future#include &lt;thread&gt; // std::threadint main ()&#123; std::packaged_task&lt;int(int)&gt; foo; // 默认构造函数. // 使用 lambda 表达式初始化一个 packaged_task 对象. std::packaged_task&lt;int(int)&gt; bar([](int x)&#123;return x*2;&#125;); foo = std::move(bar); // move-赋值操作，也是 C++11 中的新特性. // 获取与 packaged_task 共享状态相关联的 future 对象. std::future&lt;int&gt; ret = foo.get_future(); std::thread(std::move(foo), 10).detach(); // 产生线程，调用被包装的任务. int value = ret.get(); // 等待任务完成并获取结果. std::cout &lt;&lt; &quot;The double of 10 is &quot; &lt;&lt; value &lt;&lt; &quot;.\\n&quot;;return 0;&#125; std::packaged_task::valid检查当前 packaged_task 是否和一个有效的共享状态相关联，对于由默认构造函数生成的 packaged_task 对象，该函数返回 false，除非中间进行了 move 赋值操作或者 swap 操作 1234567891011121314151617181920212223242526#include &lt;iostream&gt; // std::cout#include &lt;utility&gt; // std::move#include &lt;future&gt; // std::packaged_task, std::future#include &lt;thread&gt; // std::thread// 在新线程中启动一个 int(int) packaged_task.std::future&lt;int&gt; launcher(std::packaged_task&lt;int(int)&gt;&amp; tsk, int arg)&#123; if (tsk.valid()) &#123; std::future&lt;int&gt; ret = tsk.get_future(); std::thread (std::move(tsk),arg).detach(); return ret; &#125; else return std::future&lt;int&gt;();&#125;int main ()&#123; std::packaged_task&lt;int(int)&gt; tsk([](int x)&#123;return x*2;&#125;); std::future&lt;int&gt; fut = launcher(tsk,25); std::cout &lt;&lt; &quot;The double of 25 is &quot; &lt;&lt; fut.get() &lt;&lt; &quot;.\\n&quot;; return 0;&#125; std::packaged_task::reset重置 packaged_task 的共享状态，但是保留之前的被包装的任务 std::packaged_task::swap交换 packaged_task 的共享状态 std::future 类std::future 究竟是什么呢？简单地说，std::future 可以用来获取异步任务的结果，因此可以把它当成一种简单的线程间同步的手段。std::future 通常由某个 Provider 创建，你可以把 Provider 想象成一个异步任务的提供者，Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 std::future 对象调用 get（通常在另外一个线程中） 获取该值，如果共享状态的标志不为 ready，则调用 std::future::get 会阻塞当前的调用者，直到 Provider 设置了共享状态的值（此时共享状态的标志变为 ready），std::future::get 返回异步任务的值或异常（如果发生了异常）。 一个有效(valid)的 std::future 对象通常由以下三种 Provider 创建，并和某个共享状态相关联。Provider 可以是函数或者类，其实我们前面都已经提到了，他们分别是： std::async 函数，本文后面会介绍 std::async() 函数。std::promise::get_future，get_future 为 promise 类的成员函数std::packaged_task::get_future， get_future为 packaged_task 的成员函数一个 std::future 对象只有在有效(valid)的情况下才有用(useful)，由 std::future 默认构造函数创建的 future 对象不是有效的（除非当前非有效的 future 对象被 move 赋值另一个有效的 future 对象）。 在一个有效的 future 对象上调用 get 会阻塞当前的调用者，直到 Provider 设置了共享状态的值或异常（此时共享状态的标志变为 ready），std::future::get 将返回异步任务的值或异常（如果发生了异常）。 std::async123456789101112131415161718192021222324252627282930313233// future example#include &lt;iostream&gt; // std::cout#include &lt;future&gt; // std::async, std::future#include &lt;chrono&gt; // std::chrono::milliseconds// a non-optimized way of checking for prime numbers:boolis_prime(int x)&#123; for (int i = 2; i &lt; x; ++i) if (x % i == 0) return false; return true;&#125;intmain()&#123; // call function asynchronously: std::future &lt; bool &gt; fut = std::async(is_prime, 444444443); // do something while waiting for function to set future: std::cout &lt;&lt; &quot;checking, please wait&quot;; std::chrono::milliseconds span(100); while (fut.wait_for(span) == std::future_status::timeout) std::cout &lt;&lt; &#x27;.&#x27;; bool x = fut.get(); // retrieve return value std::cout &lt;&lt; &quot;\\n444444443 &quot; &lt;&lt; (x ? &quot;is&quot; : &quot;is not&quot;) &lt;&lt; &quot; prime.\\n&quot;; return 0;&#125; std::future构造函数std::future 的拷贝构造函数是被禁用的，只提供了默认的构造函数和 move 构造函数。另外，std::future 的普通赋值操作也被禁用，只提供了 move 赋值操作 std::future::share返回一个 std::shared_future 对象，调用该函数之后，该 std::future 对象本身已经不和任何共享状态相关联，因此该 std::future 的状态不再是 valid 的了。 12345678910111213141516#include &lt;iostream&gt; // std::cout#include &lt;future&gt; // std::async, std::future, std::shared_futureint do_get_value() &#123; return 10; &#125;int main ()&#123; std::future&lt;int&gt; fut = std::async(do_get_value); std::shared_future&lt;int&gt; shared_fut = fut.share(); // 共享的 future 对象可以被多次访问. std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; shared_fut.get() &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; &quot;its double: &quot; &lt;&lt; shared_fut.get()*2 &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; std::future::get当与该 std::future 对象相关联的共享状态标志变为 ready 后，调用该函数将返回保存在共享状态中的值，如果共享状态的标志不为 ready，则调用该函数会阻塞当前的调用者，而此后一旦共享状态的标志变为 ready，get 返回 Provider 所设置的共享状态的值或者异常（如果抛出了异常） std::future::valid检查当前的 std::future 对象是否有效，即释放与某个共享状态相关联。一个有效的 std::future 对象只能通过 std::async(), std::future::get_future 或者 std::packaged_task::get_future 来初始化。 std::future::wait等待与当前std::future 对象相关联的共享状态的标志变为 ready. 如果共享状态的标志不是 ready（此时 Provider 没有在共享状态上设置值（或者异常）），调用该函数会被阻塞当前线程，直到共享状态的标志变为 ready。一旦共享状态的标志变为 ready，wait() 函数返回，当前线程被解除阻塞，但是 wait() 并不读取共享状态的值或者异常。 std::future::wait_for与 std::future::wait() 的功能类似，即等待与该 std::future 对象相关联的共享状态的标志变为 ready，而与 std::future::wait() 不同的是，wait_for() 可以设置一个时间段 rel_time，如果共享状态的标志在该时间段结束之前没有被 Provider 设置为 ready，则调用 wait_for 的线程被阻塞，在等待了 rel_time 的时间长度后 wait_for() 返回(future_status::ready、future_status::timeout、future_status::deferred) std::future::wait_until与std::future::wait_for类似 std::shared_future类std::shared_future 与 std::future 类似，但是 std::shared_future 可以拷贝、多个 std::shared_future 可以共享某个共享状态的最终结果(即共享状态的某个值或者异常)。shared_future 可以通过某个 std::future 对象隐式转换（参见 std::shared_future 的构造函数），或者通过 std::future::share() 显示转换，无论哪种转换，被转换的那个 std::future 对象都会变为 not-valid. std::future_error类std::future_error 继承子 C++ 标准异常体系中的 logic_error std::future枚举类enum class future_errc;enum class future_status;enum class launch;下面分别介绍以上三种枚举类型： std::future_errc 类型描述如下（参考）：类型 取值 描述broken_promise 0 与该 std::future 共享状态相关联的 std::promise 对象在设置值或者异常之前一被销毁。future_already_retrieved 1 与该 std::future 对象相关联的共享状态的值已经被当前 Provider 获取了，即调用了 std::future::get 函数。promise_already_satisfied 2 std::promise 对象已经对共享状态设置了某一值或者异常。no_state 3 无共享状态。 std::future_status 类型主要用在 std::future(或std::shared_future)中的 wait_for 和 wait_until 两个函数中的。类型 取值 描述future_status::ready 0 wait_for(或wait_until) 因为共享状态的标志变为 ready 而返回。future_status::timeout 1 超时，即 wait_for(或wait_until) 因为在指定的时间段（或时刻）内共享状态的标志依然没有变为 ready 而返回。future_status::deferred 2 共享状态包含了 deferred 函数。 std::launch 类型，该枚举类型主要是在调用 std::async 设置异步任务的启动策略的。 类型 描述launch::async Asynchronous: 异步任务会在另外一个线程中调用，并通过共享状态返回异步任务的结果（一般是调用 std::future::get() 获取异步任务的结果）。launch::deferred Deferred: 异步任务将会在共享状态被访问时调用，相当与按需调用（即延迟(deferred)调用）。","comments":true,"tags":[{"name":"c++并发","slug":"c-并发","permalink":"https://kettycode.github.io/tags/c-%E5%B9%B6%E5%8F%91/"}]},{"title":"C++模板学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/泛型编程/template1/","text":"注意：模板学习内容均参考 https://github.com/actuatorpro/CppTemplateTutorial.git, 可自主去github上学习 1. 前言1.1. C++另类简介：比你用的复杂，但比你想的简单C++似乎从它为世人所知的那天开始便成为天然的话题性编程语言。在它在周围有着形形色色的赞美与贬低之词。当我在微博上透露欲写此文的意愿时，也收到了很多褒贬不一的评论。作为一门语言，能拥有这么多使用并恨着它、使用并畏惧它的用户，也算是语言丛林里的奇观了。 C++之所以变成一门层次丰富、结构多变、语法繁冗的语言，是有着多层次的原因的。Bjarne在《The Design and Evolution of C++》一书中，详细的解释了C++为什么会变成如今（C++98&#x2F;03）的模样。这本书也是我和陈梓瀚一直对各位已经入门的新手强烈推荐的一本书。通过它你多少可以明白，C++的诸多语法要素之所以变成如今的模样，实属迫不得已。 模板作为C++中最有特色的语言特性，它堪称玄学的语法和语义，理所应当的成为初学者的梦魇。甚至很多工作多年的人也对C++的模板部分保有充分的敬畏。在多数的编码标准中，Template俨然和多重继承一样，成为了一般程序员（非程序库撰写者）的禁区。甚至运用模板较多的Boost，也成为了“众矢之的”。 但是实际上C++模板远没有想象的那么复杂。我们只需要换一个视角：在C++03的时候，模板本身就可以独立成为一门“语言”。它有“值”，有“函数”，有“表达式”和“语句”。除了语法比较蹩脚外，它既没有指针也没有数组，更没有C++里面复杂的继承和多态。可以说，它要比C语言要简单的多。如果我们把模板当做是一门语言来学习，那只需要花费学习OO零头的时间即可掌握。按照这样的思路，可以说在各种模板书籍中出现的多数技巧，都可以被轻松理解。 简单回顾一下模板的历史。87年的时候，泛型（Generic Programming）便被纳入了C++的考虑范畴，并直接导致了后来模板语法的产生。可以说模板语法一开始就是为了在C++中提供泛型机制。92年的时候，Alexander Stepanov开始研究利用模板语法制作程序库，后来这一程序库发展成STL，并在93年被接纳入标准中。 此时不少人以为STL已经是C++模板的集大成之作，C++模板技止于此。但是在95年的《C++ Report》上，John Barton和Lee Nackman提出了一个矩阵乘法的模板示例。可以说元编程在那个时候开始被很多人所关注。自此篇文章发表之后，很多大牛都开始对模板产生了浓厚的兴趣。其中对元编程技法贡献最大的当属Alexandrescu的《Modern C++ Design》及模板程序库Loki。这一2001年发表的图书间接地导致了模板元编程库的出现。书中所使用的Typelist等泛型组件，和Policy等设计方法令人耳目一新。但是因为全书用的是近乎Geek的手法来构造一切设施，因此使得此书阅读起来略有难度。 2002年出版的另一本书《C++ Templates》，可以说是在Template方面的集大成之作。它详细阐述了模板的语法、提供了和模板有关的语言细节信息，举了很多有代表性例子。但是对于模板新手来说，这本书细节如此丰富，让他们随随便便就打了退堂鼓缴械投降。 本文的写作初衷，就是通过“编程语言”的视角，介绍一个简单、清晰的“模板语言”。我会尽可能地将模板的诸多要素连串起来，用一些简单的例子帮助读者学习这门“语言”，让读者在编写、阅读模板代码的时候，能像 if(exp) &#123; dosomething(); &#125;一样的信手拈来，让“模板元编程”技术成为读者牢固掌握、可举一反三的有用技能。 1.2. 适宜读者群因为本文并不是用于C++入门，例子中也多少会牵涉一些其它知识，因此如果读者能够具备以下条件，会读起来更加轻松： 熟悉C++的基本语法； 使用过STL； 熟悉一些常用的算法，以及递归等程序设计方法。 此外，尽管第一章会介绍一些Template的基本语法，但是还是会略显单薄。因此也希望读者能对C++ Template最基本语法形式有所了解和掌握；如果会编写基本的函数模板和类模板那就更好了。 诚如上节所述，本文并不是《C++ Templates》的简单重复，与《Modern C++ Design》交叠更少。从知识结构上，我建议大家可以先读本文，再阅读《C++ Templates》获取更丰富的语法与实现细节，以更进一步；《Modern C++ Design》除了元编程之外，还有很多的泛型编程示例，原则上泛型编程的部分与我所述的内容交叉不大，读者在读完1-3章了解模板的基本规则之后便可阅读《MCD》的相应章节；元编程部分（如Typelist）建议在阅读完本文之后再行阅读，或许会更易理解。 1.3. 版权本文是随写随即同步到Github上，因此在行文中难免会遗漏引用。本文绝大部分内容应是直接承出我笔，但是也不定会有他山之石。所有指涉内容我会尽量以引号框记，或在上下文和边角注记中标示，如有遗漏烦请不吝指出。 全文所有为我所撰写的部分，作者均保留所有版权。如果有需要转帖或引用，还请注明出处并告知于我。 1.4. 推荐编译环境C++编译器众多，且对模板的支持可能存在细微差别。如果没有特别强调，本书行文过程中，使用了下列编译器来测试文中提供的代码和示例： Clang 14.0.3; 15.0 (amd64) Visual Studio 2022 19.2+ (amd64) 此外，部分复杂实例我们还在文中提供了在线的编译器预览以方便大家阅读和测试。在线编译器参见： gcc.godbolt.org。 一些示例中用到的特性所对应的C++标准： 特性 标准 std::decay_t C++ 14 1.5. 体例1.5.1. 示例代码123void SampleCode() &#123; // 这是一段示例代码&#125; 1.5.2. 引用引用自C++标准： 1.1.2&#x2F;1 这是一段引用或翻译自标准的文字 引用自其他图书： 《书名》这是一段引用或翻译自其他图书的文字 1.6. 意见、建议、喷、补遗、写作计划 需增加： 模板的使用动机。 增加“如何使用本文”一节。本节将说明全书的体例（强调字体、提示语、例子的组织），所有的描述、举例、引用在重审时将按照体例要求重新组织。 除了用于描述语法的例子外，其他例子将尽量赋予实际意义，以方便阐述意图。 在合适的章节完整叙述模板的类型推导规则。Parameter-Argument, auto variable, decltype, decltype(auto) 在函数模板重载和实例化的部分讲述ADL。 变参模板处应当按照标准（Argument Packing&#x2F;Unpacking）来讲解。 建议： 比较模板和函数的差异性 蓝色：C++14 Return type deduction for normal functions 的分析","comments":true,"tags":[{"name":"c++ template","slug":"c-template","permalink":"https://kettycode.github.io/tags/c-template/"}]},{"title":"C++并发编程学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/并发编程/memory/","text":"内存模型原子类型的大多数 API 都需要程序员提供一个 std::memory_order（可译为内存序，访存顺序） 的枚举类型值作为参数，比如：atomic_store，atomic_load，atomic_exchange，atomic_compare_exchange 等 API 的最后一个形参为 std::memory_order order，默认值是 std::memory_order_seq_cst（顺序一致性）。那么究竟什么是 std::memory_order 呢，为了解答这个问题，我们先来讨论 C++11 的内存模型。 一般来讲，内存模型可分为静态内存模型和动态内存模型，静态内存模型主要涉及类的对象在内存中是如何存放的，即从结构(structural)方面来看一个对象在内存中的布局。动态内存模型可理解为存储一致性模型，主要是从行为(behavioral)方面来看多个线程对同一个对象同时(读写)操作时(concurrency)所做的约束，动态内存模型理解起来稍微复杂一些，涉及了内存，Cache，CPU 各个层次的交互，尤其是在共享存储系统中，为了保证程序执行的正确性，就需要对访存事件施加严格的限制。 std::memory_order 规定了普通访存操作和相邻的原子访存操作之间的次序是如何安排的，在多核系统中，当多个线程同时读写多个变量时，其中的某个线程所看到的变量值的改变顺序可能和其他线程写入变量值的次序不相同。同时，不同的线程所观察到的某变量被修改次序也可能不相同。然而，如果保证所有对原子变量的操作都是顺序的话，可能对程序的性能影响很大，因此，我们可以通过 std::memory_order 来指定编译器对访存次序所做的限制。因此，在原子类型的 API 中，我们可以通过额外的参数指定该原子操作的访存次序(内存序)，默认的内存序是 std::memory_order_seq_cst。 我们可以把上述 6 中访存次序(内存序)分为 3 类，顺序一致性模型(std::memory_order_seq_cst)，Acquire-Release 模型(std::memory_order_consume, std::memory_order_acquire, std::memory_order_release, std::memory_order_acq_rel,) 和 Relax 模型(std::memory_order_relaxed)。三种不同的内存模型在不同类型的 CPU上(如 X86，ARM，PowerPC等)所带来的代价也不一样。例如，在 X86 或者 X86-64平台下，Acquire-Release 类型的访存序不需要额外的指令来保证原子性，即使顺序一致性类型操作也只需要在写操作(Store)时施加少量的限制，而在读操作(Load)则不需要花费额外的代价来保证原子性。 处理器一致性(Processor Consistency)模型：处理器一致性(Processor Consistency)模型比顺序一致性模型弱，因此对于某些在顺序一致性模型下能够正确执行的程序在处理器一致性条件下执行时可能会导致错误的结果，处理器一致性模型对访存事件发生次序施加的限制是：(1). 在任意读操作(Load)被允许执行之前，所有在同一处理器中先于这一 Load 的读操作都已完成；(2). 在任意写操作(Store)被允许执行之前，所有在同一处理器中先于这一 Store 的访存操作(包括 Load 和 Store操作)都已完成。上述条件允许 Store 之后的 Load 越过 Store 操作而有限执行。 弱一致性(Weak Consistency)模型：弱一致性(Weak Consistency)模型的主要思想是将同步操作和普通的访存操作区分开来，程序员必须用硬件可识别的同步操作把对可写共享单元的访存保护起来，以保证多个处理器对可写单元的访问是互斥的。弱一致性对访存事件发生次序的限制如下：(1). 同步操作的执行满足顺序一致性条件; (2). 在任一普通访存操作被允许执行之前，所有在同一处理器中先于这一访存操作的同步操作都已完成; (3). 在任一同步操作被允许执行之前，所有在同一处理器中先于这一同步操作的普通操作都已完成。上述条件允许在同步操作之间的普通访存操作执行时不用考虑进程之间的相关，虽然弱一致性增加了程序员的负担，但是它能有效地提高系统的性能。 释放一致性(Release Consistency)模型：释放一致性(Release Consistency)模型是对弱一致性(Weak Consistency)模型的改进，它把同步操作进一步分成了获取操作(Acquire)和释放操作(Release)。Acquire 用于获取对某些共享变量的独占访问权，而 Release 则用于释放这种访问权，释放一致性(Release Consistency)模型访存事件发生次序的限制如下：(1). 同步操作的执行满足顺序一致性条件; (2). 在任一普通访存操作被允许执行之前，所有在同一处理器中先于这一访存操作的 Acquire 操作都已完成; (3). 在任一 Release 操作被允许执行之前，所有在同一处理器中先于这一 Release 操作的普通操作都已完成。 在硬件实现的释放一致性模型中，对共享单元的访存是及时进行的，并在执行获取操作(Acquire)和释放操作(Release)时对齐。在共享虚拟存储系统或者在由软件维护的数据一致性的共享存储系统中，由于通信和数据交换的开销很大，有必要减少通信和数据交换的次数。为此，人们在释放一致性(Release Consistency)模型的基础上提出了急切更新释放一致性模型(Eager Release Consistency)和懒惰更新释放一致性模型(Lazy Release Consistency)。在急切更新释放一致性模型中，在临界区内的多个存数操作对共享内存的更新不是及时进行的，而是在执行 Release 操作之前(即退出临界区之前)集中进行，把多个存数操作合并在一起统一执行，从而减少了通信次数。而在懒惰更新释放一致性模型中，由一个处理器对某单元的存数操作并不是由此处理器主动传播到所有共享该单元的其他处理器，而是在其他处理器要用到此处理器所写的数据时(即其他处理器执行 Acquire 操作时)再向此处理器索取该单元的最新备份，这样可以进一步减少通信量。","comments":true,"tags":[{"name":"c++并发","slug":"c-并发","permalink":"https://kettycode.github.io/tags/c-%E5%B9%B6%E5%8F%91/"}]},{"title":"C++并发编程学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/并发编程/mutex/","text":"mutexMutex 系列类std::mutex : 最基本的Mutex类std::recursive_mutex : 递归Mutex类std::time_mutex : 定时Mutex类std::recursive_timed_mutex : 定时递归Mutex类 Lock类std::lock_guard : 与Mutex RAII相关，方便线程对互斥量上锁。std::unique_lock : 与Mutex RAII相关，但提供了更好的上锁和解锁控制 其他类型std::once_flagstd::adopt_lock_tstd::defer_lock_tstd::try_to_lock_t 函数std::try_lock : 尝试同时对多个互斥量上锁std::lock : 可以同时对多个互斥量上锁std::call_once : 如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。 std::mutex介绍std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。 构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。unlock()， 解锁，释放对互斥量的所有权。try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 1234567891011121314151617181920212223242526#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutexvolatile int counter(0); // non-atomic counterstd::mutex mtx; // locks access to countervoid attempt_10k_increases() &#123; for (int i=0; i&lt;10000; ++i) &#123; if (mtx.try_lock()) &#123; // only increase if currently not locked: ++counter; mtx.unlock(); &#125; &#125;&#125;int main (int argc, const char* argv[]) &#123; std::thread threads[10]; for (int i=0; i&lt;10; ++i) threads[i] = std::thread(attempt_10k_increases); for (auto&amp; th : threads) th.join(); std::cout &lt;&lt; counter &lt;&lt; &quot; successful increases of the counter.\\n&quot;; return 0;&#125; std::recursive_mutexstd::recursive_mutex 与 std::mutex 一样，也是一种可以被上锁的对象，但是和 std::mutex 不同的是，std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。 std::time_mutexstd::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()。 try_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 try_lock_until 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt; // std::cout#include &lt;chrono&gt; // std::chrono::milliseconds#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::timed_mutexstd::timed_mutex mtx;void fireworks() &#123; // waiting to get a lock: each thread prints &quot;-&quot; every 200ms: while (!mtx.try_lock_for(std::chrono::milliseconds(200))) &#123; std::cout &lt;&lt; &quot;-&quot;; &#125; // got a lock! - wait for 1s, then this thread prints &quot;*&quot; std::this_thread::sleep_for(std::chrono::milliseconds(1000)); std::cout &lt;&lt; &quot;*\\n&quot;; mtx.unlock();&#125;int main ()&#123; std::thread threads[10]; // spawn 10 threads: for (int i=0; i&lt;10; ++i) threads[i] = std::thread(fireworks); for (auto&amp; th : threads) th.join(); return 0;&#125; std::recursive_timed_mutexstd::recursive_timed_mutex 和 std::recursive_mutex 与 std::mutex 的关系一样，std::recursive_timed_mutex 的特性也可以从 std::timed_mutex 推导出来。 std::lock_guard与Mutex RAII相关，方便线程对互斥量上锁，(初始化时自动上锁，作用域结束后自动解锁) 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutex, std::lock_guard#include &lt;stdexcept&gt; // std::logic_errorstd::mutex mtx;void print_even (int x) &#123; if (x%2==0) std::cout &lt;&lt; x &lt;&lt; &quot; is even\\n&quot;; else throw (std::logic_error(&quot;not even&quot;));&#125;void print_thread_id (int id) &#123; try &#123; // using a local lock_guard to lock mtx guarantees unlocking on destruction / exception: std::lock_guard&lt;std::mutex&gt; lck (mtx); print_even(id); &#125; catch (std::logic_error&amp;) &#123; std::cout &lt;&lt; &quot;[exception caught]\\n&quot;; &#125;&#125;int main ()&#123; std::thread threads[10]; // spawn 10 threads: for (int i=0; i&lt;10; ++i) threads[i] = std::thread(print_thread_id,i+1); for (auto&amp; th : threads) th.join(); return 0;&#125; std::unique_lock与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制unique_lock比lock_guard能提供更多的功能特性（但需要付出性能的一些代价） 12345678910111213141516171819202122232425#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread#include &lt;mutex&gt; // std::mutex, std::unique_lockstd::mutex mtx; // mutex for critical sectionvoid print_block (int n, char c) &#123; // critical section (exclusive access to std::cout signaled by lifetime of lck): std::unique_lock&lt;std::mutex&gt; lck (mtx); for (int i=0; i&lt;n; ++i) &#123; std::cout &lt;&lt; c; &#125; std::cout &lt;&lt; &#x27;\\n&#x27;;&#125;int main ()&#123; std::thread th1 (print_block,50,&#x27;*&#x27;); std::thread th2 (print_block,50,&#x27;$&#x27;); th1.join(); th2.join(); return 0;&#125; std::call_oncestd::call_once 是 C++ 标准库提供的一个函数，用于保证一个函数只会被调用一次，即使在多线程环境下也能确保线程安全。std::call_once 主要用于执行只需要执行一次的初始化操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;thread&gt; std::once_flag flag1, flag2; void simple_do_once()&#123; std::call_once(flag1, []()&#123; std::cout &lt;&lt; &quot;简单样例：调用一次\\n&quot;; &#125;);&#125; void may_throw_function(bool do_throw)&#123; if (do_throw) &#123; std::cout &lt;&lt; &quot;抛出：call_once 会重试\\n&quot;; // 这会出现不止一次 throw std::exception(); &#125; std::cout &lt;&lt; &quot;没有抛出，call_once 不会再重试\\n&quot;; // 保证一次&#125; void do_once(bool do_throw)&#123; try &#123; std::call_once(flag2, may_throw_function, do_throw); &#125; catch (...) &#123;&#125;&#125; int main()&#123; std::thread st1(simple_do_once); std::thread st2(simple_do_once); std::thread st3(simple_do_once); std::thread st4(simple_do_once); st1.join(); st2.join(); st3.join(); st4.join(); std::thread t1(do_once, true); std::thread t2(do_once, true); std::thread t3(do_once, false); std::thread t4(do_once, true); t1.join(); t2.join(); t3.join(); t4.join();&#125;","comments":true,"tags":[{"name":"c++并发","slug":"c-并发","permalink":"https://kettycode.github.io/tags/c-%E5%B9%B6%E5%8F%91/"}]},{"title":"C++并发编程学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/并发编程/thread/","text":"threadstd::thread构造(1). 默认构造函数，创建一个空的 thread 执行对象。(2). 初始化构造函数，创建一个 thread对象，该 thread对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出。(3). 拷贝构造函数(被禁用)，意味着 thread 不可被拷贝构造。(4). move 构造函数，move 构造函数，调用成功之后 x 不代表任何 thread 执行对象。注意：可被 joinable 的 thread 对象必须在他们销毁之前被主线程 join 或者将其设置为 detached. 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;functional&gt;#include &lt;atomic&gt; void f1(int n)&#123; for (int i = 0; i &lt; 5; ++i) &#123; std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; n &lt;&lt; &quot; executing\\n&quot;; std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125;&#125; void f2(int&amp; n)&#123; for (int i = 0; i &lt; 5; ++i) &#123; std::cout &lt;&lt; &quot;Thread 2 executing\\n&quot;; ++n; std::this_thread::sleep_for(std::chrono::milliseconds(10)); &#125;&#125; int main()&#123; int n = 0; std::thread t1; // t1 is not a thread std::thread t2(f1, n + 1); // pass by value std::thread t3(f2, std::ref(n)); // pass by reference std::thread t4(std::move(t3)); // t4 is now running f2(). t3 is no longer a thread t2.join(); t4.join(); std::cout &lt;&lt; &quot;Final value of n is &quot; &lt;&lt; n &lt;&lt; &#x27;\\n&#x27;;&#125; std::thread赋值操作：(1). move 赋值操作，如果当前对象不可 joinable，需要传递一个右值引用(rhs)给 move 赋值操作；如果当前对象可被 joinable，则 terminate() 报错。(2). 拷贝赋值操作被禁用，thread 对象不可被拷贝 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;chrono&gt; // std::chrono::seconds#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread, std::this_thread::sleep_forvoid thread_task(int n) &#123; std::this_thread::sleep_for(std::chrono::seconds(n)); std::cout &lt;&lt; &quot;hello thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; paused &quot; &lt;&lt; n &lt;&lt; &quot; seconds&quot; &lt;&lt; std::endl;&#125;/* * === FUNCTION ========================================================= * Name: main * Description: program entry routine. * ======================================================================== */int main(int argc, const char *argv[])&#123; std::thread threads[5]; std::cout &lt;&lt; &quot;Spawning 5 threads...\\n&quot;; for (int i = 0; i &lt; 5; i++) &#123; threads[i] = std::thread(thread_task, i + 1); &#125; std::cout &lt;&lt; &quot;Done spawning threads! Now wait for them to join\\n&quot;; for (auto&amp; t: threads) &#123; t.join(); &#125; std::cout &lt;&lt; &quot;All threads joined.\\n&quot;; return EXIT_SUCCESS;&#125; 其他成员函数 get_id() 1atd::thread::id main_thread_id = std::this_thread::get_id(); joinable() 12345678910111213std::thread foo;std::thread bar(mythread);std::cout &lt;&lt; &quot;Joinable after construction:\\n&quot; &lt;&lt; std::boolalpha;std::cout &lt;&lt; &quot;foo: &quot; &lt;&lt; foo.joinable() &lt;&lt; &#x27;\\n&#x27;;//falsestd::cout &lt;&lt; &quot;bar: &quot; &lt;&lt; bar.joinable() &lt;&lt; &#x27;\\n&#x27;;//trueif (foo.joinable()) foo.join();if (bar.joinable()) bar.join();std::cout &lt;&lt; &quot;Joinable after joining:\\n&quot; &lt;&lt; std::boolalpha;std::cout &lt;&lt; &quot;foo: &quot; &lt;&lt; foo.joinable() &lt;&lt; &#x27;\\n&#x27;;//falsestd::cout &lt;&lt; &quot;bar: &quot; &lt;&lt; bar.joinable() &lt;&lt; &#x27;\\n&#x27;;//false join() &#x2F;&#x2F;等待线程完成其执行 detach() &#x2F;&#x2F;允许线程独立执行 1234567891011121314151617181920212223#include &lt;iostream&gt; // std::cout#include &lt;thread&gt; // std::thread, std::this_thread::sleep_for#include &lt;chrono&gt; // std::chrono::seconds void pause_thread(int n) &#123; std::this_thread::sleep_for (std::chrono::seconds(n)); std::cout &lt;&lt; &quot;pause of &quot; &lt;&lt; n &lt;&lt; &quot; seconds ended\\n&quot;;&#125; int main() &#123; std::cout &lt;&lt; &quot;Spawning and detaching 3 threads...\\n&quot;; std::thread (pause_thread,1).detach(); std::thread (pause_thread,2).detach(); std::thread (pause_thread,3).detach(); std::cout &lt;&lt; &quot;Done spawning threads.\\n&quot;; std::cout &lt;&lt; &quot;(the main thread will now pause for 5 seconds)\\n&quot;; // give the detached threads time to finish (but not guaranteed!): pause_thread(5); return 0;&#125; swap() &#x2F;&#x2F;Swaps the state of the object with that of x. native_handle()std::thread::native_handle_type nht &#x3D; std::thread::native_handle();","comments":true,"tags":[{"name":"c++并发","slug":"c-并发","permalink":"https://kettycode.github.io/tags/c-%E5%B9%B6%E5%8F%91/"}]},{"title":"C++模板学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/泛型编程/template2/","text":"2. Template的基本语法2.1. 什么是模板(Template)2.2. 类模板 (Class Template) 的基本语法2.2.1. “模板类”还是“类模板”2.2.2. Class Template的与成员变量定义我们来回顾一下最基本的Class Template声明和定义形式： Class Template声明： 1template &lt;typename T&gt; class ClassA; Class Template定义： 1234template &lt;typename T&gt; class ClassA&#123; T member;&#125;; template 是C++关键字，意味着我们接下来将定义一个模板。和函数一样，模板也有一系列参数。这些参数都被囊括在template之后的&lt; &gt;中。在上文的例子中， typename T便是模板参数。回顾一下与之相似的函数参数的声明形式： 1void foo(int a); T则可以类比为函数形参a，这里的“模板形参”T，也同函数形参一样取成任何你想要的名字；typename则类似于例子中函数参数类型int，它表示模板参数中的T将匹配一个类型。除了 typename 之外，我们在后面还要讲到，整型也可以作为模板的参数。 在定义完模板参数之后，便可以定义你所需要的类。不过在定义类的时候，除了一般类可以使用的类型外，你还可以使用在模板参数中使用的类型 T。可以说，这个 T是模板的精髓，因为你可以通过指定模板实参，将T替换成你所需要的类型。 例如我们用ClassA&lt;int&gt;来实例化类模板ClassA，那么ClassA&lt;int&gt;可以等同于以下的定义： 1234// 注意：这并不是有效的C++语法，只是为了说明模板的作用typedef class &#123; int member;&#125; ClassA&lt;int&gt;; 可以看出，通过模板参数替换类型，可以获得很多形式相同的新类型，有效减少了代码量。这种用法，我们称之为“泛型”（Generic Programming），它最常见的应用，即是STL中的容器类模板。 2.2.3. 模板的使用对于C++来说，类型最重要的作用之一就是用它去产生一个变量。例如我们定义了一个动态数组（列表）的类模板vector，它对于任意的元素类型都具有push_back和clear的操作，我们便可以如下定义这个类： 12345678910template &lt;typename T&gt;class vector&#123;public: void push_back(T const&amp;); void clear(); private: T* elements;&#125;; 此时我们的程序需要一个整型和一个浮点型的列表，那么便可以通过以下代码获得两个变量： 12vector&lt;int&gt; intArray;vector&lt;float&gt; floatArray; 此时我们就可以执行以下的操作，获得我们想要的结果： 12intArray.push_back(5);floatArray.push_back(3.0f); 变量定义的过程可以分成两步来看：第一步，vector&lt;int&gt;将int绑定到类模板vector上，获得了一个“普通的类vector&lt;int&gt;”；第二步通过“vector”定义了一个变量。与“普通的类”不同，类模板是不能直接用来定义变量的 —— 毕竟它的名字是“模板”而不是“类”。例如： 1vector unknownVector; // 错误示例 这样就是错误的。我们把通过类型绑定将类模板变成“普通的类”的过程，称之为模板实例化（Template Instantiate）。实例化的语法是： 1模板名 &lt; [模板实参1，模板实参2，...] &gt; 看几个例子： 123456789vector&lt;int&gt;ClassA&lt;double&gt;template &lt;typename T0, typename T1&gt; class ClassB&#123; // Class body ...&#125;;ClassB&lt;int, float&gt; 当然，在实例化过程中，被绑定到模板参数上的类型（即模板实参）需要与模板形参正确匹配。就如同函数一样，如果没有提供足够并匹配的参数，模板便不能正确的实例化。 2.2.4. 类模板的成员函数定义由于C++11正式废弃“模板导出”这一特性，因此在类模板的变量在调用成员函数的时候，需要看到完整的成员函数定义。因此现在的类模板中的成员函数，通常都是以内联的方式实现。例如： 123456789101112template &lt;typename T&gt;class vector&#123;public: void clear() &#123; // Function body &#125; private: T* elements;&#125;; 当然，我们也可以将vector&lt;T&gt;::clear的定义部分放在类型之外，只不过这个时候的语法就显得蹩脚许多： 1234567891011121314template &lt;typename T&gt;class vector&#123;public: void clear(); // 注意这里只有声明private: T* elements;&#125;;template &lt;typename T&gt;void vector&lt;T&gt;::clear() // 函数的实现放在这里&#123; // Function body&#125; 函数的实现部分看起来略微拗口。我第一次学到的时候，觉得 1234void vector::clear()&#123; // Function body&#125; 这样不就行了吗？但是简单想就会知道，clear里面是找不到泛型类型T的符号的。 因此，在成员函数实现的时候，必须要提供模板参数。此外，为什么类型名不是vector而是vector&lt;T&gt;呢？如果你了解过模板的偏特化与特化的语法，应该能看出，这里的vector在语法上类似于特化&#x2F;偏特化。实际上，这里的函数定义也确实是成员函数的偏特化。特化和偏特化的概念，本文会在第二部分详细介绍。 综上，正确的成员函数实现如下所示： 12345template &lt;typename T&gt; // 模板参数void vector&lt;T&gt; /*看起来像偏特化*/ ::clear() // 函数的实现放在这里&#123; // Function body&#125; 2.3. 函数模板 (Function Tempalte) 入门2.3.1. 函数模板的声明和定义函数模板的语法与类模板基本相同，也是以关键字template和模板参数列表作为声明与定义的开始。模板参数列表中的类型，可以出现在参数、返回值以及函数体中。比方说下面几个例子 1234567891011template &lt;typename T&gt; void foo(T const&amp; v);template &lt;typename T&gt; T foo();template &lt;typename T, typename U&gt; U foo(T const&amp;);template &lt;typename T&gt; void foo()&#123; T var; // ...&#125; 无论是函数模板还是类模板，在实际代码中看起来都是“千变万化”的。这些“变化”，主要是因为类型被当做了参数，导致代码中可以变化的部分更多了。 归根结底，模板无外乎两点： 函数或者类里面，有一些类型我们希望它能变化一下，我们用标识符来代替它，这就是“模板参数”； 在需要这些类型的地方，写上相对应的标识符（“模板参数”）。 当然，这里的“可变”实际上在代码编译好后就固定下来了，可以称之为编译期的可变性。 这里多啰嗦一点，主要也是想告诉大家，模板其实是个很简单的东西。 下面这个例子，或许可以帮助大家解决以下两个问题： 什么样的需求会使用模板来解决？ 怎样把脑海中的“泛型”变成真正“泛型”的代码？ 1举个例子：generic typed function ‘add’ 在我遇到的朋友中，即便如此对他解释了模板，即便他了解了模板，也仍然会对模板产生畏难情绪。毕竟从形式上来说，模板化的类和模板化的函数都要较非模板的版本更加复杂，阅读代码所需要理解的内容也有所增多。 如何才能克服这一问题，最终视模板如平坦代码呢？ 答案只有一个：无他，唯手熟尔。 在学习模板的时候，要反复做以下的思考和练习： 提出问题：我的需求能不能用模板来解决？ 怎么解决？ 把解决方案用代码写出来。 如果失败了，找到原因。是知识有盲点（例如不知道怎么将 T&amp; 转化成 T），还是不可行（比如试图利用浮点常量特化类模板，但实际上这样做是不可行的）？ 通过重复以上的练习，应该可以对模板的语法和含义都有所掌握。如果提出问题本身有困难，或许下面这个经典案例可以作为你思考的开始： 写一个泛型的数据结构：例如，线性表，数组，链表，二叉树； 写一个可以在不同数据结构、不同的元素类型上工作的泛型函数，例如求和； 当然和“设计模式”一样，模板在实际应用中，也会有一些固定的需求和解决方案。比较常见的场景包括：泛型（最基本的用法）、通过类型获得相应的信息（型别萃取）、编译期间的计算、类型间的推导和变换（从一个类型变换成另外一个类型，比如boost::function）。这些本文在以后的章节中会陆续介绍。 2.3.2. 函数模板的使用我们先来看一个简单的函数模板，两个数相加： 1234template &lt;typename T&gt; T Add(T a, T b)&#123; return a + b;&#125; 函数模板的调用格式是： 1函数模板名 &lt; 模板参数列表 &gt; ( 参数 ) 例如，我们想对两个 int 求和，那么套用类的模板实例化方法，我们可以这么写： 123int a = 5;int b = 3;int result = Add&lt;int&gt;(a, b); 这时我们等于拥有了一个新函数： 1int Add&lt;int&gt;(int a, int b) &#123; return a + b; &#125; 这时在另外一个偏远的程序角落，你也需要求和。而此时你的参数类型是 float ，于是你写下： 1Add&lt;float&gt;(a, b); 一切看起来都很完美。但如果你具备程序员的最佳美德——懒惰——的话，你肯定会这样想，我在调用 Add&lt;int&gt;(a, b) 的时候， a 和 b 匹配的都是那个 T。编译器就应该知道那个 T 实际上是 int 呀？为什么还要我多此一举写 Add&lt;int&gt; 呢？唔，我想说的是，编译器的作者也是这么想的。所以实际上你在编译器里面写下以下片段： 123int a = 5;int b = 3;int result = Add(a, b); 编译器会心领神会地将 Add 变成 Add&lt;int&gt;。但是编译器不能面对模棱两可的答案。比如你这么写的话呢？ 123int a = 5;char b = 3;int result = Add(a, b); 第一个参数 a 告诉编译器，这个 T 是 int。编译器点点头说，好。但是第二个参数 b 不高兴了，告诉编译器说，你这个 T，其实是 char。两个参数各自指导 T 的类型，编译器就不知道怎么做了。在Visual Studio 2012下，会有这样的提示： 1error C2782: &#x27;T _1_2_2::Add(T,T)&#x27; : template parameter &#x27;T&#x27; is ambiguous 好吧，”ambiguous”，这个提示再明确不过了。 不过，只要你别逼得编译器精神分裂的话，编译器其实是非常聪明的，它可以从很多的蛛丝马迹中，猜测到你真正的意图，有如下面的例子： 123456template &lt;typename T&gt; class A &#123;&#125;;template &lt;typename T&gt; T foo( A&lt;T&gt; v );A&lt;int&gt; v;foo(v); // 它能准确地猜到 T 是 int. 咦，编译器居然绕过了A这个外套，猜到了 T 匹配的是 int。编译器是怎么完成这一“魔法”的，我们暂且不表，2.2节时再和盘托出。 下面轮到你的练习时间了。你试着写了很多的例子，但是其中一个你还是犯了疑惑： 123456789float data[1024];template &lt;typename T&gt; T GetValue(int i)&#123; return static_cast&lt;T&gt;(data[i]);&#125;float a = GetValue(0); // 出错了！int b = GetValue(1); // 也出错了！ 为什么会出错呢？你仔细想了想，原来编译器是没办法去根据返回值推断类型的。函数调用的时候，返回值被谁接受还不知道呢。如下修改后，就一切正常了： 12float a = GetValue&lt;float&gt;(0);int b = GetValue&lt;int&gt;(1); 嗯，是不是so easy啊？嗯，你又信心满满的做了一个练习： 你要写一个函数模板叫 c_style_cast，顾名思义，执行的是C风格的转换。然后出于方便起见，你希望它能和 static_cast 这样的内置转换有同样的写法。于是你写了一个use case。 1DstT dest = c_style_cast&lt;DstT&gt;(src); 根据调用形式你知道了，有 DstT 和 SrcT 两个模板参数。参数只有一个， src，所以函数的形参当然是这么写了： (SrcT src)。实现也很简单， (DstT)v。 我们把手上得到的信息来拼一拼，就可以编写自己的函数模板了： 1234567template &lt;typename SrcT, typename DstT&gt; DstT c_style_cast(SrcT v)&#123; return (DstT)(v);&#125;int v = 0;float i = c_style_cast&lt;float&gt;(v); 嗯，很Easy嘛！我们F6一下…咦！这是什么意思！ 1error C2783: &#x27;DstT _1_2_2::c_style_cast(SrcT)&#x27; : could not deduce template argument for &#x27;DstT&#x27; 然后你仔细的比较了一下，然后发现 … 模板参数有两个，而参数里面能得到的只有 SrcT 一个。结合出错信息看来关键在那个 DstT 上。这个时候，你死马当活马医，把模板参数写完整了： 1float i = c_style_cast&lt;int, float&gt;(v); 嗯，很顺利的通过了。难道C++不能支持让参数推导一部分模板参数吗？ 当然是可以的。只不过在部分推导、部分指定的情况下，编译器对模板参数的顺序是有限制的：先写需要指定的模板参数，再把能推导出来的模板参数放在后面。 在这个例子中，能推导出来的是 SrcT，需要指定的是 DstT。把函数模板写成下面这样就可以了： 1234567template &lt;typename DstT, typename SrcT&gt; DstT c_style_cast(SrcT v) // 模板参数 DstT 需要人肉指定，放前面。&#123; return (DstT)(v);&#125;int v = 0;float i = c_style_cast&lt;float&gt;(v); // 形象地说，DstT会先把你指定的参数吃掉，剩下的就交给编译器从函数参数列表中推导啦。 2.4. 整型也可是Template参数模板参数除了类型外（包括基本类型、结构、类类型等），也可以是一个整型数（Integral Number）。这里的整型数比较宽泛，包括布尔型，不同位数、有无符号的整型，甚至包括指针。我们将整型的模板参数和类型作为模板参数来做一个对比： 12template &lt;typename T&gt; class TemplateWithType;template &lt;int V&gt; class TemplateWithValue; 我想这个时候你也更能理解 typename 的意思了：它相当于是模板参数的“类型”，告诉你 T 是一个 typename。 按照C++ Template最初的想法，模板不就是为了提供一个类型安全、易于调试的宏吗？有类型就够了，为什么要引入整型参数呢？考虑宏，它除了代码替换，还有一个作用是作为常数出现。所以整型模板参数最基本的用途，也是定义一个常数。例如这段代码的作用： 123456template &lt;typename T, int Size&gt; struct Array&#123; T data[Size];&#125;;Array&lt;int, 16&gt; arr; 便相当于下面这段代码： 123456class IntArrayWithSize16&#123; int data[16]; // int 替换了 T, 16 替换了 Size&#125;;IntArrayWithSize16 arr; 其中有一点需要注意，因为模板的匹配是在编译的时候完成的，所以实例化模板的时候所使用的参数，也必须要在编译期就能确定。例如以下的例子编译器就会报错： 12345678template &lt;int i&gt; class A &#123;&#125;;void foo()&#123; int x = 3; A&lt;5&gt; a; // 正确！ A&lt;x&gt; b; // error C2971: &#x27;_1_3::A&#x27; : template parameter &#x27;i&#x27; : &#x27;x&#x27; : a local variable cannot be used as a non-type argument&#125; 因为x不是一个编译期常量，所以 A&lt;x&gt; 就会告诉你，x是一个局部变量，不能作为一个模板参数出现。 嗯，这里我们再来写几个相对复杂的例子： 1234567891011121314151617181920212223242526template &lt;int i&gt; class A &#123;public: void foo(int) &#123; &#125;&#125;;template &lt;uint8_t a, typename b, void* c&gt; class B &#123;&#125;;template &lt;bool, void (*a)()&gt; class C &#123;&#125;;template &lt;void (A&lt;3&gt;::*a)(int)&gt; class D &#123;&#125;;template &lt;int i&gt; int Add(int a) // 当然也能用于函数模板&#123; return a + i;&#125;void foo()&#123; A&lt;5&gt; a; B&lt;7, A&lt;5&gt;, nullptr&gt; b; // 模板参数可以是一个无符号八位整数，可以是模板生成的类；可以是一个指针。 C&lt;false, &amp;foo&gt; c; // 模板参数可以是一个bool类型的常量，甚至可以是一个函数指针。 D&lt;&amp;A&lt;3&gt;::foo&gt; d; // 丧心病狂啊！它还能是一个成员函数指针！ int x = Add&lt;3&gt;(5); // x == 8。因为整型模板参数无法从函数参数获得，所以只能是手工指定啦。&#125;template &lt;float a&gt; class E &#123;&#125;; // ERROR: 别闹！早说过只能是整数类型的啦！ 当然，除了单纯的用作常数之外，整型参数还有一些其它的用途。这些“其它”用途最重要的一点是让类型也可以像整数一样运算。《Modern C++ Design》给我们展示了很多这方面的例子。不过你不用急着去阅读那本天书，我们会在做好足够的知识铺垫后，让你轻松学会这些招数。 2.5. 模板形式与功能是统一的第一章走马观花的带着大家复习了一下C++ Template的基本语法形式，也解释了包括 typename 在内，类&#x2F;函数模板写法中各个语法元素的含义。形式是功能的外在体现，介绍它们也是为了让大家能理解到，模板之所以写成这种形式是有必要的，而不是语言的垃圾成分。 从下一章开始，我们便进入了更加复杂和丰富的世界：讨论模板的匹配规则。其中有令人望而生畏的特化与偏特化。但是，请相信我们在序言中所提到的：将模板作为一门语言来看待，它会变得有趣而简单。","comments":true,"tags":[{"name":"c++ template","slug":"c-template","permalink":"https://kettycode.github.io/tags/c-template/"}]},{"title":"现代C++学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/现代C++/base1/","text":"迈向现代C++被弃用的特性注意：弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分特性其实会『永久』保留 1.不再允许字符串字面值常量赋值给一个 char *。如果需要用字符串字面值常量赋值和初始化一个 char *，应该使用 const char * 或者 auto。2.C++98 异常说明、 unexpected_handler、set_unexpected() 等相关特性被弃用，应该使用 noexcept。3.auto_ptr 被弃用，应使用 unique_ptr。4.bool 类型的 ++ 操作被弃用。5.C 语言风格的类型转换被弃用（即在变量前使用 (convert_type)），应该使用 static_cast、reinterpret_cast、const_cast 来进行类型转换。6.特别地，在最新的 C++17 标准中弃用了一些可以使用的 C 标准库，例如 、、 与 等7.std::bind,std::function,export等特效 与C的兼容性在编写 C++ 时，也应该尽可能的避免使用诸如 void* 之类的程序风格。而在不得不使用 C 时，应该注意使用 extern “C” 这种特性，将 C 语言的代码与 C++代码进行分离编译，再统一链接这种做法。","comments":true,"tags":[{"name":"modern c++","slug":"modern-c","permalink":"https://kettycode.github.io/tags/modern-c/"}]},{"title":"C++模板学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/泛型编程/template5/","text":"5. 未完成章节123456789101112131415161718192021222324252627282930313233# 6. 元编程下的数据结构与算法## 6.1. 表达式与数值计算## 6.2. 获得类型的属性——类型萃取（Type Traits） ## 6.3. 列表与数组## 6.4. 字典结构## 6.5. “快速”排序## 6.6. 其它常用的“轮子”# 7. 非模板的编译期计算# 8. 模板的进阶技巧## 8.1. 嵌入类## 8.2. Template-Template Class## 8.3. 高阶函数## 8.4. 闭包：模板的“基于对象”stl allocator?mpl::apply## 8.5. 占位符(placeholder)：在C++中实现方言的基石## 8.6. 编译期“多态”# 9. 模板的威力：从foreach, transform到Linq## 9.1. Foreach与Transform## 9.2. Boost中的模板Any Spirit Hana TypeErasure## 9.3. Reactor、Linq与C++中的实践## 9.4. 更高更快更强：从Linq到FP# 10. 结语：讨论有益，争端无用## 10.1. 更好的编译器，更友善的出错信息## 10.2. 模板的症结：易于实现，难于完美## 10.3. 一些期望alexandrescu 关于 min max 的讨论：《再谈Min和Max》std::experimental::any / boost.any 对于 reference 的处理","comments":true,"tags":[{"name":"c++ template","slug":"c-template","permalink":"https://kettycode.github.io/tags/c-template/"}]},{"title":"C++模板学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/泛型编程/template3/","text":"3. 模板元编程基础3.1. 编程，元编程，模板元编程技术的学习是一个登山的过程。第一章是最为平坦的山脚道路。而从这一章开始，则是正式的爬坡。无论是我写作还是你阅读，都需要付出比第一章更多的代价。那么问题就是，付出更多的精力学习模板是否值得？ 这个问题很功利，但是一针见血。因为技术的根本目的在于解决需求。那C++的模板能做什么？ 一个高（树）大（新）上（风）的回答是，C++里面的模板，犹如C中的宏、C和Java中的自省（restropection）和反射（reflection），是一个改变语言内涵，拓展语言外延的存在。 程序最根本的目的是什么？复现真实世界或人所构想的规律，减少重复工作的成本，或通过提升规模完成人所不能及之事。但是世间之事万千，有限的程序如何重现复杂的世界呢？ 答案是“抽象”。论及具体手段，无外乎“求同”与“存异”：概括一般规律，处理特殊情况。这也是软件工程所追求的目标。一般规律概括的越好，我们所付出的劳动也就越少。 同样的，作为脑力劳动的产品，程序本身也是有规律性的。《Modern C++ Design》中的前言就抛出了一连串有代表性的问题： 123如何撰写更高级的C++程式？如何应付即使在很干净的设计中仍然像雪崩一样的不相干细节？如何构建可复用组件，使得每次在不同程式中应用组件时无需大动干戈？ 我们以数据结构举例。在程序里，你需要一些堆栈。这个堆栈的元素可能是整数、浮点或者别的什么类型。一份整型堆栈的代码可能是： 1234567891011121314class StackInt&#123;public: void push(int v); int pop(); int Find(int x) &#123; for(int i = 0; i &lt; size; ++i) &#123; if(data[i] == x) &#123; return i; &#125; &#125; &#125; // ... 其他代码 ...&#125;; 如果你要支持浮点了，那么你只能将代码再次拷贝出来，并作如下修改： 1234567891011121314class StackFloat&#123;public: void push(float v); float pop(); int Find(float x) &#123; for(int i = 0; i &lt; size; ++i) &#123; if(data[i] == x) &#123; return i; &#125; &#125; &#125; // ... 其他代码 ...&#125;; 当然也许你觉得这样做能充分体会代码行数增长的成就感。但是有一天，你突然发现：呀，Find 函数实现有问题了。怎么办？这个时候也许你只有两份这样的代码，那好说，一一去修正就好了。如果你有十个呢？二十个？五十个？ 时间一长，你就厌倦了这样的生活。你觉得每个堆栈都差不多，但是又有点不一样。为了这一点点不一样，你付出了太多的时间。吃饭的时间，泡妞的时间，睡觉的时间，看岛国小电影顺便练习小臂力量的时间。 于是便诞生了新的技术，来消解我们的烦恼。 这个技术的名字，并不叫“模板”，而是叫“元编程”。 元（meta）无论在中文还是英文里，都是个很“抽象（abstract）”的词。因为它的本意就是“抽象”。元编程，也可以说就是“编程的抽象”。用更好理解的说法，元编程意味着你撰写一段程序A，程序A会运行后生成另外一个程序B，程序B才是真正实现功能的程序。那么这个时候程序A可以称作程序B的元程序，撰写程序A的过程，就称之为“元编程”。 回到我们的堆栈的例子。真正执行功能的，其实仍然是浮点的堆栈、整数的堆栈、各种你所需要的类型的堆栈。但是因为这些堆栈之间太相似了，仅仅有着些微的不同，我们为什么不能有一个将相似之处囊括起来，同时又能分别体现出不同之处的程序呢？很多语言都提供了这样的机会。C中的宏，C++中的模板，Python中的Duck Typing，广义上将都能够实现我们的思路。 我们的目的，是找出程序之间的相似性，进行“元编程”。而在C++中，元编程的手段，可以是宏，也可以是模板。 宏的例子姑且不论，我们来看一看模板： 123456789101112131415161718template &lt;typename T&gt;class Stack&#123;public: void push(T v); T pop(); int Find(T x) &#123; for(int i = 0; i &lt; size; ++i) &#123; if(data[i] == x) &#123; return i; &#125; &#125; &#125; // ... 其他代码 ...&#125;;typedef Stack&lt;int&gt; StackInt;typedef Stack&lt;float&gt; StackFloat; 通过模板，我们可以将形形色色的堆栈代码分为两个部分，一个部分是不变的接口，以及近乎相同的实现；另外一部分是元素的类型，它们是需要变化的。因此同函数类似，需要变化的部分，由模板参数来反映；不变的部分，则是模板内的代码。可以看到，使用模板的代码，要比不使用模板的代码简洁许多。 如果元编程中所有变化的量（或者说元编程的参数），都是类型，那么这样的编程，我们有个特定的称呼，叫“泛型”。 但是你会问，模板的发明，仅仅是为了做和宏几乎一样的替换工作吗？可以说是，也可以说不是。一方面，很多时候模板就是为了替换类型，这个时候作用上其实和宏没什么区别。只是宏是基于文本的替换，被替换的文本本身没有任何语义。只有替换完成，编译器才能进行接下来的处理。而模板会在分析模板时以及实例化模板时时候都会进行检查，而且源代码中也能与调试符号一一对应，所以无论是编译时还是运行时，排错都相对简单。 但是模板和宏也有很大的不同，否则此文也就不能成立了。模板最大的不同在于它是“可以运算”的。我们来举一个例子，不过可能有点牵强。考虑我们要写一个向量逐分量乘法。只不过这个向量，它非常的大。所以为了保证速度，我们需要使用SIMD指令进行加速。假设我们有以下指令可以使用： 1234Int8,16: N/AInt32 : VInt32Mul(int32x4, int32x4)Int64 : VInt64Mul(int64x4, int64x4)Float : VInt64Mul(floatx2, floatx2) 所以对于Int8和Int16，我们需要提升到Int32，而Int32和Int64，各自使用自己的指令。所以我们需要实现下的逻辑： 123456789for(v4a, v4b : vectorsA, vectorsB)&#123; if type is Int8, Int16 VInt32Mul( ConvertToInt32(v4a), ConvertToInt32(v4b) ) elif type is Int32 VInt32Mul( v4a, v4b ) elif type is Float ...&#125; 这里的问题就在于，如何根据 type 分别提供我们需要的实现？这里有两个难点。首先， if(type == xxx) &#123;&#125; 是不存在于C++中的。第二，即便存在根据 type 的分配方法，我们也不希望它在运行时branch，这样会变得很慢。我们希望它能按照类型直接就把代码编译好，就跟直接写的一样。 嗯，聪明你果然想到了，重载也可以解决这个问题。 1234567891011GenericMul(int8x4, int8x4);GenericMul(int16x4, int16x4);GenericMul(int32x4, int32x4);GenericMul(int64x4, int64x4);// 其它 Generic Mul ...for(v4a, v4b : vectorsA, vectorsB)&#123; GenericMul(v4a, v4b);&#125; 这样不就可以了吗？ 唔，你赢了，是这样没错。但是问题是，我这个平台是你可没见过，它叫 Deep Thought， 特别缺心眼儿，不光有 int8，还有更奇怪的 int9, int11，以及可以代表世间万物的 int42。你总不能为之提供所有的重载吧？这简直就像你枚举了所有程序的输入，并为之提供了对应的输出一样。 好吧，我承认这个例子还是太牵强了。不过相信我，在你阅读完第二章和第三章之后，你会将这些特性自如地运用到你的程序之中。你的程序将会变成体现模板“可运算”威力的最好例子。 3.2. 模板世界的If-Then-Else：类模板的特化与偏特化3.2.1. 根据类型执行代码前一节的示例提出了一个要求：需要做出根据类型执行不同代码。要达成这一目的，模板并不是唯一的途径。比如之前我们所说的重载。如果把眼界放宽一些，虚函数也是根据类型执行代码的例子。此外，在C语言时代，也会有一些技法来达到这个目的，比如下面这个例子，我们需要对两个浮点做加法， 或者对两个整数做乘法： 12345678910111213141516171819202122232425struct Variant&#123; union &#123; int x; float y; &#125; data; uint32 typeId;&#125;;Variant addFloatOrMulInt(Variant const* a, Variant const* b)&#123; Variant ret; assert(a-&gt;typeId == b-&gt;typeId); if (a-&gt;typeId == TYPE_INT) &#123; ret.x = a-&gt;x * b-&gt;x; &#125; else &#123; ret.y = a-&gt;y + b-&gt;y; &#125; return ret;&#125; 更常见的是 void*: 123456789101112define BIN_OP(type, a, op, b, result) (*(type *)(result)) = (*(type const *)(a)) op (*(type const*)(b))void doDiv(void* out, void const* data0, void const* data1, DATA_TYPE type)&#123; if(type == TYPE_INT) &#123; BIN_OP(int, data0, *, data1, out); &#125; else &#123; BIN_OP(float, data0, +, data1, out); &#125;&#125; 在C++中比如在 Boost.Any 的实现中，运用了 typeid 来查询类型信息。和 typeid 同属于RTTI机制的 dynamic_cast，也经常会用来做类型判别的工作。我想你应该写过类似于下面的代码： 123456789101112IAnimal* animal = GetAnimalFromSystem();IDog* maybeDog = dynamic_cast&lt;IDog*&gt;(animal);if(maybeDog)&#123; maybeDog-&gt;Wangwang();&#125;ICat* maybeCat = dynamic_cast&lt;ICat*&gt;(animal);if(maybeCat)&#123; maybeCat-&gt;Moemoe();&#125; 当然，在实际的工作中，我们建议把需要 dynamic_cast 后执行的代码，尽量变成虚函数。不过这个已经是另外一个问题了。我们看到，不管是哪种方法都很难避免 if 的存在。而且因为输入数据的类型是模糊的，经常需要强制地、没有任何检查的转换成某个类型，因此很容易出错。 但是模板与这些方法最大的区别并不在这里。模板无论其参数或者是类型，它都是一个编译期分派的办法。编译期就能确定的东西既可以做类型检查，编译器也能进行优化，砍掉任何不必要的代码执行路径。例如在上例中， 12345template &lt;typename T&gt; T addFloatOrMulInt(T a, T b);// 迷之代码1：用于T是float的情况// 迷之代码2：用于T是int时的情况 如果你运用了模板来实现，那么当传入两个不同类型的变量，或者不是 int 和 float 变量，编译器就会提示错误。但是如果使用了我们前述的 Variant 来实现，编译器可就管不了那么多了。但是，成也编译期，败也编译期。最严重的“缺点”，就是你没办法根据用户输入或者别的什么在运行期间可能发生变化的量来决定它产生、或执行什么代码。比如下面的代码段，它是不成立的。 1234567template &lt;int i, int j&gt;int foo() &#123; return i + j; &#125;int main()&#123; cin &gt;&gt; x &gt;&gt; y; return foo&lt;x, y&gt;();&#125; 这点限制也粉碎了妄图用模板来包办工厂（Factory）甚至是反射的梦想。尽管在《Modern C++ Design》中（别问我为什么老举这本书，因为《C++ Templates》和《Generic Programming》我只是囫囵吞枣读过，基本不记得了)大量运用模板来简化工厂方法；同时C++11&#x2F;14中的一些机制如Variadic Template更是让这一问题的解决更加彻底。但无论如何，直到C++11&#x2F;14，光靠模板你就是写不出依靠类名或者ID变量产生类型实例的代码。 所以说，从能力上来看，模板能做的事情都是编译期完成的。编译期完成的意思就是，当你编译一个程序的时候，所有的量就都已经确定了。比如下面的这个例子： 12345int a = 3, b = 5;Variant aVar, bVar;aVar.setInt(a); // 我们新加上的方法，怎么实现的无所谓，大家明白意思就行了。bVar.setInt(b);Variant result = addFloatOrMulInt(aVar, bVar); 除非世界末日，否则这个例子里不管你怎么蹦跶，单看代码我们就能知道， aVar 和 bVar 都一定会是整数。所以如果有合适的机制，编译器就能知道此处的 addFloatOrMulInt 中只需要执行 Int 路径上的代码，而且编译器在此处也能单独为 Int 路径生成代码，从而去掉那个不必要的 if。 在模板代码中，这个“合适的机制”就是指“特化”和“部分特化（Partial Specialization）”，后者也叫“偏特化”。 3.2.2. 特化我的高中物理老师对我说过一句令我受用至今的话：把自己能做的事情做好。编写模板程序也是一样。当你试图用模板解决问题之前，先撇开那些复杂的语法要素，用最直观的方式表达你的需求： 12345678910111213141516171819202122// 这里是伪代码，意思一下int|float addFloatOrMulInt(a, b)&#123; if(type is Int) &#123; return a * b; &#125; else if (type is Float) &#123; return a + b; &#125;&#125;void foo()&#123; float a, b, c; c = addFloatOrMulInt(a, b); // c = a + b; int x, y, z; z = addFloatOrMulInt(x, y); // z = x * y;&#125; 因为这一节是讲类模板有关的特化和偏特化机制，所以我们不用普通的函数，而是用类的静态成员函数来做这个事情（这就是典型的没事找抽型）： 123456789101112131415161718192021222324// 这里仍然是伪代码，意思一下，too。class AddFloatOrMulInt&#123; static int|float Do(a, b) &#123; if(type is Int) &#123; return a * b; &#125; else if (type is Float) &#123; return a + b; &#125; &#125;&#125;;void foo()&#123; float a, b, c; c = AddFloatOrMulInt::Do(a, b); // c = a + b; int x, y, z; z = AddFloatOrMulInt::Do(x, y); // z = x * y;&#125; 好，意思表达清楚了。我们先从调用方的角度，把这个形式改写一下： 12345678void foo()&#123; float a, b, c; c = AddFloatOrMulInt&lt;float&gt;::Do(a, b); // c = a + b; int x, y, z; z = AddFloatOrMulInt&lt;int&gt;::Do(x, y); // z = x * y;&#125; 也许你不明白为什么要改写成现在这个样子。看不懂不怪你，怪我讲得不好。但是你别急，先看看这样改写以后能不能跟我们的目标接近一点。如果我们把 AddFloatOrMulInt&lt;float&gt;::Do 看作一个普通的函数，那么我们可以写两个实现出来： 123456789101112131415161718float AddFloatOrMulInt&lt;float&gt;::Do(float a, float b)&#123; return a + b;&#125;int AddFloatOrMulInt&lt;int&gt;::Do(int a, int b)&#123; return a * b;&#125;void foo()&#123; float a, b, c; c = AddFloatOrMulInt&lt;float&gt;::Do(a, b); // c = a + b; int x, y, z; z = AddFloatOrMulInt&lt;int&gt;::Do(x, y); // z = x * y;&#125; 这样是不是就很开心了？我们更进一步，把 AddFloatOrMulInt&lt;int&gt;::Do 换成合法的类模板： 123456789101112131415161718192021222324252627282930// 这个是给float用的。template &lt;typename T&gt; class AddFloatOrMulInt&#123; T Do(T a, T b) &#123; return a + b; &#125;&#125;;// 这个是给int用的。template &lt;typename T&gt; class AddFloatOrMulInt&#123; T Do(T a, T b) &#123; return a * b; &#125;&#125;;void foo()&#123; float a, b, c; // 嗯，我们需要 c = a + b; c = AddFloatOrMulInt&lt;float&gt;::Do(a, b); // ... 觉得哪里不对劲 ... // ... // ... // ... // 啊！有两个AddFloatOrMulInt，class看起来一模一样，要怎么区分呢！&#125; 好吧，问题来了！如何要让两个内容不同，但是模板参数形式相同的类进行区分呢？特化！特化（specialization）是根据一个或多个特殊的整数或类型，给出模板实例化时的一个指定内容。我们先来看特化是怎么应用到这个问题上的。 1234567891011121314151617181920212223242526272829303132333435// 首先，要写出模板的一般形式（原型）template &lt;typename T&gt; class AddFloatOrMulInt&#123; static T Do(T a, T b) &#123; // 在这个例子里面一般形式里面是什么内容不重要，因为用不上 // 这里就随便给个0吧。 return T(0); &#125;&#125;;// 其次，我们要指定T是int时候的代码，这就是特化：template &lt;&gt; class AddFloatOrMulInt&lt;int&gt;&#123;public: static int Do(int a, int b) // &#123; return a * b; &#125;&#125;;// 再次，我们要指定T是float时候的代码：template &lt;&gt; class AddFloatOrMulInt&lt;float&gt;&#123;public: static float Do(float a, float b) &#123; return a + b; &#125;&#125;;void foo()&#123; // 这里面就不写了&#125; 我们再把特化的形式拿出来一瞧：这货有点怪啊： template &lt;&gt; class AddFloatOrMulInt&lt;int&gt;。别急，我给你解释一下。 1234567891011121314151617181920// 我们这个模板的基本形式是什么？template &lt;typename T&gt; class AddFloatOrMulInt;// 但是这个类，是给T是Int的时候用的，于是我们写作class AddFloatOrMulInt&lt;int&gt;;// 当然，这里编译是通不过的。// 但是它又不是个普通类，而是类模板的一个特化（特例）。// 所以前面要加模板关键字template，// 以及模板参数列表template &lt;/* 这里要填什么？ */&gt; class AddFloatOrMulInt&lt;int&gt;;// 最后，模板参数列表里面填什么？因为原型的T已经被int取代了。所以这里就不能也不需要放任何额外的参数了。// 所以这里放空。template &lt;&gt; class AddFloatOrMulInt&lt;int&gt;&#123; // ... 针对Int的实现 ... &#125;;// Bingo! 哈，这样就好了。我们来做一个练习。我们有一些类型，然后你要用模板做一个对照表，让类型对应上一个数字。我先来做一个示范： 123456789101112template &lt;typename T&gt; class TypeToID&#123;public: static int const ID = -1;&#125;;template &lt;&gt; class TypeToID&lt;uint8_t&gt;&#123;public: static int const ID = 0;&#125;; 然后呢，你的任务就是，要所有无符号的整数类型的特化（其实就是uint8_t到uint64_t啦），把所有的基本类型都赋予一个ID（当然是不一样的啦）。当你做完后呢，可以把类型所对应的ID打印出来，我仍然以 uint8_t 为例： 1234void PrintID()&#123; cout &lt;&lt; &quot;ID of uint8_t: &quot; &lt;&lt; TypeToID&lt;uint8_t&gt;::ID &lt;&lt; endl;&#125; 嗯，看起来挺简单的，是吧。但是这里透露出了一个非常重要的信号，我希望你已经能察觉出来了： TypeToID 如同是一个函数。这个函数只能在编译期间执行。它输入一个类型，输出一个ID。 如果你体味到了这一点，那么恭喜你，你的模板元编程已经开悟了。 3.2.3. 特化：一些其它问题在上一节结束之后，你一定做了许多的练习。我们再来做三个练习。第一，给float一个ID；第二，给void*一个ID；第三，给任意类型的指针一个ID。先来做第一个: 123456789// ...// TypeToID 的模板“原型”// ...template &lt;&gt; class TypeToID&lt;float&gt;&#123;public: static int const ID = 0xF10A7;&#125;; 嗯， 这个你已经了然于心了。那么void*呢？你想了想，这已经是一个复合类型了。不错你还是战战兢兢地写了下来： 12345678910template &lt;&gt; class TypeToID&lt;void*&gt;&#123;public: static int const ID = 0x401d;&#125;;void PrintID()&#123; cout &lt;&lt; &quot;ID of uint8_t: &quot; &lt;&lt; TypeToID&lt;void*&gt;::ID &lt;&lt; endl;&#125; 遍译运行一下，对了。模板不过如此嘛。然后你觉得自己已经完全掌握了，并试图将所有C++类型都放到模板里面，开始了自我折磨的过程： 123456class ClassB &#123;&#125;;template &lt;&gt; class TypeToID&lt;void ()&gt;; // 函数的TypeIDtemplate &lt;&gt; class TypeToID&lt;int[3]&gt;; // 数组的TypeIDtemplate &lt;&gt; class TypeToID&lt;int (int[3])&gt;; // 这是以数组为参数的函数的TypeIDtemplate &lt;&gt; class TypeToID&lt;int (ClassB::*[3])(void*, float[2])&gt;; // 我也不知道这是什么了，自己看着办吧。 甚至连 const 和 volatile 都能装进去： 1template &lt;&gt; class TypeToID&lt;int const * volatile * const volatile&gt;; 此时就很明白了，只要 &lt;&gt; 内填进去的是一个C++能解析的合法类型，模板都能让你特化。不过这个时候如果你一点都没有写错的话， PrintID 中只打印了我们提供了特化的类型的ID。那如果我们没有为之提供特化的类型呢？比如说double？OK，实践出真知，我们来尝试着运行一下： 1234void PrintID()&#123; cout &lt;&lt; &quot;ID of double: &quot; &lt;&lt; TypeToID&lt;double&gt;::ID &lt;&lt; endl;&#125; 嗯，它输出的是-1。我们顺藤摸瓜会看到， TypeToID的类模板“原型”的ID是值就是-1。通过这个例子可以知道，当模板实例化时提供的模板参数不能匹配到任何的特化形式的时候，它就会去匹配类模板的“原型”形式。 不过这里有一个问题要理清一下。和继承不同，类模板的“原型”和它的特化类在实现上是没有关系的，并不是在类模板中写了 ID 这个Member，那所有的特化就必须要加入 ID 这个Member，或者特化就自动有了这个成员。完全没这回事。我们把类模板改成以下形式，或许能看的更清楚一点： 123456789101112131415161718template &lt;typename T&gt; class TypeToID&#123;public: static int const NotID = -2;&#125;;template &lt;&gt; class TypeToID&lt;float&gt;&#123;public: static int const ID = 1;&#125;;void PrintID()&#123; cout &lt;&lt; &quot;ID of float: &quot; &lt;&lt; TypeToID&lt;float&gt;::ID &lt;&lt; endl; // Print &quot;1&quot; cout &lt;&lt; &quot;NotID of float: &quot; &lt;&lt; TypeToID&lt;float&gt;::NotID &lt;&lt; endl; // Error! TypeToID&lt;float&gt;使用的特化的类，这个类的实现没有NotID这个成员。 cout &lt;&lt; &quot;ID of double: &quot; &lt;&lt; TypeToID&lt;double&gt;::ID &lt;&lt; endl; // Error! TypeToID&lt;double&gt;是由类模板实例化出来的，它只有NotID，没有ID这个成员。&#125; 这样就明白了。类模板和类模板的特化的作用，仅仅是指导编译器选择哪个编译，但是特化之间、特化和它原型的类模板之间，是分别独立实现的。所以如果多个特化、或者特化和对应的类模板有着类似的内容，很不好意思，你得写上若干遍了。 第三个问题，是写一个模板匹配任意类型的指针。对于C语言来说，因为没有泛型的概念，因此它提供了无类型的指针void*。它的优点是，所有指针都能转换成它。它的缺点是，一旦转换称它后，你就再也不知道这个指针到底是指向float或者是int或者是struct了。 比如说copy。 1234567891011void copy(void* dst, void const* src, size_t elemSize, size_t elemCount, void (*copyElem)(void* dstElem, void const* srcElem))&#123; void const* reader = src; void const* writer = dst; for(size_t i = 0; i &lt; elemCount; ++i) &#123; copyElem(writer, reader); advancePointer(reader, elemSize); // 把Reader指针往后移动一些字节 advancePointer(writer, elemSize); &#125;&#125; 为什么要提供copyElem，是因为可能有些struct需要深拷贝，所以得用特殊的copy函数。这个在C++98&#x2F;03里面就体现为拷贝构造和赋值函数。 但是不管怎么搞，因为这个函数的参数只是void*而已，当你使用了错误的elemSize，或者传入了错误的copyElem，就必须要到运行的时候才有可能看出来。注意，这还只是有可能而已。 那么C++有了模板后，能否既能匹配任意类型的指针，同时又保留了类型信息呢？答案是显然的。至于怎么写，那就得充分发挥你的直觉了： 首先，我们需要一个typename T来指代“任意类型”这四个字： 1template &lt;typename T&gt; 接下来，我们要写函数原型： 1void copy(?? dest, ?? src, size_t elemCount); 这里的 ?? 要怎么写呢？既然我们有了模板类型参数T，那我们不如就按照经验，写 T* 看看。 12template &lt;typename T&gt;void copy(T* dst, T const* src, size_t elemCount); 编译一下，咦，居然通过了。看来这里的语法与我们以前学到的知识并没有什么不同。这也是语言设计最重要的一点原则：一致性。它可以让你辛辛苦苦体验到的规律不至于白费。 最后就是实现： 12345678template &lt;typename T&gt;void copy(T* dst, T const* src, size_t elemCount)&#123; for(size_t i = 0; i &lt; elemCount; ++i) &#123; dst[i] = src[i]; &#125;&#125; 是不是简洁了许多？你不需要再传入size；只要你有正确的赋值函数，也不需要提供定制的copy；也不用担心dst和src的类型不匹配了。 最后，我们把函数模板学到的东西，也应用到类模板里面： 123456template &lt;typename T&gt; // 嗯，需要一个Tclass TypeToID&lt;T*&gt; // 我要对所有的指针类型特化，所以这里就写T*&#123;public: static int const ID = 0x80000000; // 用最高位表示它是一个指针&#125;; 最后写个例子来测试一下，看看我们的 T* 能不能搞定 float*： 1234void PrintID()&#123; cout &lt;&lt; &quot;ID of float*: &quot; &lt;&lt; TypeToID&lt;float*&gt;::ID &lt;&lt; endl;&#125; 哈哈，大功告成。嗯，别急着高兴。待我问一个问题：你知道 TypeToID&lt;float*&gt; 后，这里的T是什么吗？换句话说，你知道下面这段代码打印的是什么吗？ 12345678910111213141516// ...// TypeToID 的其他代码，略过不表// ...template &lt;typename T&gt; // 嗯，需要一个Tclass TypeToID&lt;T*&gt; // 我要对所有的指针类型特化，所以这里就写T*&#123;public: typedef T SameAsT; static int const ID = 0x80000000; // 用最高位表示它是一个指针&#125;;void PrintID()&#123; cout &lt;&lt; &quot;ID of float*: &quot; &lt;&lt; TypeToID&lt; TypeToID&lt;float*&gt;::SameAsT &gt;::ID &lt;&lt; endl;&#125; 别急着运行，你先猜。 ————————- 这里是给勤于思考的码猴的分割线 ——————————- OK，猜出来了吗，T是float。为什么呢？因为你用 float * 匹配了 T *，所以 T 就对应 float 了。没想清楚的自己再多体会一下。 嗯，所以实际上，我们可以利用这个特性做一件事情：把指针类型的那个指针给“干掉”： 12345678910111213141516171819template &lt;typename T&gt;class RemovePointer&#123;public: typedef T Result; // 如果放进来的不是一个指针，那么它就是我们要的结果。&#125;;template &lt;typename T&gt;class RemovePointer&lt;T*&gt; // 祖传牛皮藓，专治各类指针&#123;public: typedef T Result; // 正如我们刚刚讲的，去掉一层指针，把 T* 这里的 T 取出来。&#125;;void Foo()&#123; RemovePointer&lt;float*&gt;::Result x = 5.0f; // 喏，用RemovePointer后，那个Result就是把float*的指针处理掉以后的结果：float啦。 std::cout &lt;&lt; x &lt;&lt; std::endl;&#125; 当然啦，这里我们实现的不算是真正的 RemovePointer，因为我们只去掉了一层指针。而如果传进来的是类似 RemovePointer&lt;int**&gt; 这样的东西呢？是的没错，去掉一层之后还是一个指针。RemovePointer&lt;int**&gt;::Result 应该是一个 int*，要怎么才能实现我们想要的呢？聪明的你一定能想到：只要像剥洋葱一样，一层一层一层地剥开，不就好了吗！相应地我们应该怎么实现呢？可以把 RemovePointer 的特化版本改成这样（当然如果有一些不明白的地方你可以暂时跳过，接着往下看，很快就会明白的）： 123456789template &lt;typename T&gt;class RemovePointer&lt;T*&gt;&#123;public: // 如果是传进来的是一个指针，我们就剥夺一层，直到指针形式不存在为止。 // 例如 RemovePointer&lt;int**&gt;，Result 是 RemovePointer&lt;int*&gt;::Result， // 而 RemovePointer&lt;int*&gt;::Result 又是 int，最终就变成了我们想要的 int，其它也是类似。 typedef typename RemovePointer&lt;T&gt;::Result Result;&#125;; 是的没错，这便是我们想要的 RemovePointer 的样子。类似的你还可以试着实现 RemoveConst, AddPointer 之类的东西。 OK，回到我们之前的话题，如果这个时候，我需要给 int* 提供一个更加特殊的特化，那么我还得多提供一个： 1234567891011121314151617181920212223// ...// TypeToID 的其他代码，略过不表// ...template &lt;typename T&gt; // 嗯，需要一个Tclass TypeToID&lt;T*&gt; // 我要对所有的指针类型特化，所以这里就写T*&#123;public: typedef T SameAsT; static int const ID = 0x80000000; // 用最高位表示它是一个指针&#125;;template &lt;&gt; // 嗯，int* 已经是个具体的不能再具体的类型了，所以模板不需要额外的类型参数了class TypeToID&lt;int*&gt; // 嗯，对int*的特化。在这里呢，要把int*整体看作一个类型&#123;public: static int const ID = 0x12345678; // 给一个缺心眼的ID&#125;;void PrintID()&#123; cout &lt;&lt; &quot;ID of int*: &quot; &lt;&lt; TypeToID&lt;int*&gt;::ID &lt;&lt; endl;&#125; 嗯，这个时候它会输出0x12345678的十进制（大概？）。可能会有较真的人说，int* 去匹配 T 或者 T*，也是合法的。就和你说22岁以上能结婚，那24岁当然也能结婚一样。那为什么 int* 就会找 int*，float *因为没有合适的特化就去找 T*，更一般的就去找 T 呢？废话，有专门为你准备的东西你不用，非要自己找事？这就是直觉。但是呢，直觉对付更加复杂的问题还是没用的（也不是没用，主要是你没这个直觉了）。我们要把这个直觉，转换成合理的规则——即模板的匹配规则。当然，这个匹配规则是对复杂问题用的，所以我们会到实在一眼看不出来的时候才会动用它。一开始我们只要把握：模板是从最特殊到最一般形式进行匹配的 就可以了。 3.3. 即用即推导3.3.1. 视若无睹的语法错误这一节我们将讲述模板一个非常重要的行为特点：那就是什么时候编译器会对模板进行推导，推导到什么程度。 这一知识，对于理解模板的编译期行为、以及修正模板编译错误都非常重要。 我们先来看一个例子： 12345678910111213141516template &lt;typename T&gt; struct X &#123;&#125;; template &lt;typename T&gt; struct Y&#123; typedef X&lt;T&gt; ReboundType; // 类型定义1 typedef typename X&lt;T&gt;::MemberType MemberType; // 类型定义2 typedef UnknownType MemberType3; // 类型定义3 void foo() &#123; X&lt;T&gt; instance0; typename X&lt;T&gt;::MemberType instance1; WTF instance2 大王叫我来巡山 - + &amp; &#125;&#125;; 把这段代码编译一下，类型定义3出错，其它的都没问题。不过到这里你应该会有几个问题： 不是struct X&lt;T&gt;的定义是空的吗？为什么在struct Y内的类型定义2使用了 X&lt;T&gt;::MemberType 编译器没有报错？ 类型定义2中的typename是什么鬼？为什么类型定义1就不需要？ 为什么类型定义3会导致编译错误？ 为什么void foo()在MSVC下什么错误都没报？ 这时我们就需要请出C++11标准 —— 中的某些概念了。这是我们到目前为止第一次参阅标准。我希望能尽量减少直接参阅标准的次数，因此即便是极为复杂的模板匹配决议我都暂时没有引入标准中的描述。然而，Template引入的“双阶段名称查找（Two phase name lookup）”堪称是C++中最黑暗的角落 —— 这是LLVM的团队自己在博客上说的 —— 因此在这里，我们还是有必要去了解标准中是如何规定的。 3.3.2. 名称查找：I am who I am在C++标准中对于“名称查找（name lookup）”这个高大上的名词的诠释，主要集中出现在三处。第一处是3.4节，标题名就叫“Name Lookup”；第二处在10.2节，继承关系中的名称查找；第三处在14.6节，名称解析（name resolution）。 名称查找&#x2F;名称解析，是编译器的基石。对编译原理稍有了解的人，都知道“符号表”的存在及重要意义。考虑一段最基本的C代码： 1234int a = 0;int b;b = (a + 1) * 2;printf(&quot;Result: %d&quot;, b); 在这段代码中，所有出现的符号可以分为以下几类： int：类型标识符，代表整型； a, b, printf：变量名或函数名； =, +, *：运算符； ,, ;, (, )：分隔符； 那么，编译器怎么知道int就是整数类型，b=(a+1)*2中的a和b就是整型变量呢？这就是名称查找&#x2F;名称解析的作用：它告诉编译器，这个标识符（identifer）是在哪里被声明或定义的，它究竟是什么意思。 也正因为这个机制非常基础，所以它才会面临各种可能的情况，编译器也要想尽办法让它在大部分场合都表现的合理。比如我们常见的作用域规则，就是为了对付名称在不同代码块中传播、并且遇到重名要如何处理的问题。下面是一个最简单的、大家在语言入门过程中都会碰到的一个例子： 123456789101112131415161718int a = 0;void f() &#123; int a = 0; a += 2; printf(&quot;Inside &lt;a&gt;: %d\\n&quot;, a);&#125;void g() &#123; printf(&quot;Outside &lt;a&gt;: %d\\n&quot;, a);&#125;int main() &#123; f(); g();&#125;/* ------------ Console Output -----------------Inside &lt;a&gt;: 2Outside &lt;a&gt;: 0--------------- Console Output -------------- */ 我想大家尽管不能处理所有名称查找中所遇到的问题，但是对一些常见的名称查找规则也有了充分的经验，可以解决一些常见的问题。但是模板的引入，使得名称查找这一本来就不简单的基本问题变得更加复杂了。考虑下面这个例子： 123456789struct A &#123; int a; &#125;;struct AB &#123; int a, b; &#125;;struct C &#123; int c; &#125;;template &lt;typename T&gt; foo(T&amp; v0, C&amp; v1)&#123; v0.a = 1; v1.a = 2; v1.c = 3;&#125; 简单分析上述代码很容易得到以下结论： 函数foo中的变量v1已经确定是struct C的实例，所以，v1.a = 2;会导致编译错误，v1.c = 3;是正确的代码； 对于变量v0来说，这个问题就变得很微妙。如果v0是struct A或者struct AB的实例，那么foo中的语句v0.a = 1;就是正确的。如果是struct C，那么这段代码就是错误的。 因此在模板定义的地方进行语义分析，并不能完全得出代码是正确或者错误的结论，只有到了实例化阶段，确定了模板参数的类型后，才知道这段代码正确与否。令人高兴的是，在这一问题上，我们和C++标准委员会的见地一致，说明我们的C++水平已经和Herb Sutter不分伯仲了。既然我们和Herb Sutter水平差不多，那凭什么人家就吃香喝辣？下面我们来选几条标准看看服不服： 14.6 名称解析（Name resolution） 1) 模板定义中能够出现以下三类名称： 模板名称、或模板实现中所定义的名称； 和模板参数有关的名称； 模板定义所在的定义域内能看到的名称。 … 9) … 如果名字查找和模板参数有关，那么查找会延期到模板参数全都确定的时候。 … 10) 如果（模板定义内出现的）名字和模板参数无关，那么在模板定义处，就应该找得到这个名字的声明。… 14.6.2 依赖性名称（Dependent names） 1) …（模板定义中的）表达式和类型可能会依赖于模板参数，并且模板参数会影响到名称查找的作用域 … 如果表达式中有操作数依赖于模板参数，那么整个表达式都依赖于模板参数，名称查找延期到模板实例化时进行。并且定义时和实例化时的上下文都会参与名称查找。（依赖性）表达式可以分为类型依赖（类型指模板参数的类型）或值依赖。 14.6.2.2 类型依赖的表达式 2) 如果成员函数所属的类型是和模板参数有关的，那么这个成员函数中的this就认为是类型依赖的。 14.6.3 非依赖性名称（Non-dependent names） 1) 非依赖性名称在模板定义时使用通常的名称查找规则进行名称查找。 [Working Draft: Standard of Programming Language C++, N3337][1] 知道差距在哪了吗：人家会说黑话。什么时候咱们也会说黑话了，就是标准委员会成员了，反正懂得也不比他们少。不过黑话确实不太好懂 —— 怪我翻译不好的人，自己看原文，再说好懂了人家还靠什么吃饭 —— 我们来举一个例子： 12345678910111213141516int a;struct B &#123; int v; &#125;template &lt;typename T&gt; struct X &#123; B b; // B 是第三类名字，b 是第一类 T t; // T 是第二类 X* anthor; // X 这里代指 X&lt;T&gt;，第一类 typedef int Y; // int 是第三类 Y y; // Y 是第一类 C c; // C 什么都不是，编译错误。 void foo() &#123; b.v += y; // b 是第一类，非依赖性名称 b.v *= T::s_mem; // T::s_mem 是第二类 // s_mem的作用域由T决定 // 依赖性名称，类型依赖 &#125;&#125;; 所以，按照标准的意思，名称查找会在模板定义和实例化时各做一次，分别处理非依赖性名称和依赖性名称的查找。这就是“两阶段名称查找”这一名词的由来。只不过这个术语我也不知道是谁发明的，它并没有出现的标准上，但是频繁出现在StackOverflow和Blog上。 接下来，我们就来解决2.3.1节中留下的几个问题。 先看第四个问题。为什么MSVC中，函数模板的定义内不管填什么编译器都不报错？因为MSVC在分析模板中成员函数定义时没有做任何事情。至于为啥连“大王叫我来巡山”都能过得去，这是C++语法&#x2F;语义分析的特殊性导致的。C++是个非常复杂的语言，以至于它的编译器，不可能通过词法-语法-语义多趟分析清晰分割，因为它的语义将会直接干扰到语法： 123void foo()&#123; A&lt;T&gt; b;&#125; 在这段简短的代码中，就包含了两个歧义的可能，一是A是模板，于是A&lt;T&gt;是一个实例化的类型，b是变量，另外一种是比较表达式（Comparison Expression）的组合，((A &lt; T) &gt; b)。 甚至词法分析也会受到语义的干扰，C++11中才明确被修正的vector&lt;vector&lt;int&gt;&gt;，就因为&gt;&gt;被误解为右移或流操作符，而导致某些编译器上的错误。因此，在语义没有确定之前，连语法都没有分析的价值。 大约是基于如此考量，为了偷懒，MSVC将包括所有模板成员函数的语法&#x2F;语义分析工作都挪到了第二个Phase，于是乎连带着语法分析都送进了第二个阶段。符合标准么？显然不符合。 但是这里值得一提的是，MSVC的做法和标准相比，虽然投机取巧，但并非有弊无利。我们来先说一说坏处。考虑以下例子： 12345678910111213// ----------- X.h ------------template &lt;typename T&gt; struct X &#123; // 实现代码&#125;;// ---------- X.cpp -----------// ... 一些代码 ...X&lt;int&gt; xi; // ... 一些代码 ...X&lt;float&gt; xf;// ... 一些代码 ... 此时如果X中有一些与模板参数无关的错误，如果名称查找&#x2F;语义分析在两个阶段完成，那么这些错误会很早、且唯一的被提示出来；但是如果一切都在实例化时处理，那么可能会导致不同的实例化过程提示同样的错误。而模板在运用过程中，往往会产生很多实例，此时便会大量报告同样的错误。 当然，MSVC并不会真的这么做。根据推测，最终他们是合并了相同的错误。因为即便对于模板参数相关的编译错误，也只能看到最后一次实例化的错误信息： 1234567891011121314151617template &lt;typename T&gt; struct X &#123;&#125;; template &lt;typename T&gt; struct Y&#123; typedef X&lt;T&gt; ReboundType; // 类型定义1 void foo() &#123; X&lt;T&gt; instance0; X&lt;T&gt;::MemberType instance1; WTF instance2 &#125;&#125;;void poo()&#123; Y&lt;int&gt;::foo(); Y&lt;float&gt;::foo();&#125; MSVC下和模板相关的错误只有一个： 12345error C2039: &#x27;MemberType&#x27;: is not a member of &#x27;X&lt;T&gt;&#x27; with [ T=float ] 然后是一些语法错误，比如MemberType不是一个合法的标识符之类的。这样甚至你会误以为int情况下模板的实例化是正确的。虽然在有了经验之后会发现这个问题挺荒唐的，但是仍然会让新手有困惑。 相比之下，更加遵守标准的Clang在错误提示上就要清晰许多： 1234567891011121314151617181920error: unknown type name &#x27;WTF&#x27; WTF instance2 ^error: expected &#x27;;&#x27; at end of declaration WTF instance2 ^ ;error: no type named &#x27;MemberType&#x27; in &#x27;X&lt;int&gt;&#x27; typename X&lt;T&gt;::MemberType instance1; ~~~~~~~~~~~~~~~^~~~~~~~~~ note: in instantiation of member function &#x27;Y&lt;int&gt;::foo&#x27; requested here Y&lt;int&gt;::foo(); ^error: no type named &#x27;MemberType&#x27; in &#x27;X&lt;float&gt;&#x27; typename X&lt;T&gt;::MemberType instance1; ~~~~~~~~~~~~~~~^~~~~~~~~~ note: in instantiation of member function &#x27;Y&lt;float&gt;::foo&#x27; requested here Y&lt;float&gt;::foo(); ^4 errors generated. 可以看到，Clang的提示和标准更加契合。它很好地区分了模板在定义和实例化时分别产生的错误。 另一个缺点也与之类似。因为没有足够的检查，如果你写的模板没有被实例化，那么很可能缺陷会一直存在于代码之中。特别是模板代码多在头文件。虽然不如接口那么重要，但也是属于被公开的部分，别人很可能会踩到坑上。缺陷一旦传播开修复起来就没那么容易了。 但是正如我前面所述，这个违背了标准的特性，并不是一无是处。首先，它可以完美的兼容标准。符合标准的、能够被正确编译的代码，一定能够被MSVC的方案所兼容。其次，它带来了一个非常有趣的特性，看下面这个例子： 1234567891011121314struct A;template &lt;typename T&gt; struct X &#123; int v; void convertTo(A&amp; a) &#123; a.v = v; // 这里需要A的实现 &#125;&#125;;struct A &#123; int v; &#125;;void main() &#123; X&lt;int&gt; x; x.foo(5);&#125; 这个例子在Clang中是错误的，因为： 1234567error: variable has incomplete type &#x27;A&#x27; A a; ^ note: forward declaration of &#x27;A&#x27; struct A; ^1 error generated. 符合标准的写法需要将类模板的定义，和函数模板的定义分离开： TODO 此处例子不够恰当，并且描述有歧义。需要在未来版本中修订。 12345678910111213141516struct A;template &lt;typename T&gt; struct X &#123; int v; void convertTo(A&amp; a);&#125;;struct A &#123; int v; &#125;;template &lt;typename T&gt; void X&lt;T&gt;::convertTo(A&amp; a) &#123; a.v = v;&#125; void main() &#123; X&lt;int&gt; x; x.foo(5);&#125; 但是其实我们知道，foo要到实例化之后，才需要真正的做语义分析。在MSVC上，因为函数实现就是到模板实例化时才处理的，所以这个例子是完全正常工作的。因此在上面这个例子中，MSVC的实现要比标准更加易于写和维护，是不是有点写Java&#x2F;C那种声明实现都在同一处的清爽感觉了呢！ 扩展阅读： [The Dreaded Two-Phase Name Lookup][2] 3.3.3. “多余的” typename 关键字到了这里，2.3.1 中提到的四个问题，还有三个没有解决： 12345678template &lt;typename T&gt; struct X &#123;&#125;; template &lt;typename T&gt; struct Y&#123; typedef X&lt;T&gt; ReboundType; // 这里为什么是正确的？ typedef typename X&lt;T&gt;::MemberType MemberType2; // 这里的typename是做什么的？ typedef UnknownType MemberType3; // 这里为什么会出错？&#125;; 我们运用我们2.3.2节中学习到的标准，来对Y内部做一下分析： 123456789101112131415template &lt;typename T&gt; struct Y&#123; // X可以查找到原型； // X&lt;T&gt;是一个依赖性名称，模板定义阶段并不管X&lt;T&gt;是不是正确的。 typedef X&lt;T&gt; ReboundType; // X可以查找到原型； // X&lt;T&gt;是一个依赖性名称，X&lt;T&gt;::MemberType也是一个依赖性名称； // 所以模板声明时也不会管X模板里面有没有MemberType这回事。 typedef typename X&lt;T&gt;::MemberType MemberType2; // UnknownType 不是一个依赖性名称 // 而且这个名字在当前作用域中不存在，所以直接报错。 typedef UnknownType MemberType3; &#125;; 下面，唯一的问题就是第二个：typename是做什么的？ 对于用户来说，这其实是一个语法噪音。也就是说，其实就算没有它，语法上也说得过去。事实上，某些情况下MSVC的确会在标准需要的时候，不用写typename。但是标准中还是规定了形如 T::MemberType 这样的qualified id 在默认情况下不是一个类型，而是解释为T的一个成员变量MemberType，只有当typename修饰之后才能作为类型出现。 事实上，标准对typename的使用规定极为复杂，也算是整个模板中的难点之一。如果想了解所有的标准，需要阅读标准14.6节下2-7条，以及14.6.2.1第一条中对于current instantiation的解释。 简单来说，如果编译器能在出现的时候知道它是一个类型，那么就不需要typename，如果必须要到实例化的时候才能知道它是不是合法，那么定义的时候就把这个名称作为变量而不是类型。 我们用一行代码来说明这个问题： 1a * b; 在没有模板的情况下，这个语句有两种可能的意思：如果a是一个类型，这就是定义了一个指针b，它拥有类型a*；如果a是一个对象或引用，这就是计算一个表达式a*b，虽然结果并没有保存下来。可是如果上面的a是模板参数的成员，会发生什么呢？ 1234template &lt;typename T&gt; void meow()&#123; T::a * b; // 这是指针定义还是表达式语句？&#125; 编译器对模板进行语法检查的时候，必须要知道上面那一行到底是个什么——这当然可以推迟到实例化的时候进行（比如VC，这也是上面说过VC可以不加typename的原因），不过那是另一个故事了——显然在模板定义的时候，编译器并不能妄断。因此，C++标准规定，在没有typename约束的情况下认为这里T::a不是类型，因此T::a * b; 会被当作表达式语句（例如乘法）；而为了告诉编译器这是一个指针的定义，我们必须在T::a之前加上typename关键字，告诉编译器T::a是一个类型，这样整个语句才能符合指针定义的语法。 在这里，我举几个例子帮助大家理解typename的用法，这几个例子已经足以涵盖日常使用[（预览）][3]： 1234567891011121314151617181920212223242526struct A;template &lt;typename T&gt; struct B;template &lt;typename T&gt; struct X &#123; typedef X&lt;T&gt; TA; // 编译器当然知道 X&lt;T&gt; 是一个类型。 typedef X TB; // X 等价于 X&lt;T&gt; 的缩写 typedef T TC; // T 不是一个类型还玩毛 // ！！！注意我要变形了！！！ class Y &#123; typedef X&lt;T&gt; TD; // X 的内部，既然外部高枕无忧，内部更不用说了 typedef X&lt;T&gt;::Y TE; // 嗯，这里也没问题，编译器知道Y就是当前的类型， // 这里在VS2015上会有错，需要添加 typename， // Clang 上顺利通过。 typedef typename X&lt;T*&gt;::Y TF; // 这个居然要加 typename！ // 因为，X&lt;T*&gt;和X&lt;T&gt;不一样哦， // 它可能会在实例化的时候被别的偏特化给抢过去实现了。 &#125;; typedef A TG; // 嗯，没问题，A在外面声明啦 typedef B&lt;T&gt; TH; // B&lt;T&gt;也是一个类型 typedef typename B&lt;T&gt;::type TI; // 嗯，因为不知道B&lt;T&gt;::type的信息， // 所以需要typename typedef B&lt;int&gt;::type TJ; // B&lt;int&gt; 不依赖模板参数， // 所以编译器直接就实例化（instantiate）了 // 但是这个时候，B并没有被实现，所以就出错了&#125;; 3.4. 本章小结这一章是写作中最艰难的一章，中间停滞了将近一年。因为要说清楚C++模板中一些语法噪音和设计决议并不是一件轻松的事情。不过通过这一章的学习，我们知道了下面这几件事情： 部分特化&#x2F;偏特化 和 特化 相当于是模板实例化过程中的if-then-else。这使得我们根据不同类型，选择不同实现的需求得以实现； 在 2.3.3 一节我们插入了C++模板中最难理解的内容之一：名称查找。名称查找是语义分析的一个环节，模板内书写的 变量声明、typedef、类型名称 甚至 类模板中成员函数的实现 都要符合名称查找的规矩才不会出错； C++编译器对语义的分析的原则是“大胆假设，小心求证”：在能求证的地方尽量求证 —— 比如两段式名称查找的第一阶段；无法检查的地方假设你是正确的 —— 比如typedef typename A&lt;T&gt;::MemberType X;在模板定义时因为T不明确不会轻易判定这个语句的死刑。 从下一章开始，我们将进入元编程环节。我们将使用大量的示例，一方面帮助巩固大家学到的模板知识，一方面也会引导大家使用函数式思维去解决常见的问题。","comments":true,"tags":[{"name":"c++ template","slug":"c-template","permalink":"https://kettycode.github.io/tags/c-template/"}]},{"title":"现代C++学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/现代C++/base10/","text":"其他杂项1.新类型 long long intlong long int 并不是 C++11 最先引入的，其实早在 C99， long long int 就已经被纳入 C 标准中，所以大部分的编译器早已支持。 C++11 的工作则是正式把它纳入标准库， 规定了一个 long long int 类型至少具备 64 位的比特数 2.noexcept的修饰和操作C++11 将异常的声明简化为以下两种情况：1.函数可能抛出任何异常2.函数不能抛出任何异常并使用 noexcept 对这两种行为进行限制 12void may_throw(); // 可能抛出异常void no_throw() noexcept; // 不可能抛出异常 使用 noexcept 修饰过的函数如果抛出异常，编译器会使用 std::terminate() 来立即终止程序运行。 noexcept 还能够做操作符，用于操作一个表达式，当表达式无异常时，返回 true，否则返回 false 1234567891011121314151617181920212223#include &lt;iostream&gt;void may_throw() &#123; throw true;&#125;auto non_block_throw = []&#123; may_throw();&#125;;void no_throw() noexcept &#123; return;&#125;auto block_throw = []() noexcept &#123; no_throw();&#125;;int main()&#123; std::cout &lt;&lt; std::boolalpha &lt;&lt; &quot;may_throw() noexcept? &quot; &lt;&lt; noexcept(may_throw()) &lt;&lt; std::endl &lt;&lt; &quot;no_throw() noexcept? &quot; &lt;&lt; noexcept(no_throw()) &lt;&lt; std::endl &lt;&lt; &quot;lmay_throw() noexcept? &quot; &lt;&lt; noexcept(non_block_throw()) &lt;&lt; std::endl &lt;&lt; &quot;lno_throw() noexcept? &quot; &lt;&lt; noexcept(block_throw()) &lt;&lt; std::endl; return 0;&#125; noexcept 修饰完一个函数之后能够起到封锁异常扩散的功效，如果内部产生异常，外部也不会触发 123456789101112131415try &#123; may_throw();&#125; catch (...) &#123; std::cout &lt;&lt; &quot;捕获异常, 来自 may_throw()&quot; &lt;&lt; std::endl;&#125;try &#123; non_block_throw();&#125; catch (...) &#123; std::cout &lt;&lt; &quot;捕获异常, 来自 non_block_throw()&quot; &lt;&lt; std::endl;&#125;try &#123; block_throw();&#125; catch (...) &#123; std::cout &lt;&lt; &quot;捕获异常, 来自 block_throw()&quot; &lt;&lt; std::endl;&#125; 12捕获异常, 来自 may_throw()捕获异常, 来自 non_block_throw() 3.字面量原始字符串字面量C++11 提供了原始字符串字面量的写法，可以在一个字符串前方使用 R 来修饰这个字符串， 同时，将原始字符串使用括号包裹 12345678#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string str = R&quot;(C:\\File\\To\\Path)&quot;; std::cout &lt;&lt; str &lt;&lt; std::endl; return 0;&#125; 自定义字面量C++11 引进了自定义字面量的能力，通过重载双引号后缀运算符实现 12345678910111213141516// 字符串字面量自定义必须设置如下的参数列表std::string operator&quot;&quot; _wow1(const char *wow1, size_t len) &#123; return std::string(wow1)+&quot;woooooooooow, amazing&quot;;&#125;std::string operator&quot;&quot; _wow2 (unsigned long long i) &#123; return std::to_string(i)+&quot;woooooooooow, amazing&quot;;&#125;int main() &#123; auto str = &quot;abc&quot;_wow1; auto num = 1_wow2; std::cout &lt;&lt; str &lt;&lt; std::endl; std::cout &lt;&lt; num &lt;&lt; std::endl; return 0;&#125; 自定义字面量支持四种字面量：1.整型字面量：重载时必须使用 unsigned long long、const char *、模板字面量算符参数，在上面的代码中使用的是前者；2.浮点型字面量：重载时必须使用 long double、const char *、模板字面量算符；3.字符串字面量：必须使用 (const char *, size_t) 形式的参数表；4.字符字面量：参数只能是 char, wchar_t, char16_t, char32_t 这几种类型 4.内存对齐C++ 11 引入了两个新的关键字 alignof 和 alignas 来支持对内存对齐进行控制。 alignof 关键字能够获得一个与平台相关的 std::size_t 类型的值，用于查询该平台的对齐方式。 当然我们有时候并不满足于此，甚至希望自定定义结构的对齐方式，同样，C++ 11 还引入了 alignas 来重新修饰某个结构的对齐方式。 123456789101112131415161718192021#include &lt;iostream&gt;struct Storage &#123; char a; int b; double c; long long d;&#125;;struct alignas(std::max_align_t) AlignasStorage &#123; char a; int b; double c; long long d;&#125;;int main() &#123; std::cout &lt;&lt; alignof(Storage) &lt;&lt; std::endl; std::cout &lt;&lt; alignof(AlignasStorage) &lt;&lt; std::endl; return 0;&#125; 其中 std::max_align_t 要求每个标量类型的对齐方式严格一样，因此它几乎是最大标量没有差异， 进而大部分平台上得到的结果为 long double，因此我们这里得到的 AlignasStorage 的对齐要求是 8 或 16","comments":true,"tags":[{"name":"modern c++","slug":"modern-c","permalink":"https://kettycode.github.io/tags/modern-c/"}]},{"title":"C++模板学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/泛型编程/template4/","text":"4. 深入理解特化与偏特化4.1. 正确的理解偏特化4.1.1. 偏特化与函数重载的比较在前面的章节中，我们介绍了偏特化的形式、也介绍了简单的用例。因为偏特化和函数重载存在着形式上的相似性，因此初学者便会借用重载的概念，来理解偏特化的行为。只是，重载和偏特化尽管相似但仍有差异。 我们来先看一个函数重载的例子： 123456789void doWork(int);void doWork(float);void doWork(int, int);void f() &#123; doWork(0); doWork(0.5f); doWork(0, 0);&#125; 在这个例子中，我们展现了函数重载可以在两种条件下工作：参数数量相同、类型不同；参数数量不同。 仿照重载的形式，我们通过特化机制，试图实现一个模板的“重载”： 1234567891011template &lt;typename T&gt; struct DoWork; // (0) 这是原型template &lt;&gt; struct DoWork&lt;int&gt; &#123;&#125;; // (1) 这是 int 类型的&quot;重载&quot;template &lt;&gt; struct DoWork&lt;float&gt; &#123;&#125;; // (2) 这是 float 类型的&quot;重载&quot;template &lt;&gt; struct DoWork&lt;int, int&gt; &#123;&#125;; // (3) 这是 int, int 类型的“重载”void f()&#123; DoWork&lt;int&gt; i; DoWork&lt;float&gt; f; DoWork&lt;int, int&gt; ii;&#125; 这个例子在字面上“看起来”并没有什么问题，可惜编译器在编译的时候仍然提示出错了goo.gl/zI42Zv： 1234565 : error: too many template arguments for class template &#x27;DoWork&#x27;template &lt;&gt; struct DoWork&lt;int, int&gt; &#123;&#125;; // 这是 int, int 类型的“重载”^ ~~~~1 : note: template is declared heretemplate &lt;typename T&gt; struct DoWork &#123;&#125;; // 这是原型~~~~~~~~~~~~~~~~~~~~~ ^ 从编译出错的失望中冷静一下，在仔细看看函数特化&#x2F;偏特化和一般模板的不同之处： 123template &lt;typename T&gt; class X &#123;&#125;;template &lt;typename T&gt; class X &lt;T*&gt; &#123;&#125;;// ^^^^ 注意这里 对，就是这个&lt;T*&gt;，跟在X后面的“小尾巴”，我们称作实参列表，决定了第二条语句是第一条语句的跟班。所以，第二条语句，即“偏特化”，必须要符合原型X的基本形式：那就是只有一个模板参数。这也是为什么DoWork尝试以template &lt;&gt; struct DoWork&lt;int, int&gt;的形式偏特化的时候，编译器会提示模板实参数量过多。 另外一方面，在类模板的实例化阶段，它并不会直接去寻找 template &lt;&gt; struct DoWork&lt;int, int&gt;这个小跟班，而是会先找到基本形式，template &lt;typename T&gt; struct DoWork;，然后再去寻找相应的特化。 我们以DoWork&lt;int&gt; i;为例，尝试复原一下编译器完成整个模板匹配过程的场景，帮助大家理解。看以下示例代码： 12345678template &lt;typename T&gt; struct DoWork; // (0) 这是原型template &lt;&gt; struct DoWork&lt;int&gt; &#123;&#125;; // (1) 这是 int 类型的特化template &lt;&gt; struct DoWork&lt;float&gt; &#123;&#125;; // (2) 这是 float 类型的特化template &lt;typename U&gt; struct DoWork&lt;U*&gt; &#123;&#125;; // (3) 这是指针类型的偏特化DoWork&lt;int&gt; i; // (4)DoWork&lt;float*&gt; pf; // (5) 首先，编译器分析(0), (1), (2)三句，得知(0)是模板的原型，(1)，(2)，(3)是模板(0)的特化或偏特化。我们假设有两个字典，第一个字典存储了模板原型，我们称之为TemplateDict。第二个字典TemplateSpecDict，存储了模板原型所对应的特化&#x2F;偏特化形式。所以编译器在处理这几句时，可以视作 123456// 以下为伪代码TemplateDict[DoWork&lt;T&gt;] = &#123; DoWork&lt;int&gt;, DoWork&lt;float&gt;, DoWork&lt;U*&gt; &#125;; 然后 (4) 试图以int实例化类模板DoWork。它会在TemplateDict中，找到DoWork，它有一个形式参数T接受类型，正好和我们实例化的要求相符合。并且此时T被推导为int。(5) 中的float*也是同理。 123456789&#123; // 以下为 DoWork&lt;int&gt; 查找对应匹配的伪代码 templateProtoInt = TemplateDict.find(DoWork, int); // 查找模板原型，查找到(0) template = templatePrototype.match(int); // 以 int 对应 int 匹配到 (1)&#125;&#123; // 以下为DoWork&lt;float*&gt; 查找对应匹配的伪代码 templateProtoIntPtr = TemplateDict.find(DoWork, float*) // 查找模板原型，查找到(0) template = templateProtoIntPtr.match(float*) // 以 float* 对应 U* 匹配到 (3)，此时U为float&#125; 那么根据上面的步骤所展现的基本原理，我们随便来几个练习： 1234567891011121314151617181920212223242526template &lt;typename T, typename U&gt; struct X ; // 0 // 原型有两个类型参数 // 所以下面的这些偏特化的实参列表 // 也需要两个类型参数对应template &lt;typename T&gt; struct X&lt;T, T &gt; &#123;&#125;; // 1template &lt;typename T&gt; struct X&lt;T*, T &gt; &#123;&#125;; // 2template &lt;typename T&gt; struct X&lt;T, T* &gt; &#123;&#125;; // 3template &lt;typename U&gt; struct X&lt;U, int&gt; &#123;&#125;; // 4template &lt;typename U&gt; struct X&lt;U*, int&gt; &#123;&#125;; // 5template &lt;typename U, typename T&gt; struct X&lt;U*, T* &gt; &#123;&#125;; // 6template &lt;typename U, typename T&gt; struct X&lt;U, T* &gt; &#123;&#125;; // 7template &lt;typename T&gt; struct X&lt;unique_ptr&lt;T&gt;, shared_ptr&lt;T&gt;&gt;; // 8// 以下特化，分别对应哪个偏特化的实例？// 此时偏特化中的T或U分别是什么类型？X&lt;float*, int&gt; v0; X&lt;double*, int&gt; v1; X&lt;double, double&gt; v2; X&lt;float*, double*&gt; v3; X&lt;float*, float*&gt; v4; X&lt;double, float*&gt; v5; X&lt;int, double*&gt; v6; X&lt;int*, int&gt; v7; X&lt;double*, double&gt; v8; 在上面这段例子中，有几个值得注意之处。首先，偏特化时的模板形参，和原型的模板形参没有任何关系。和原型不同，它的顺序完全不影响模式匹配的顺序，它只是偏特化模式，如&lt;U, int&gt;中U的声明，真正的模式，是由&lt;U, int&gt;体现出来的。 这也是为什么在特化的时候，当所有类型都已经确定，我们就可以抛弃全部的模板参数，写出template &lt;&gt; struct X&lt;int, float&gt;这样的形式：因为所有列表中所有参数都确定了，就不需要额外的形式参数了。 其次，作为一个模式匹配，偏特化的实参列表中展现出来的“样子”，就是它能被匹配的原因。比如，struct X&lt;T, T&gt;中，要求模板的两个参数必须是相同的类型。而struct X&lt;T, T*&gt;，则代表第二个模板类型参数必须是第一个模板类型参数的指针，比如X&lt;float***, float****&gt;就能匹配上。当然，除了简单的指针、const和volatile修饰符，其他的类模板也可以作为偏特化时的“模式”出现，例如示例8，它要求传入同一个类型的unique_ptr和shared_ptr。C++标准中指出下列模式都是可以被匹配的： N3337, 14.8.2.5&#x2F;8 令T是模板类型实参或者类型列表（如 int, float, double 这样的，TT是template-template实参（参见6.2节），i是模板的非类型参数（整数、指针等），则以下形式的形参都会参与匹配： T, cv-list T, T*, template-name &lt;T&gt;, T&amp;, T&amp;&amp; T [ integer-constant ] type (T), T(), T(T) T type ::*, type T::*, T T::* T (type ::*)(), type (T::*)(), type (type ::*)(T), type (T::*)(T), T (type ::*)(T), T (T::*)(), T (T::*)(T) type [i], template-name &lt;i&gt;, TT&lt;T&gt;, TT&lt;i&gt;, TT&lt;&gt; 对于某些实例化，偏特化的选择并不是唯一的。比如v4的参数是&lt;float*, float*&gt;，能够匹配的就有三条规则，1，6和7。很显然，6还是比7好一些，因为能多匹配一个指针。但是1和6，就很难说清楚谁更好了。一个说明了两者类型相同；另外一个则说明了两者都是指针。所以在这里，编译器也没办法决定使用那个，只好报出了编译器错误。 其他的示例可以先自己推测一下， 再去编译器上尝试一番：goo.gl/9UVzje。 4.1.2. 不定长的模板参数不过这个时候也许你还不死心。有没有一种办法能够让例子DoWork像重载一样，支持对长度不一的参数列表分别偏特化&#x2F;特化呢？ 答案当然是肯定的。 首先，首先我们要让模板实例化时的模板参数统一到相同形式上。逆向思维一下，虽然两个类型参数我们很难缩成一个参数，但是我们可以通过添加额外的参数，把一个扩展成两个呀。比如这样： 123DoWork&lt;int, void&gt; i;DoWork&lt;float, void&gt; f;DoWork&lt;int, int &gt; ii; 这时，我们就能写出统一的模板原型： 1template &lt;typename T0, typename T1&gt; struct DoWork; 继而偏特化&#x2F;特化问题也解决了： 123template &lt;&gt; struct DoWork&lt;int, void&gt; &#123;&#125;; // (1) 这是 int 类型的特化template &lt;&gt; struct DoWork&lt;float, void&gt; &#123;&#125;; // (2) 这是 float 类型的特化template &lt;&gt; struct DoWork&lt;int, int&gt; &#123;&#125;; // (3) 这是 int, int 类型的特化 显而易见这个解决方案并不那么完美。首先，不管是偏特化还是用户实例化模板的时候，都需要多撰写好几个void，而且最长的那个参数越长，需要写的就越多；其次，如果我们的DoWork在程序维护的过程中新加入了一个参数列表更长的实例，那么最悲惨的事情就会发生 —— 原型、每一个偏特化、每一个实例化都要追加上void以凑齐新出现的实例所需要的参数数量。 所幸模板参数也有一个和函数参数相同的特性：默认实参（Default Arguments）。只需要一个例子，你们就能看明白了goo.gl/TtmcY9： 1234567891011template &lt;typename T0, typename T1 = void&gt; struct DoWork;template &lt;typename T&gt; struct DoWork&lt;T&gt; &#123;&#125;;template &lt;&gt; struct DoWork&lt;int&gt; &#123;&#125;;template &lt;&gt; struct DoWork&lt;float&gt; &#123;&#125;;template &lt;&gt; struct DoWork&lt;int, int&gt; &#123;&#125;;DoWork&lt;int&gt; i;DoWork&lt;float&gt; f;DoWork&lt;double&gt; d;DoWork&lt;int, int&gt; ii; 所有参数不足，即原型中参数T1没有指定的地方，都由T1自己的默认参数void补齐了。 但是这个方案仍然有些美中不足之处。 比如，尽管我们默认了所有无效的类型都以void结尾，所以正确的类型列表应该是类似于&lt;int, float, char, void, void&gt;这样的形态。但你阻止不了你的用户写出类似于&lt;void, int, void, float, char, void, void&gt;这样不符合约定的类型参数列表。 其次，假设这段代码中有一个函数，它的参数使用了和类模板相同的参数列表类型，如下面这段代码： 123456789101112template &lt;typename T0, typename T1 = void&gt; struct X &#123; static void call(T0 const&amp; p0, T1 const&amp; p1); // 0&#125;;template &lt;typename T0&gt; struct X&lt;T0&gt; &#123; static void call(T0 const&amp; p0); // 1&#125;;void foo()&#123; X&lt;int&gt;::call(5); // 调用函数 1 X&lt;int, float&gt;::call(5, 0.5f); // 调用函数 0&#125; 那么，每加一个参数就要多写一个偏特化的形式，甚至还要重复编写一些可以共享的实现。 不过不管怎么说，以长参数加默认参数的方式支持变长参数是可行的做法，这也是C++98&#x2F;03时代的唯一选择。 例如，Boost.Tuple就使用了这个方法，支持了变长的Tuple： 12345678910111213141516// Tuple 的声明，来自 booststruct null_type;template &lt; class T0 = null_type, class T1 = null_type, class T2 = null_type, class T3 = null_type, class T4 = null_type, class T5 = null_type, class T6 = null_type, class T7 = null_type, class T8 = null_type, class T9 = null_type&gt;class tuple;// Tuple的一些用例tuple&lt;int&gt; a;tuple&lt;double&amp;, const double&amp;, const double, double*, const double*&gt; b;tuple&lt;A, int(*)(char, int), B(A::*)(C&amp;), C&gt; c;tuple&lt;std::string, std::pair&lt;A, B&gt; &gt; d;tuple&lt;A*, tuple&lt;const A*, const B&amp;, C&gt;, bool, void*&gt; e; 此外，Boost.MPL也使用了这个手法将boost::mpl::vector映射到boost::mpl::vector _n_上。但是我们也看到了，这个方案的缺陷很明显：代码臃肿和潜在的正确性问题。此外，过度使用模板偏特化、大量冗余的类型参数也给编译器带来了沉重的负担。 为了缓解这些问题，在C++11中，引入了变参模板（Variadic Template）。我们来看看支持了变参模板的C++11是如何实现tuple的： 1template &lt;typename... Ts&gt; class tuple; 是不是一下子简洁了很多！这里的typename... Ts相当于一个声明，是说Ts不是一个类型，而是一个不定常的类型列表。同C语言的不定长参数一样，它通常只能放在参数列表的最后。看下面的例子： 1234template &lt;typename... Ts, typename U&gt; class X &#123;&#125;; // (1) error!template &lt;typename... Ts&gt; class Y &#123;&#125;; // (2)template &lt;typename... Ts, typename U&gt; class Y&lt;U, Ts...&gt; &#123;&#125;; // (3)template &lt;typename... Ts, typename U&gt; class Y&lt;Ts..., U&gt; &#123;&#125;; // (4) error! 为什么第(1)条语句会出错呢？(1)是模板原型，模板实例化时，要以它为基础和实例化时的类型实参相匹配。因为C++的模板是自左向右匹配的，所以不定长参数只能结尾。其他形式，无论写作Ts, U，或者是Ts, V, Us,，或者是V, Ts, Us都是不可取的。(4) 也存在同样的问题。 但是，为什么(3)中， 模板参数和(1)相同，都是typename... Ts, typename U，但是编译器却并没有报错呢？ 答案在这一节的早些时候。(3)和(1)不同，它并不是模板的原型，它只是Y的一个偏特化。回顾我们在之前所提到的，偏特化时，模板参数列表并不代表匹配顺序，它们只是为偏特化的模式提供的声明，也就是说，它们的匹配顺序，只是按照&lt;U, Ts...&gt;来，而之前的参数只是告诉你Ts是一个类型列表，而U是一个类型，排名不分先后。 在这里，我们只提到了变长模板参数的声明，如何使用我们将在第四章讲述。 4.1.3. 模板的默认实参在上一节中，我们介绍了模板对默认实参的支持。当时我们的例子很简单，默认模板实参是一个确定的类型void或者自定义的null_type： 123template &lt; typename T0, typename T1 = void, typename T2 = void&gt; class Tuple; 实际上，模板的默认参数不仅仅可以是一个确定的类型，它还能是以其他类型为参数的一个类型表达式。考虑下面的例子：我们要执行两个同类型变量的除法，它对浮点、整数和其他类型分别采取不同的措施。对于浮点，执行内置除法；对于整数，要处理除零保护，防止引发异常；对于其他类型，执行一个叫做CustomeDiv的函数。 第一步，我们先把浮点正确的写出来： 12345678910111213141516171819202122232425262728include &lt;type_traits&gt;template &lt;typename T&gt; T CustomDiv(T lhs, T rhs) &#123; // Custom Div的实现&#125;template &lt;typename T, bool IsFloat = std::is_floating_point&lt;T&gt;::value&gt; struct SafeDivide &#123; static T Do(T lhs, T rhs) &#123; return CustomDiv(lhs, rhs); &#125;&#125;;template &lt;typename T&gt; struct SafeDivide&lt;T, true&gt;&#123; // 偏特化A static T Do(T lhs, T rhs)&#123; return lhs/rhs; &#125;&#125;;template &lt;typename T&gt; struct SafeDivide&lt;T, false&gt;&#123; // 偏特化B static T Do(T lhs, T rhs)&#123; return lhs; &#125;&#125;;void foo()&#123; SafeDivide&lt;float&gt;::Do(1.0f, 2.0f); // 调用偏特化A SafeDivide&lt;int&gt;::Do(1, 2); // 调用偏特化B&#125; 在实例化的时候，尽管我们只为SafeDivide指定了参数T，但是它的另一个参数IsFloat在缺省的情况下，可以根据T，求出表达式std::is_floating_point&lt;T&gt;::value的值作为实参的值，带入到SafeDivide的匹配中。 嗯，这个时候我们要再把整型和其他类型纳入进来，无外乎就是加这么一个参数goo.gl/0Lqywt： 123456789101112131415161718192021222324252627282930313233343536include &lt;complex&gt;include &lt;type_traits&gt;template &lt;typename T&gt; T CustomDiv(T lhs, T rhs) &#123; T v; // Custom Div的实现 return v;&#125;template &lt; typename T, bool IsFloat = std::is_floating_point&lt;T&gt;::value, bool IsIntegral = std::is_integral&lt;T&gt;::value&gt; struct SafeDivide &#123; static T Do(T lhs, T rhs) &#123; return CustomDiv(lhs, rhs); &#125;&#125;;template &lt;typename T&gt; struct SafeDivide&lt;T, true, false&gt;&#123; // 偏特化A static T Do(T lhs, T rhs)&#123; return lhs/rhs; &#125;&#125;;template &lt;typename T&gt; struct SafeDivide&lt;T, false, true&gt;&#123; // 偏特化B static T Do(T lhs, T rhs)&#123; return rhs == 0 ? 0 : lhs/rhs; &#125;&#125;;void foo()&#123; SafeDivide&lt;float&gt;::Do(1.0f, 2.0f); // 调用偏特化A SafeDivide&lt;int&gt;::Do(1, 2); // 调用偏特化B SafeDivide&lt;std::complex&lt;float&gt;&gt;::Do(&#123;1.f, 2.f&#125;, &#123;1.f, -2.f&#125;); // 调用一般形式&#125; 当然，这时也许你会注意到，is_integral，is_floating_point和其他类类型三者是互斥的，那能不能只使用一个条件量来进行分派呢？答案当然是可以的：goo.gl/jYp5J2： 12345678910111213141516171819202122232425262728293031323334include &lt;complex&gt;include &lt;type_traits&gt;template &lt;typename T&gt; T CustomDiv(T lhs, T rhs) &#123; T v; // Custom Div的实现 return v;&#125;template &lt;typename T, typename Enabled = std::true_type&gt; struct SafeDivide &#123; static T Do(T lhs, T rhs) &#123; return CustomDiv(lhs, rhs); &#125;&#125;;template &lt;typename T&gt; struct SafeDivide&lt; T, typename std::is_floating_point&lt;T&gt;::type&gt;&#123; // 偏特化A static T Do(T lhs, T rhs)&#123; return lhs/rhs; &#125;&#125;;template &lt;typename T&gt; struct SafeDivide&lt; T, typename std::is_integral&lt;T&gt;::type&gt;&#123; // 偏特化B static T Do(T lhs, T rhs)&#123; return rhs == 0 ? 0 : lhs/rhs; &#125;&#125;;void foo()&#123; SafeDivide&lt;float&gt;::Do(1.0f, 2.0f); // 调用偏特化A SafeDivide&lt;int&gt;::Do(1, 2); // 调用偏特化B SafeDivide&lt;std::complex&lt;float&gt;&gt;::Do(&#123;1.f, 2.f&#125;, &#123;1.f, -2.f&#125;);&#125; 我们借助这个例子，帮助大家理解一下这个结构是怎么工作的： 对SafeDivide&lt;int&gt; 通过匹配类模板的泛化形式，计算默认实参，可以知道我们要匹配的模板实参是SafeDivide&lt;int, true_type&gt; 计算两个偏特化的形式的匹配：A得到&lt;int, false_type&gt;,和B得到 &lt;int, true_type&gt; 最后偏特化B的匹配结果和模板实参一致，使用它。 针对SafeDivide&lt;complex&lt;float&gt;&gt; 通过匹配类模板的泛化形式，可以知道我们要匹配的模板实参是SafeDivide&lt;complex&lt;float&gt;, true_type&gt; 计算两个偏特化形式的匹配：A和B均得到SafeDivide&lt;complex&lt;float&gt;, false_type&gt; A和B都与模板实参无法匹配，所以使用原型，调用CustomDiv 4.2. 后悔药：SFINAE考虑下面这个函数模板： 1234template &lt;typename T, typename U&gt;void foo(T t, typename U::type u) &#123; // ...&#125; 到本节为止，我们所有的例子都保证了一旦咱们敲定了模板参数中 T 和 U，函数参变量 t 和 u 的类型都是成立的，比如下面这样： 123456789101112struct X &#123; typedef float type;&#125;;template &lt;typename T, typename U&gt;void foo(T t, typename U::type u) &#123; // ...&#125;void callFoo() &#123; foo&lt;int, X&gt;(5, 5.0); // T == int, typename U::type == X::type == float&#125; 那么这里有一个可能都不算是问题的问题 —— 对于下面的代码，你认为它会提示怎么样的错误： 1234567891011121314151617struct X &#123; typedef float type;&#125;;struct Y &#123; typedef float type2;&#125;;template &lt;typename T, typename U&gt;void foo(T t, typename U::type u) &#123; // ...&#125;void callFoo() &#123; foo&lt;int, X&gt;(5, 5.0); // T == int, typename U::type == X::type == float foo&lt;int, Y&gt;(5, 5.0); // ???&#125; 这个时候你也许会说：啊，这个简单，Y 没有 type 这个成员自然会出错啦！嗯，这个时候咱们来看看Clang给出的结果： 12345error: no matching function for call to &#x27;foo&#x27; foo&lt;int, Y&gt;(5, 5.0); // ??? ^~~~~~~~~~~ note: candidate template ignored: substitution failure [with T = int, U = Y]: no type named &#x27;type&#x27; in &#x27;Y&#x27; void foo(T t, typename U::type u) &#123; 完整翻译过来就是，直接的出错原因是没有匹配的 foo 函数，间接原因是尝试用 [T = int, U = y] 做类型替换的时候失败了，所以这个函数模板就被忽略了。等等，不是出错，而是被忽略了？那么也就是说，只要有别的能匹配的类型兜着，编译器就无视这里的失败了？ 银河火箭队的阿喵说，就是这样。不信邪的朋友可以试试下面的代码： 123456789101112131415161718192021struct X &#123; typedef float type;&#125;;struct Y &#123; typedef float type2;&#125;;template &lt;typename T, typename U&gt;void foo(T t, typename U::type u) &#123; // ...&#125;template &lt;typename T, typename U&gt;void foo(T t, typename U::type2 u) &#123; // ...&#125; void callFoo() &#123; foo&lt;int, X&gt;(5, 5.0); // T == int, typename U::type == X::type == float foo&lt;int, Y&gt;( 1, 1.0 ); // ???&#125; 这下相信编译器真的是不关心替换失败了吧。我们管这种只要有正确的候选，就无视替换失败的做法为SFINAE。 我们不用纠结这个词的发音，它来自于 Substitution failure is not an error 的首字母缩写。这一句之乎者也般难懂的话，由之乎者 —— 啊，不，Substitution，Failure和Error三个词构成。 我们从最简单的词“Error”开始理解。Error就是一般意义上的编译错误。一旦出现编译错误，大家都知道，编译器就会中止编译，并且停止接下来的代码生成和链接等后续活动。 其次，我们再说“Failure”。很多时候光看字面意思，很多人会把 Failure 和 Error 等同起来。但是实际上Failure很多场合下只是一个中性词。比如我们看下面这个虚构的例子就知道这两者的区别了。 假设我们有一个语法分析器，其中某一个规则需要匹配一个token，它可以是标识符，字面量或者是字符串，那么我们会有下面的代码： 1234567891011121314switch(token)&#123;case IDENTIFIER: // do something break;case LITERAL_NUMBER: // do something break;case LITERAL_STRING: // do something break;default: throw WrongToken(token);&#125; 假如我们当前的token是 LITERAL_STRING 的时候，那么第一步它在匹配 IDENTIFIER 时，我们可以认为它失败（failure）了，但是它在第三步就会匹配上，所以它并不是一个错误。 但是如果这个token既不是标识符、也不是数字字面量、也不是字符串字面量，而且我们的语法规定除了这三类值以外其他统统都是非法的时，我们才认为它是一个error。 大家所熟知的函数重载也是如此。比如说下面这个例子： 123456789101112struct A &#123;&#125;;struct B: public A &#123;&#125;;struct C &#123;&#125;;void foo(A const&amp;) &#123;&#125;void foo(B const&amp;) &#123;&#125;void callFoo() &#123; foo( A() ); foo( B() ); foo( C() );&#125; 那么 foo( A() ) 虽然匹配 foo(B const&amp;) 会失败，但是它起码能匹配 foo(A const&amp;)，所以它是正确的；foo( B() ) 能同时匹配两个函数原型，但是 foo(B const&amp;) 要更好一些，因此它选择了这个原型。而 foo( C() ); 因为两个函数都匹配失败（Failure）了，所以它找不到相应的原型，这时才会报出一个编译器错误（Error）。 所以到这里我们就明白了，在很多情况下，Failure is not an error。编译器在遇到Failure的时候，往往还需要尝试其他的可能性。 好，现在我们把最后一个词，Substitution，加入到我们的字典中。现在这句话的意思就是说，我们要把 Failure is not an error 的概念，推广到Substitution阶段。 所谓substitution，就是将函数模板中的形参，替换成实参的过程。概念很简洁但是实现却颇多细节，所以C++标准中对这一概念的解释比较拗口。它分别指出了以下几点： 什么时候函数模板会发生实参 替代（Substitute） 形参的行为； 什么样的行为被称作 Substitution； 什么样的行为不可以被称作 Substitution Failure —— 他们叫SFINAE error。 我们在此不再详述，有兴趣的同学可以参照这里，这是标准的一个精炼版本。这里我们简单的解释一下。 考虑我们有这么个函数签名： 12345678910111213template &lt; typename T0, // 一大坨其他模板参数 typename U = /* 和前面T有关的一大坨 */&gt;RType /* 和模板参数有关的一大坨 */functionName ( PType0 /* PType0 是和模板参数有关的一大坨 */, PType1 /* PType1 是和模板参数有关的一大坨 */, // ... 其他参数) &#123; // 实现，和模板参数有关的一大坨&#125; 那么，在这个函数模板被实例化的时候，所有函数签名上的“和模板参数有关的一大坨”被推导出具体类型的过程，就是替换。一个更具体的例子来解释上面的“一大坨”： 1234567891011121314151617template &lt; typename T, typename U = typename vector&lt;T&gt;::iterator // 1&gt;typename vector&lt;T&gt;::value_type // 1foo( T*, // 1 T&amp;, // 1 typename T::internal_type, // 1 typename add_reference&lt;T&gt;::type, // 1 int // 这里都不需要 substitution)&#123; // 根据定义，substitution只发生在函数签名上。 // 故而整个函数实现部分都不会存在 substitution。 // 这是一个重点需要记住。&#125; 所有标记为 1 的部分，都是需要替换的部分，而它们在替换过程中的失败（failure），就称之为替换失败（substitution failure）。 下面的代码是提供了一些替换成功和替换失败的示例： 1234567891011121314151617struct X &#123; typedef int type;&#125;;struct Y &#123; typedef int type2;&#125;;template &lt;typename T&gt; void foo(typename T::type); // Foo0template &lt;typename T&gt; void foo(typename T::type2); // Foo1template &lt;typename T&gt; void foo(T); // Foo2void callFoo() &#123; foo&lt;X&gt;(5); // Foo0: Succeed, Foo1: Failed, Foo2: Failed foo&lt;Y&gt;(10); // Foo0: Failed, Foo1: Succeed, Foo2: Failed foo&lt;int&gt;(15); // Foo0: Failed, Foo1: Failed, Foo2: Succeed&#125; 在这个例子中，当我们指定 foo&lt;Y&gt; 的时候，substitution就开始工作了，而且会同时工作在三个不同的 foo 签名上。如果我们仅仅因为 Y 没有 type，匹配 Foo0 失败了，就宣布代码有错，中止编译，那显然是武断的。因为 Foo1 是可以被正确替换的，我们也希望 Foo1 成为 foo&lt;Y&gt; 的原型。 std&#x2F;boost库中的 enable_if 是 SFINAE 最直接也是最主要的应用。所以我们通过下面 enable_if 的例子，来深入理解一下 SFINAE 在模板编程中的作用。 假设我们有两个不同类型的计数器（counter），一种是普通的整数类型，另外一种是一个复杂对象，它从接口 ICounter 继承，这个接口有一个成员叫做increase实现计数功能。现在，我们想把这两种类型的counter封装一个统一的调用：inc_counter。那么，我们直觉会简单粗暴的写出下面的代码： 1234567891011121314151617181920212223242526272829struct ICounter &#123; virtual void increase() = 0; virtual ~ICounter() &#123;&#125;&#125;;struct Counter: public ICounter &#123; void increase() override &#123; // Implements &#125;&#125;;template &lt;typename T&gt;void inc_counter(T&amp; counterObj) &#123; counterObj.increase();&#125;template &lt;typename T&gt;void inc_counter(T&amp; intTypeCounter)&#123; ++intTypeCounter;&#125;void doSomething() &#123; Counter cntObj; uint32_t cntUI32; // blah blah blah inc_counter(cntObj); inc_counter(cntUI32);&#125; 我们非常希望它展现出预期的行为。因为其实我们是知道对于任何一个调用，两个 inc_counter 只有一个是能够编译正确的。“有且唯一”，我们理应当期望编译器能够挑出那个唯一来。 可惜编译器做不到这一点。首先，它就告诉我们，这两个签名 12template &lt;typename T&gt; void inc_counter(T&amp; counterObj);template &lt;typename T&gt; void inc_counter(T&amp; intTypeCounter); 其实是一模一样的。我们遇到了 redefinition。 我们看看 enable_if 是怎么解决这个问题的。我们通过 enable_if 这个 T 对于不同的实例做个限定： 1234567891011template &lt;typename T&gt; void inc_counter( T&amp; counterObj, typename std::enable_if&lt; std::is_base_of&lt;ICounter, T&gt;::value &gt;::type* = nullptr );template &lt;typename T&gt; void inc_counter( T&amp; counterInt, typename std::enable_if&lt; std::is_integral&lt;T&gt;::value &gt;::type* = nullptr ); 然后我们解释一下，这个 enable_if 是怎么工作的，语法为什么这么丑： 首先，替换（substitution）只有在推断函数类型的时候，才会起作用。推断函数类型需要参数的类型，所以， typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type 这么一长串代码，就是为了让 enable_if 参与到函数类型中； 其次， is_integral&lt;T&gt;::value 返回一个布尔类型的编译器常数，告诉我们它是或者不是一个 integral type，enable_if&lt;C&gt; 的作用就是，如果这个 C 值为 True，那么 enable_if&lt;C&gt;::type 就会被推断成一个 void 或者是别的什么类型，让整个函数匹配后的类型变成 void inc_counter&lt;int&gt;(int &amp; counterInt, void* dummy = nullptr); 如果这个值为 False ，那么 enable_if&lt;false&gt; 这个特化形式中，压根就没有这个 ::type，于是替换就失败了。和我们之前的例子中一样，这个函数原型就不会被产生出来。 所以我们能保证，无论对于 int 还是 counter 类型的实例，我们都只有一个函数原型通过了substitution —— 这样就保证了它的“有且唯一”，编译器也不会因为你某个替换失败而无视成功的那个实例。 这个例子说到了这里，熟悉C++的你，一定会站出来说我们只要把第一个签名改成： 1void inc_counter(ICounter&amp; counterObj); 就能完美解决这个问题了，根本不需要这么复杂的编译器机制。 嗯，你说的没错，在这里这个特性一点都没用。 这也提醒我们，当你觉得需要写 enable_if 的时候，首先要考虑到以下可能的替代方案： 重载（适用于函数模板） 偏特化（适用于类模板） 虚函数 但是问题到了这里并没有结束。因为 increase 毕竟是个虚函数。假如 Counter 需要调用的地方实在是太多了，这个时候我们会非常期望 increase 不再是个虚函数以提高性能。此时我们会调整继承层级： 123456struct ICounter &#123;&#125;;struct Counter: public ICounter &#123; void increase() &#123; // impl &#125;&#125;; 那么原有的 void inc_counter(ICounter&amp; counterObj) 就无法再执行下去了。这个时候你可能会考虑一些变通的办法： 123456789101112131415template &lt;typename T&gt;void inc_counter(ICounter&amp; c) &#123;&#125;;template &lt;typename T&gt;void inc_counter(T&amp; c) &#123; ++c; &#125;;void doSomething() &#123; Counter cntObj; uint32_t cntUI32; // blah blah blah inc_counter(cntObj); // 1 inc_counter(static_cast&lt;ICounter&amp;&gt;(cntObj)); // 2 inc_counter(cntUI32); // 3&#125; 对于调用 1，因为 cntObj 到 ICounter 是需要类型转换的，所以比 void inc_counter(T&amp;) [T = Counter] 要更差一些。然后它会直接实例化后者，结果实现变成了 ++cntObj，BOOM！ 那么我们做 2 试试看？嗯，工作的很好。但是等等，我们的初衷是什么来着？不就是让 inc_counter 对不同的计数器类型透明吗？这不是又一夜回到解放前了？ 所以这个时候，就能看到 enable_if 是如何通过 SFINAE 发挥威力的了： 1234567891011121314151617181920212223242526272829303132333435include &lt;type_traits&gt;include &lt;utility&gt;include &lt;cstdint&gt;struct ICounter &#123;&#125;;struct Counter: public ICounter &#123; void increase() &#123; // impl &#125;&#125;;template &lt;typename T&gt; void inc_counter( T&amp; counterObj, typename std::enable_if&lt; std::is_base_of&lt;ICounter, T&gt;::value &gt;::type* = nullptr )&#123; counterObj.increase(); &#125;template &lt;typename T&gt; void inc_counter( T&amp; counterInt, typename std::enable_if&lt; std::is_integral&lt;T&gt;::value &gt;::type* = nullptr )&#123; ++counterInt;&#125; void doSomething() &#123; Counter cntObj; uint32_t cntUI32; // blah blah blah inc_counter(cntObj); // OK! inc_counter(cntUI32); // OK!&#125; 这个代码是不是看起来有点脏脏的。眼尖的你定睛一瞧，咦， ICounter 不是已经空了吗，为什么我们还要用它作为基类呢？ 这是个好问题。在本例中，我们用它来区分一个counter是不是继承自ICounter。最终目的，是希望知道 counter 有没有 increase 这个函数。 所以 ICounter 只是相当于一个标签。而于情于理这个标签都是个累赘。但是在C++11之前，我们并没有办法去写类似于： 1template &lt;typename T&gt; void foo(T&amp; c, decltype(c.increase())* = nullptr); 这样的函数签名，因为假如 T 是 int，那么 c.increase() 这个函数调用就不存在。但它又不属于Type Failure，而是一个Expression Failure，在C++11之前它会直接导致编译器出错，这并不是我们所期望的。所以我们才退而求其次，用一个类似于标签的形式来提供我们所需要的类型信息。以后的章节，后面我们会说到，这种和类型有关的信息我们可以称之为 type traits。 到了C++11，它正式提供了 Expression SFINAE，这时我们就能抛开 ICounter 这个无用的Tag，直接写出我们要写的东西： 123456789101112131415161718192021222324struct Counter &#123; void increase() &#123; // Implements &#125;&#125;;template &lt;typename T&gt;void inc_counter(T&amp; intTypeCounter, std::decay_t&lt;decltype(++intTypeCounter)&gt;* = nullptr) &#123; ++intTypeCounter;&#125;template &lt;typename T&gt;void inc_counter(T&amp; counterObj, std::decay_t&lt;decltype(counterObj.increase())&gt;* = nullptr) &#123; counterObj.increase();&#125;void doSomething() &#123; Counter cntObj; uint32_t cntUI32; // blah blah blah inc_counter(cntObj); inc_counter(cntUI32);&#125; 此外，还有一种情况只能使用 SFINAE，而无法使用包括继承、重载在内的任何方法，这就是Universal Reference。比如， 12// 这里的a是个通用引用，可以准确的处理左右值引用的问题。template &lt;typename ArgT&gt; void foo(ArgT&amp;&amp; a); 假如我们要限定ArgT只能是 float 的衍生类型，那么写成下面这个样子是不对的，它实际上只能接受 float 的右值引用。 1void foo(float&amp;&amp; a); 此时的唯一选择，就是使用Universal Reference，并增加 enable_if 限定类型，如下面这样： 1234567template &lt;typename ArgT&gt;void foo( ArgT&amp;&amp; a, typename std::enabled_if&lt; std::is_same&lt;std::decay_t&lt;ArgT&gt;, float&gt;::value &gt;::type* = nullptr); 从上面这些例子可以看到，SFINAE最主要的作用，是保证编译器在泛型函数、偏特化、及一般重载函数中遴选函数原型的候选列表时不被打断。除此之外，它还有一个很重要的元编程作用就是实现部分的编译期自省和反射。 虽然它写起来并不直观，但是对于既没有编译器自省、也没有Concept的C++11来说，已经是最好的选择了。 4.3. Concept “概念”：对模板参数约束的直接描述4.3.1. “概念” 解决了什么问题从上一节可以看出，我们兜兜转转了那么久，就是为了解决两个问题： 在模板进行特化的时候，盘算一下并告诉编译器这里能不能特化； 在函数决议面临多个候选的时候，如果有且仅有其中一个原型能够被函数决议接纳，那就决定是你了！ 如果语言能允许用户直接描述需求并传达给编译器，不就不用这么麻烦了么。其实在很多现代语言中，都有类似的语言要素存在，比如C的约束（constraint on type parameters)： 1234567public class Employee &#123; // ...&#125;public class GenericList&lt;T&gt; where T : Employee &#123; // ...&#125; 上例就非常清晰的呈现了我们对GenericList中T的要求是：它得是一个Employee或Employee的子类。 这种“清晰的”类型约束，在C++中称作概念（Concept）。最早有迹可循的概念相关工作应当从2003年后就开始了。2006年Bjarne在POPL 06上的一篇报告“Specifying C++ concepts”算是“近代”Concept工作的首次公开亮相。委员会为Concept筹划数年，在2008年提出了第一版Concepts提案，试图进入C++0x的标准中。这也是Concept第一次在C++社群当中被广泛“炒作”。不过2009年的会议，让“近代”Concept在N2617草案戛然而止。 2013年之后，Concept改头换面为Concept Lite提案（N3701)卷土重来，历经多方博弈和多轮演化，最终形成了我们在C++20里看到的Concept。有关于Concept的方法论和比较，B.S. 在白皮书中有过比较详细的交代。 总之，在concept进入标准之后，模板特化的类型约束写起来就方便与直接多了。而且这些约束之间还可以像表达式一样复用和组合。虽然因为C++类型系统自身的琐碎导致基础库中的concept仍然相当的冗长，但是比起之前起码具备了可用性。 比如我们拿上一节中最后一个例子作为对比： 12345678910111213// SFINAEtemplate &lt;typename ArgT&gt;void foo( ArgT&amp;&amp; a, typename std::enabled_if&lt; std::is_same&lt;std::decay_t&lt;ArgT&gt;, float&gt;::value &gt;::type* = nullptr);// Concepttemplate &lt;typename ArgT&gt; requires std::same_as&lt;std::remove_cvref&lt;T&gt;, float&gt; void foo(ArgT&amp;&amp; a) &#123;&#125; 可以看到，concept之后的表达式消除了语法噪音，显得更为简洁一些。而对于之前++的例子，concept下则更为扼要： 12345template &lt;typename T&gt; concept Incrementable = requires (T t) &#123; ++t; &#125;template &lt;Incrementable T&gt;void inc_counter(T&amp; intTypeCounter) &#123; ++intTypeCounter;&#125; 直接告诉编译器，我们对T的要求是你得有++。 当然有人会问，那能不能直接写成以下形式，不是更简单吗？ 12template &lt;typename T&gt; requires (T t) &#123; ++t; &#125;void inc_counter(T&amp; cnt); 答案是：不能。因为requires作为关键字&#x2F;保留字是存在二义性的。当它用于函数模板或者类模板的声明时，它是一个constraint，后面需要跟着concept表达式；而用于concept中，则是一个required expression，用于concept的求解。既然constraint后面跟着一个concept表达式，而requires也可以用来定义一个concept expression，那么一个风骚的想法形成了：我能不能用 requires (requires (T t) &#123;++t;&#125;) 来约束模板参数呢？ 当然是可以的！C++就是这么的简（有）单（病）！ 12template &lt;typename T&gt; requires (requires (T t) &#123; ++t; &#125;)void inc_counter(T&amp; cnt); 总而言之，除了这些烦人的问题，“概念”的出现，使得模板的出错提示也清爽了些许 —— 虽然大佬们都在鼓吹concept让模板出错多么好调试，但是实际上模板出错，有一半是来源自类型系统本质上的复杂性，概念并不能解决这一问题。 比如这里使用SFINAE的提示： 123456&lt;source&gt;:23:5: error: no matching function for call to &#x27;Inc&#x27; Inc(y); ^~~&lt;source&gt;:5:6: note: candidate template ignored: substitution failure [with T = X]: cannot increment value of type &#x27;X&#x27;void Inc(T&amp; v, std::decay_t&lt;decltype(++v)&gt;* = nullptr) ^ ~~ 而这里是使用了concept的提示。 1234567891011&lt;source&gt;:25:5: error: no matching function for call to &#x27;Inc_Concept&#x27; Inc_Concept(y); ^~~~~~~~~~~&lt;source&gt;:13:6: note: candidate template ignored: constraints not satisfied [with T = X]void Inc_Concept(T&amp; v) ^&lt;source&gt;:12:11: note: because &#x27;X&#x27; does not satisfy &#x27;Incrementable&#x27;template &lt;Incrementable T&gt; ^&lt;source&gt;:10:41: note: because &#x27;++t&#x27; would be invalid: cannot increment value of type &#x27;X&#x27;concept Incrementable = requires(T t) &#123; ++t; &#125;; 虽然在这个例子中，通过 Concept 获得出错提示看起来要比使用 SFINAE 所获得的错误描述要更长一点，但是对于更加复杂类型来说，则会友善许多。以后会找个例子给大家陈述。 4.3.2. “概念”入门","comments":true,"tags":[{"name":"c++ template","slug":"c-template","permalink":"https://kettycode.github.io/tags/c-template/"}]},{"title":"现代C++学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/现代C++/base2/","text":"语言可用性常量nullptrnullptr 出现的目的是为了替代 NULL。在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。 constexprC++ 本身已经具备了常量表达式的概念，比如 1+2, 3*4 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。 C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证该函数在编译期就应该是一个常量表达式。 此外，constexpr 修饰的函数可以使用递归。从 C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句， 变量及其初始化###if&#x2F;switch变量声明强化在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 for 语句内能够声明一个临时变量 int，但始终没有办法在 if 和 switch 语句中声明一个临时的变量。C++17 消除了这一限制，使得我们可以在 if（或 switch）中完成这一操作： 12345// 将临时变量放到 if 语句内if (const std::vector&lt;int&gt;::iterator itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) &#123; *itr = 4;&#125; 初始化列表在传统 C++ 中，不同的对象有着不同的初始化方法，例如普通数组、 POD （Plain Old Data，即没有构造、析构和虚函数的类或结构体） 类型都可以使用 {} 进行初始化，也就是我们所说的初始化列表。 而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 () 进行。 这些不同方法都针对各自对象，不能通用。 为解决这个问题，C++11 首先把初始化列表的概念绑定到类型上，称其为 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如： 1234567891011121314151617181920212223#include &lt;initializer_list&gt;#include &lt;vector&gt;#include &lt;iostream&gt;class MagicFoo &#123;public: std::vector&lt;int&gt; vec; MagicFoo(std::initializer_list&lt;int&gt; list) &#123; for (std::initializer_list&lt;int&gt;::iterator it = list.begin(); it != list.end(); ++it) vec.push_back(*it); &#125;&#125;;int main() &#123; // after C++11 MagicFoo magicFoo = &#123;1, 2, 3, 4, 5&#125;; MagicFoo magicFoo &#123;1, 2, 3, 4, 5&#125;; std::cout &lt;&lt; &quot;magicFoo: &quot;; for (std::vector&lt;int&gt;::iterator it = magicFoo.vec.begin(); it != magicFoo.vec.end(); ++it) std::cout &lt;&lt; *it &lt;&lt; std::endl;&#125; 这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。 初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如： 1234567public: void foo(std::initializer_list&lt;int&gt; list) &#123; for (std::initializer_list&lt;int&gt;::iterator it = list.begin(); it != list.end(); ++it) vec.push_back(*it); &#125;magicFoo.foo(&#123;6,7,8,9&#125;); 结构化绑定结构化绑定提供了类似其他语言中提供的多返回值的功能。在容器一章中，我们会学到 C++11 新增了 std::tuple 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C++11&#x2F;14 并没有提供一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 std::tie 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;tuple&gt;std::tuple&lt;bool, int,int&gt; GetUserAge(const std::string&amp; user_name)&#123; std::tuple&lt;bool, int,int&gt; result; if (user_name.compare(&quot;xiaoli&quot;) == 0) &#123; result = std::make_tuple(true, 18,0); &#125; else &#123; result = std::make_tuple(false, -1,-1); &#125; return result;&#125;int main()&#123; std::tuple&lt;bool, int,int&gt; result = GetUserAge(&quot;xiaolili&quot;); bool work_status; int age; int user_id; std::tie(work_status, age, user_id) = result; std::cout &lt;&lt; &quot;查询结果：&quot; &lt;&lt; work_status &lt;&lt; &quot; &quot; &lt;&lt; &quot;年龄：&quot; &lt;&lt; age &lt;&lt;&quot; &quot;&lt;&lt;&quot;用户id:&quot;&lt;&lt;user_id &lt;&lt;std::endl; getchar(); return 0;&#125; C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码： 123456789101112#include &lt;iostream&gt;#include &lt;tuple&gt;std::tuple&lt;int, double, std::string&gt; f() &#123; return std::make_tuple(1, 2.3, &quot;456&quot;);&#125;int main() &#123; auto [x, y, z] = f(); std::cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;, &quot; &lt;&lt; z &lt;&lt; std::endl; return 0;&#125; 类型推导C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。这使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。 auto使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。你应该在前面的小节里看到了传统 C++ 中冗长的迭代写法： 1234567// 在 C++11 之前// 由于 cbegin() 将返回 vector&lt;int&gt;::const_iterator// 所以 it 也应该是 vector&lt;int&gt;::const_iterator 类型for(vector&lt;int&gt;::const_iterator it = vec.cbegin(); it != vec.cend(); ++it)//C++11之后for (auto it = list.begin(); it != list.end(); ++it) 注意：auto 还不能用于推导数组类型： 1234auto auto_arr2[10] = &#123;arr&#125;; // 错误, 无法推导数组元素类型2.6.auto.cpp:30:19: error: &#x27;auto_arr2&#x27; declared as array of &#x27;auto&#x27; auto auto_arr2[10] = &#123;arr&#125;; decltypedecltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 typeof 很相似：decltype(表达式) 123456789auto x = 1;auto y = 2;decltype(x+y) z;if (std::is_same&lt;decltype(x), int&gt;::value) std::cout &lt;&lt; &quot;type x == int&quot; &lt;&lt; std::endl;if (std::is_same&lt;decltype(x), float&gt;::value) std::cout &lt;&lt; &quot;type x == float&quot; &lt;&lt; std::endl;if (std::is_same&lt;decltype(x), decltype(z)&gt;::value) std::cout &lt;&lt; &quot;type z == type x&quot; &lt;&lt; std::endl; 其中，std::is_same&lt;T, U&gt; 用于判断 T 和 U 这两个类型是否相等。输出结果为： 12type x == inttype z == type x 尾返回类型推导在传统 C++ 中我们必须这么写： 1234template&lt;typename R, typename T, typename U&gt;R add(T x, U y) &#123; return x+y;&#125; 这样的代码其实变得很丑陋，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 add() 这个函数会做什么样的操作，以及获得一个什么样的返回类型。 1decltype(x+y) add(T x, U y) 但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做尾返回类型（trailing return type），利用 auto 关键字将返回类型后置： 1234template&lt;typename T, typename U&gt;auto add2(T x, U y) -&gt; decltype(x+y)&#123; return x + y;&#125; 从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法： 1234template&lt;typename T, typename U&gt;auto add3(T x, U y)&#123; return x + y;&#125; decltype(auto)decltype(auto) 是 C++14 开始提供的一个略微复杂的用法。简单来说，decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 decltype 的参数表达式。考虑看下面的例子，当我们需要对下面两个函数进行封装时： 12345678910111213141516std::string lookup1();std::string&amp; lookup2();//封装实现std::string look_up_a_string_1() &#123; return lookup1();&#125;std::string&amp; look_up_a_string_2() &#123; return lookup2();&#125;//C++14以后decltype(auto) look_up_a_string_1() &#123; return lookup1();&#125;decltype(auto) look_up_a_string_2() &#123; return lookup2();&#125; 控制流if constexpr我们知道了 C++11 引入了 constexpr 关键字，它将表达式或函数编译为常量结果。一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断，岂不是能让程序效率更高？C++17 将 constexpr 这个关键字引入到 if 语句中，允许在代码中声明常量表达式的判断条件，考虑下面的代码： 1234567891011121314#include &lt;iostream&gt;template&lt;typename T&gt;auto print_type_info(const T&amp; t) &#123; if constexpr (std::is_integral&lt;T&gt;::value) &#123; return t + 1; &#125; else &#123; return t + 0.001; &#125;&#125;int main() &#123; std::cout &lt;&lt; print_type_info(5) &lt;&lt; std::endl; std::cout &lt;&lt; print_type_info(3.14) &lt;&lt; std::endl;&#125; 在编译时，实际代码就会表现为如下： 12345678910int print_type_info(const int&amp; t) &#123; return t + 1;&#125;double print_type_info(const double&amp; t) &#123; return t + 0.001;&#125;int main() &#123; std::cout &lt;&lt; print_type_info(5) &lt;&lt; std::endl; std::cout &lt;&lt; print_type_info(3.14) &lt;&lt; std::endl;&#125; 区间for迭代终于，C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句，我们可以进一步简化前面的例子： 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4&#125;; if (auto itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) *itr = 4; for (auto element : vec) std::cout &lt;&lt; element &lt;&lt; std::endl; // read only for (auto &amp;element : vec) &#123; element += 1; // writeable &#125; for (auto element : vec) std::cout &lt;&lt; element &lt;&lt; std::endl; // read only&#125;","comments":true,"tags":[{"name":"modern c++","slug":"modern-c","permalink":"https://kettycode.github.io/tags/modern-c/"}]},{"title":"现代C++学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/现代C++/base4/","text":"语言运行期的强化1.Lambda表达式基本语法捕获列表 mutable(可选) 异常属性 -&gt; 返回类型 {&#x2F;&#x2F; 函数体} 捕获捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：[] 空捕获列表[name1, name2, …] 捕获一系列变量[&amp;] 引用捕获, 让编译器自行推导引用列表[&#x3D;] 值捕获, 让编译器自行推导值捕获列表 表达式捕获上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。 C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的： 1234567891011#include &lt;iostream&gt;#include &lt;memory&gt; // std::make_unique#include &lt;utility&gt; // std::movevoid lambda_expression_capture() &#123; auto important = std::make_unique&lt;int&gt;(1); auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -&gt; int &#123; return x+y+v1+(*v2); &#125;; std::cout &lt;&lt; add(3,4) &lt;&lt; std::endl;&#125; 在上面的代码中，important 是一个独占指针，是不能够被 “&#x3D;” 值捕获到，这时候我们可以将其转移为右值，在表达式中初始化。 泛型Lambda123456auto add = [](auto x, auto y) &#123; return x+y;&#125;;add(1, 2);add(1.1, 2.2); 2.函数对象包装器std::functionLambda 表达式的本质是一个和函数对象类型相似的类类型（称为闭包类型）的对象（称为闭包对象）， 当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如： 123456789101112131415#include &lt;iostream&gt;using foo = void(int); // 定义函数类型, using 的使用见上一节中的别名语法void functional(foo f) &#123; // 参数列表中定义的函数类型 foo 被视为退化后的函数指针类型 foo* f(1); // 通过函数指针调用函数&#125;int main() &#123; auto f = [](int value) &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; &#125;; functional(f); // 传递闭包对象，隐式转换为 foo* 类型的函数指针值 f(1); // lambda 表达式调用 return 0;&#125; 上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用， 而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型， 统一称之为可调用类型。而这种类型，便是通过 std::function 引入的。 C++11 std::function 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作， 它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）， 换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。 例如： 123456789101112131415161718#include &lt;functional&gt;#include &lt;iostream&gt;int foo(int para) &#123; return para;&#125;int main() &#123; // std::function 包装了一个返回值为 int, 参数为 int 的函数 std::function&lt;int(int)&gt; func = foo; int important = 10; std::function&lt;int(int)&gt; func2 = [&amp;](int value) -&gt; int &#123; return 1+value+important; &#125;; std::cout &lt;&lt; func(10) &lt;&lt; std::endl; std::cout &lt;&lt; func2(10) &lt;&lt; std::endl;&#125; std::bind 和 std::placeholderstd::bind 则是用来绑定函数调用的参数的， 它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。 例如： 12345678910int foo(int a, int b, int c) &#123; ;&#125;int main() &#123; // 将参数1,2绑定到函数 foo 上， // 但使用 std::placeholders::_1 来对第一个参数进行占位 auto bindFoo = std::bind(foo, std::placeholders::_1, 1,2); // 这时调用 bindFoo 时，只需要提供第一个参数即可 bindFoo(1);&#125; 3.右值引用左值、右值、将亡值、纯右值左值 (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。右值 (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。 而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。 纯右值 (prvalue, pure rvalue)，纯粹的右值，要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值。需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组 将亡值 (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中， 纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。 右值引用和左值引用要拿到一个将亡值，就需要用到右值引用：T &amp;&amp;，其中 T 是类型。 右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。 C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值， 有了它我们就能够方便的获得一个右值临时对象，例如： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;void reference(std::string&amp; str) &#123; std::cout &lt;&lt; &quot;左值&quot; &lt;&lt; std::endl;&#125;void reference(std::string&amp;&amp; str) &#123; std::cout &lt;&lt; &quot;右值&quot; &lt;&lt; std::endl;&#125;int main()&#123; std::string lv1 = &quot;string,&quot;; // lv1 是一个左值 // std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值 std::string&amp;&amp; rv1 = std::move(lv1); // 合法, std::move可以将左值转移为右值 std::cout &lt;&lt; rv1 &lt;&lt; std::endl; // string, const std::string&amp; lv2 = lv1 + lv1; // 合法, 常量左值引用能够延长临时变量的生命周期 // lv2 += &quot;Test&quot;; // 非法, 常量引用无法被修改 std::cout &lt;&lt; lv2 &lt;&lt; std::endl; // string,string, std::string&amp;&amp; rv2 = lv1 + lv2; // 合法, 右值引用延长临时对象生命周期 rv2 += &quot;Test&quot;; // 合法, 非常量引用能够修改临时变量 std::cout &lt;&lt; rv2 &lt;&lt; std::endl; // string,string,string,Test reference(rv2); // 输出左值 return 0;&#125; rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值。 移动语义传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝&#x2F;复制的概念，但为了实现对资源的移动操作， 调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。 试想，搬家的时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份（重买）再放到新家、 再把原来的东西全部扔掉（销毁），这是非常反人类的一件事情。 传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据拷贝，浪费时间和空间。 右值引用的出现恰好就解决了这两个概念的混淆问题，例如： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;class A &#123;public: int *pointer; A():pointer(new int(1)) &#123; std::cout &lt;&lt; &quot;构造&quot; &lt;&lt; pointer &lt;&lt; std::endl; &#125; A(A&amp; a):pointer(new int(*a.pointer)) &#123; std::cout &lt;&lt; &quot;拷贝&quot; &lt;&lt; pointer &lt;&lt; std::endl; &#125; // 无意义的对象拷贝 A(A&amp;&amp; a):pointer(a.pointer) &#123; a.pointer = nullptr; std::cout &lt;&lt; &quot;移动&quot; &lt;&lt; pointer &lt;&lt; std::endl; &#125; ~A()&#123; std::cout &lt;&lt; &quot;析构&quot; &lt;&lt; pointer &lt;&lt; std::endl; delete pointer; &#125;&#125;;// 防止编译器优化A return_rvalue(bool test) &#123; A a,b; if(test) return a; // 等价于 static_cast&lt;A&amp;&amp;&gt;(a); else return b; // 等价于 static_cast&lt;A&amp;&amp;&gt;(b);&#125;int main() &#123; A obj = return_rvalue(false); std::cout &lt;&lt; &quot;obj:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; obj.pointer &lt;&lt; std::endl; std::cout &lt;&lt; *obj.pointer &lt;&lt; std::endl; return 0;&#125; 在上面的代码中： 首先会在 return_rvalue 内部构造两个 A 对象，于是获得两个构造函数的输出；函数返回后，产生一个将亡值，被 A 的移动构造（A(A&amp;&amp;)）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 obj 中，而将亡值的指针被设置为 nullptr，防止了这块内存区域被销毁。从而避免了无意义的拷贝构造，加强了性能。再来看看涉及标准库的例子: 123456789101112131415161718192021222324#include &lt;iostream&gt; // std::cout#include &lt;utility&gt; // std::move#include &lt;vector&gt; // std::vector#include &lt;string&gt; // std::stringint main() &#123; std::string str = &quot;Hello world.&quot;; std::vector&lt;std::string&gt; v; // 将使用 push_back(const T&amp;), 即产生拷贝行为 v.push_back(str); // 将输出 &quot;str: Hello world.&quot; std::cout &lt;&lt; &quot;str: &quot; &lt;&lt; str &lt;&lt; std::endl; // 将使用 push_back(const T&amp;&amp;), 不会出现拷贝行为 // 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销 // 这步操作后, str 中的值会变为空 v.push_back(std::move(str)); // 将输出 &quot;str: &quot; std::cout &lt;&lt; &quot;str: &quot; &lt;&lt; str &lt;&lt; std::endl; return 0;&#125; 完美转发一个声明的右值引用其实是一个左值。这就为我们进行参数转发（传递）造成了问题： 123456789101112131415161718192021void reference(int&amp; v) &#123; std::cout &lt;&lt; &quot;左值&quot; &lt;&lt; std::endl;&#125;void reference(int&amp;&amp; v) &#123; std::cout &lt;&lt; &quot;右值&quot; &lt;&lt; std::endl;&#125;template &lt;typename T&gt;void pass(T&amp;&amp; v) &#123; std::cout &lt;&lt; &quot;普通传参:&quot;; reference(v); // 始终调用 reference(int&amp;)&#125;int main() &#123; std::cout &lt;&lt; &quot;传递右值:&quot; &lt;&lt; std::endl; pass(1); // 1是右值, 但输出是左值 std::cout &lt;&lt; &quot;传递左值:&quot; &lt;&lt; std::endl; int l = 1; pass(l); // l 是左值, 输出左值 return 0;&#125; 对于 pass(1) 来说，虽然传递的是右值，但由于 v 是一个引用，所以同时也是左值。 因此 reference(v) 会调用 reference(int&amp;)，输出『左值』。 引用坍缩规则：在传统 C++ 中，我们不能够对一个引用类型继续进行引用， 但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用， 既能左引用，又能右引用。但是却遵循如下规则： 函数形参类型 实参参数类型 推导后函数形参类型 T&amp; 左引用 T&amp; T&amp; 右引用 T&amp; T&amp;&amp; 左引用 T&amp; T&amp;&amp; 右引用 T&amp;&amp; 只有函数形参为右引用，实参也为右引用时才能被推导成右引用类型 完美转发就是基于上述规律产生的。所谓完美转发，就是为了让我们在传递参数的时候， 保持原来的参数类型（左引用保持左引用，右引用保持右引用）。 为了解决这个问题，我们应该使用 std::forward 来进行参数的转发（传递） std::forward 和 std::move 一样，没有做任何事情，std::move 单纯的将左值转化为右值， std::forward 也只是单纯的将参数做了一个类型的转换，从现象上来看， std::forward(v) 和 static_cast&lt;T&amp;&amp;&gt;(v) 是完全一样的。 因此：在使用循环语句的过程中，auto&amp;&amp; 是最安全的方式","comments":true,"tags":[{"name":"modern c++","slug":"modern-c","permalink":"https://kettycode.github.io/tags/modern-c/"}]},{"title":"现代C++学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/现代C++/base3/","text":"继续学习现代C++模板C++ 的模板一直是这门语言的一种特殊的艺术，模板甚至可以独立作为一门新的语言来进行使用。模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。 外部模板传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板的实例化。为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化： 12template class std::vector&lt;bool&gt;; // 强行实例化extern template class std::vector&lt;double&gt;; // 不在该当前编译文件中实例化模板 “&gt;”在传统 C++ 的编译器中，&gt;&gt;一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码： 1std::vector&lt;std::vector&lt;int&gt;&gt; matrix; 这在传统 C++ 编译器下是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译 类型别名模板在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效： 12345678typedef int (*process)(void *);using NewProcess = int(*)(void *);template&lt;typename T&gt;using TrueDarkMagic = MagicType&lt;std::vector&lt;T&gt;, std::string&gt;;int main() &#123; TrueDarkMagic&lt;bool&gt; you;&#125; 变长参数模板模板一直是 C++ 所独有的黑魔法（一起念：Dark Magic）之一。 在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子， 接受一组固定数量的模板参数；而 C++11 加入了新的表示方法， 允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。 1234567template&lt;typename... Ts&gt; class Magic;class Magic&lt;int, std::vector&lt;int&gt;, std::map&lt;std::string, std::vector&lt;int&gt;&gt;&gt; darkMagic;class Magic&lt;&gt; nothing;template&lt;typename Require, typename... Args&gt; class Magic; 除了在模板参数中能使用 … 表示不定长模板参数外， 函数参数也使用同样的表示法代表不定长参数， 这也就为我们简单编写变长参数函数提供了便捷的手段，例如： 123456template&lt;typename... Args&gt; void printf(const std::string &amp;str, Args... args);template&lt;typename... Ts&gt;void magic(Ts... args) &#123; std::cout &lt;&lt; sizeof...(args) &lt;&lt; std::endl;&#125; 其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法： 12345678910111213141516171819202122232425262728293031//递归#include &lt;iostream&gt;template&lt;typename T0&gt;void printf1(T0 value) &#123; std::cout &lt;&lt; value &lt;&lt; std::endl;&#125;template&lt;typename T, typename... Ts&gt;void printf1(T value, Ts... args) &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; printf1(args...);&#125;int main() &#123; printf1(1, 2, &quot;123&quot;, 1.1); return 0;&#125;//变参模板展开template&lt;typename T0, typename... T&gt;void printf2(T0 t0, T... t) &#123; std::cout &lt;&lt; t0 &lt;&lt; std::endl; if constexpr (sizeof...(t) &gt; 0) printf2(t...);&#125;//初始化列表展开template&lt;typename T, typename... Ts&gt;auto printf3(T value, Ts... args) &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; (void) std::initializer_list&lt;T&gt;&#123;([&amp;args] &#123; std::cout &lt;&lt; args &lt;&lt; std::endl; &#125;(), value)...&#125;;&#125; 折叠表达式12345678#include &lt;iostream&gt;template&lt;typename ... T&gt;auto sum(T ... t) &#123; return (t + ...);&#125;int main() &#123; std::cout &lt;&lt; sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) &lt;&lt; std::endl;&#125; 非类型模板参数推导12345678910template &lt;typename T, int BufSize&gt;class buffer_t &#123;public: T&amp; alloc(); void free(T&amp; item);private: T data[BufSize];&#125;buffer_t&lt;int, 100&gt; buf; // 100 作为模板参数 C++17 引入了这一特性，我们的确可以 auto 关键字，让编译器辅助完成具体类型的推导， 例如： 12345678template &lt;auto value&gt; void foo() &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; return;&#125;int main() &#123; foo&lt;10&gt;(); // value 被推导为 int 类型&#125; 面向对象委托构造C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的： 123456789101112131415161718#include &lt;iostream&gt;class Base &#123;public: int value1; int value2; Base() &#123; value1 = 1; &#125; Base(int value) : Base() &#123; // 委托 Base() 构造函数 value2 = value; &#125;&#125;;int main() &#123; Base b(2); std::cout &lt;&lt; b.value1 &lt;&lt; std::endl; std::cout &lt;&lt; b.value2 &lt;&lt; std::endl;&#125; 继承构造在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 using 引入了继承构造函数的概念： 123456789101112131415161718192021#include &lt;iostream&gt;class Base &#123;public: int value1; int value2; Base() &#123; value1 = 1; &#125; Base(int value) : Base() &#123; // 委托 Base() 构造函数 value2 = value; &#125;&#125;;class Subclass : public Base &#123;public: using Base::Base; // 继承构造&#125;;int main() &#123; Subclass s(3); std::cout &lt;&lt; s.value1 &lt;&lt; std::endl; std::cout &lt;&lt; s.value2 &lt;&lt; std::endl;&#125; 显式虚函数重载123456struct Base &#123; virtual void foo();&#125;;struct SubClass: Base &#123; void foo();&#125;; SubClass::foo 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果。C++11 引入了 override 和 final 这两个关键字来防止上述情形的发生。 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的其函数签名一致的虚函数，否则将无法通过编译: 1234567struct Base &#123; virtual void foo(int);&#125;;struct SubClass: Base &#123; virtual void foo(int) override; // 合法 virtual void foo(float) override; // 非法, 父类没有此虚函数&#125;; final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。 123456789101112struct Base &#123; virtual void foo() final;&#125;;struct SubClass1 final: Base &#123;&#125;; // 合法struct SubClass2 : SubClass1 &#123;&#125;; // 非法, SubClass1 已 finalstruct SubClass3: Base &#123; void foo(); // 非法, foo 已 final&#125;; 显式禁用默认函数在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、 复制构造、赋值算符以及析构函数。 另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。 当程序员有需要时，可以重载这部分函数。这就引发了一些需求：无法精确控制默认函数的生成行为。 例如禁止类的拷贝时，必须将复制构造函数与赋值算符声明为 private。 尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。并且，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。 若用户定义了任何构造函数，编译器将不再生成默认构造函数， 但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬。C++11允许显式的声明采用或拒绝编译器自带的函数。 例如： 123456class Magic &#123; public: Magic() = default; // 显式声明使用编译器生成的构造 Magic&amp; operator=(const Magic&amp;) = delete; // 显式声明拒绝编译器生成构造 Magic(int magic_number);&#125; 强类型枚举在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同，这通常不是我们希望看到的结果。C++11 引入了枚举类（enumeration class），并使用 enum class 的语法进行声明： 123456enum class new_enum : unsigned int &#123; value1, value2, value3 = 100, value4 = 100&#125;; 而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 &lt;&lt; 这个算符来进行输出. 12345678910#include &lt;iostream&gt;template&lt;typename T&gt;std::ostream&amp; operator&lt;&lt;( typename std::enable_if&lt;std::is_enum&lt;T&gt;::value, std::ostream&gt;::type&amp; stream, const T&amp; e)&#123; return stream &lt;&lt; static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(e);&#125;std::cout &lt;&lt; new_enum::value3 &lt;&lt; std::endl","comments":true,"tags":[{"name":"modern c++","slug":"modern-c","permalink":"https://kettycode.github.io/tags/modern-c/"}]},{"title":"现代C++学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/现代C++/base5/","text":"容器1.线性容器std::array1.为什么要引入 std::array 而不是直接使用 std::vector？与 std::vector 不同，std::array 对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用 std::array 容器。 另外由于 std::vector 是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作， 容器并不会自动归还被删除元素相应的内存，这时候就需要手动运行 shrink_to_fit() 释放这部分内存。 2.已经有了传统数组，为什么要用 std::array?使用 std::array 能够让代码变得更加“现代化”，而且封装了一些操作函数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 std::sort。 12345678910111213// 非法,不同于 C 风格数组，std::array 不会自动退化成 T*// int *arr_p = arr;void foo(int *p, int len) &#123; return;&#125;std::array&lt;int, 4&gt; arr = &#123;1,2,3,4&#125;;// C 风格接口传参// foo(arr, arr.size()); // 非法, 无法隐式转换foo(&amp;arr[0], arr.size());foo(arr.data(), arr.size()); std::forward_liststd::forward_list 是一个列表容器，使用方法和 std::list 基本类似，因此我们就不花费篇幅进行介绍了。 需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现， 提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点）， 也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。 无序容器我们已经熟知了传统 C++ 中的有序容器 std::map&#x2F;std::set，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 &lt; 操作符比较元素大小并判断元素是否相同， 并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 &lt; 操作符的顺序来逐个遍历。 无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)， 在不关心容器内部元素顺序时，能够获得显著的性能提升。 C++11 引入了的两组无序容器分别是：std::unordered_map&#x2F;std::unordered_multimap 和 std::unordered_set&#x2F;std::unordered_multiset。 它们的用法和原有的 std::map&#x2F;std::multimap&#x2F;std::set&#x2F;set::multiset 基本类似 元组纵观传统 C++ 中的容器，除了 std::pair 外， 似乎没有现成的结构能够用来存放不同类型的数据（通常我们会自己定义结构）。 但 std::pair 的缺陷是显而易见的，只能保存两个元素。 元组基本操作关于元组的使用有三个核心的函数：std::make_tuple: 构造元组std::get: 获得元组某个位置的值std::tie: 元组拆包 123456789101112131415161718192021222324252627282930313233343536#include &lt;tuple&gt;#include &lt;iostream&gt;auto get_student(int id)&#123; // 返回类型被推断为 std::tuple&lt;double, char, std::string&gt; if (id == 0) return std::make_tuple(3.8, &#x27;A&#x27;, &quot;张三&quot;); if (id == 1) return std::make_tuple(2.9, &#x27;C&#x27;, &quot;李四&quot;); if (id == 2) return std::make_tuple(1.7, &#x27;D&#x27;, &quot;王五&quot;); return std::make_tuple(0.0, &#x27;D&#x27;, &quot;null&quot;); // 如果只写 0 会出现推断错误, 编译失败&#125;int main()&#123; auto student = get_student(0); std::cout &lt;&lt; &quot;ID: 0, &quot; &lt;&lt; &quot;GPA: &quot; &lt;&lt; std::get&lt;0&gt;(student) &lt;&lt; &quot;, &quot; &lt;&lt; &quot;成绩: &quot; &lt;&lt; std::get&lt;1&gt;(student) &lt;&lt; &quot;, &quot; &lt;&lt; &quot;姓名: &quot; &lt;&lt; std::get&lt;2&gt;(student) &lt;&lt; &#x27;\\n&#x27;; double gpa; char grade; std::string name; // 元组进行拆包 std::tie(gpa, grade, name) = get_student(1); std::cout &lt;&lt; &quot;ID: 1, &quot; &lt;&lt; &quot;GPA: &quot; &lt;&lt; gpa &lt;&lt; &quot;, &quot; &lt;&lt; &quot;成绩: &quot; &lt;&lt; grade &lt;&lt; &quot;, &quot; &lt;&lt; &quot;姓名: &quot; &lt;&lt; name &lt;&lt; &#x27;\\n&#x27;;&#125; std::get 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象： 1234std::tuple&lt;std::string, double, double, int&gt; t(&quot;123&quot;, 4.5, 6.7, 8);std::cout &lt;&lt; std::get&lt;std::string&gt;(t) &lt;&lt; std::endl;std::cout &lt;&lt; std::get&lt;double&gt;(t) &lt;&lt; std::endl; // 非法, 引发编译期错误std::cout &lt;&lt; std::get&lt;3&gt;(t) &lt;&lt; std::endl; 运行期索引std::get&lt;&gt; 依赖一个编译期的常量，所以下面的方式是不合法的： 12int index = 1;std::get&lt;index&gt;(t); 使用 std::variant&lt;&gt;（C++ 17 引入），提供给 variant&lt;&gt; 的类型模板参数 可以让一个 variant&lt;&gt; 从而容纳提供的几种类型的变量（在其他语言，例如 Python&#x2F;JavaScript 等，表现为动态类型）： 123456789101112131415161718#include &lt;variant&gt;template &lt;size_t n, typename... T&gt;constexpr std::variant&lt;T...&gt; _tuple_index(const std::tuple&lt;T...&gt;&amp; tpl, size_t i) &#123; if constexpr (n &gt;= sizeof...(T)) throw std::out_of_range(&quot;越界.&quot;); if (i == n) return std::variant&lt;T...&gt;&#123; std::in_place_index&lt;n&gt;, std::get&lt;n&gt;(tpl) &#125;; return _tuple_index&lt;(n &lt; sizeof...(T)-1 ? n+1 : 0)&gt;(tpl, i);&#125;template &lt;typename... T&gt;constexpr std::variant&lt;T...&gt; tuple_index(const std::tuple&lt;T...&gt;&amp; tpl, size_t i) &#123; return _tuple_index&lt;0&gt;(tpl, i);&#125;template &lt;typename T0, typename ... Ts&gt;std::ostream &amp; operator&lt;&lt; (std::ostream &amp; s, std::variant&lt;T0, Ts...&gt; const &amp; v) &#123; std::visit([&amp;](auto &amp;&amp; x)&#123; s &lt;&lt; x;&#125;, v); return s;&#125; 123int i = 1;std::cout &lt;&lt; tuple_index(t, i) &lt;&lt; std::endl;//tuple_index(t,i) -&gt; tuple_index(t,1) -&gt; tuple_index&lt;0&gt;(t,1) -&gt; tuple_index&lt;1&gt;(t,1) -&gt; &#123;std::in_place_index&lt;1&gt;,std::get&lt;1&gt;(t)&#125; 元组合并和遍历合并两个元组，这可以通过 std::tuple_cat 来实现： 1auto new_tuple = std::tuple_cat(get_student(1), std::move(t)); 遍历一个元组 12345678template &lt;typename T&gt;auto tuple_len(T &amp;tpl) &#123; return std::tuple_size&lt;T&gt;::value;&#125;// 迭代for(int i = 0; i != tuple_len(new_tuple); ++i) // 运行期索引 std::cout &lt;&lt; tuple_index(new_tuple, i) &lt;&lt; std::endl;","comments":true,"tags":[{"name":"modern c++","slug":"modern-c","permalink":"https://kettycode.github.io/tags/modern-c/"}]},{"title":"现代C++学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/现代C++/base6/","text":"智能指针与内存管理1.RAII与引用计数引用计数这种计数是为了防止内存泄露而产生的。 基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。 所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间， 也就是我们常说的 RAII 资源获取即初始化技术。 在传统 C++ 里我们只好使用 new 和 delete 去 『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。 这些智能指针包括 std::shared_ptr&#x2F;std::unique_ptr&#x2F;std::weak_ptr，使用它们需要包含头文件 。 std::shared_ptrstd::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当引用计数变为零的时候就会将对象自动删除。 但还不够，因为使用 std::shared_ptr 仍然需要使用 new 来调用，这使得代码出现了某种程度上的不对称。 std::make_shared 就能够用来消除显式的使用 new，所以std::make_shared 会分配创建传入参数中的对象， 并返回这个对象类型的std::shared_ptr指针 1234567891011121314#include &lt;iostream&gt;#include &lt;memory&gt;void foo(std::shared_ptr&lt;int&gt; i) &#123; (*i)++;&#125;int main() &#123; // auto pointer = new int(10); // illegal, no direct assignment // Constructed a std::shared_ptr auto pointer = std::make_shared&lt;int&gt;(10); foo(pointer); std::cout &lt;&lt; *pointer &lt;&lt; std::endl; // 11 // The shared_ptr will be destructed before leaving the scope return 0;&#125; std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数， 并通过use_count()来查看一个对象的引用计数。 1234567891011121314151617181920auto pointer = std::make_shared&lt;int&gt;(10);auto pointer2 = pointer; // 引用计数+1auto pointer3 = pointer; // 引用计数+1int *p = pointer.get(); // 这样不会增加引用计数std::cout &lt;&lt; &quot;pointer.use_count() = &quot; &lt;&lt; pointer.use_count() &lt;&lt; std::endl; // 3std::cout &lt;&lt; &quot;pointer2.use_count() = &quot; &lt;&lt; pointer2.use_count() &lt;&lt; std::endl; // 3std::cout &lt;&lt; &quot;pointer3.use_count() = &quot; &lt;&lt; pointer3.use_count() &lt;&lt; std::endl; // 3pointer2.reset();std::cout &lt;&lt; &quot;reset pointer2:&quot; &lt;&lt; std::endl;std::cout &lt;&lt; &quot;pointer.use_count() = &quot; &lt;&lt; pointer.use_count() &lt;&lt; std::endl; // 2std::cout &lt;&lt; &quot;pointer2.use_count() = &quot; &lt;&lt; pointer2.use_count() &lt;&lt; std::endl; // pointer2 已 reset; 0std::cout &lt;&lt; &quot;pointer3.use_count() = &quot; &lt;&lt; pointer3.use_count() &lt;&lt; std::endl; // 2pointer3.reset();std::cout &lt;&lt; &quot;reset pointer3:&quot; &lt;&lt; std::endl;std::cout &lt;&lt; &quot;pointer.use_count() = &quot; &lt;&lt; pointer.use_count() &lt;&lt; std::endl; // 1std::cout &lt;&lt; &quot;pointer2.use_count() = &quot; &lt;&lt; pointer2.use_count() &lt;&lt; std::endl; // 0std::cout &lt;&lt; &quot;pointer3.use_count() = &quot; &lt;&lt; pointer3.use_count() &lt;&lt; std::endl; // pointer3 已 reset; 0 std::unique_ptrstd::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全： 12std::unique_ptr&lt;int&gt; pointer = std::make_unique&lt;int&gt;(10); // make_unique 从 C++14 引入std::unique_ptr&lt;int&gt; pointer2 = pointer; // 非法 既然是独占，换句话说就是不可复制。但是，我们可以利用 std::move 将其转移给其他的 unique_ptr 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;memory&gt;struct Foo &#123; Foo() &#123; std::cout &lt;&lt; &quot;Foo::Foo&quot; &lt;&lt; std::endl; &#125; ~Foo() &#123; std::cout &lt;&lt; &quot;Foo::~Foo&quot; &lt;&lt; std::endl; &#125; void foo() &#123; std::cout &lt;&lt; &quot;Foo::foo&quot; &lt;&lt; std::endl; &#125;&#125;;void f(const Foo &amp;) &#123; std::cout &lt;&lt; &quot;f(const Foo&amp;)&quot; &lt;&lt; std::endl;&#125;int main() &#123; std::unique_ptr&lt;Foo&gt; p1(std::make_unique&lt;Foo&gt;()); // p1 不空, 输出 if (p1) p1-&gt;foo(); &#123; std::unique_ptr&lt;Foo&gt; p2(std::move(p1)); // p2 不空, 输出 f(*p2); // p2 不空, 输出 if(p2) p2-&gt;foo(); // p1 为空, 无输出 if(p1) p1-&gt;foo(); p1 = std::move(p2); // p2 为空, 无输出 if(p2) p2-&gt;foo(); std::cout &lt;&lt; &quot;p2 被销毁&quot; &lt;&lt; std::endl; &#125; // p1 不空, 输出 if (p1) p1-&gt;foo(); // Foo 的实例会在离开作用域时被销毁&#125; std::weak_ptrstd::weak_ptr 是一种智能指针，通常不单独使用，只能和 shared_ptr 类型指针搭配使用，可以视为 shared_ptr 指针的一种辅助工具。借助 weak_ptr 类型指针可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、通过expired()判断shared_ptr 指针指向的堆内存是否已经被释放等等，还可以解决shared_ptr 循环引用的问题。 weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()&#x3D;&#x3D;0，但更快。表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;memory&gt; int main() &#123; &#123; std::shared_ptr&lt;int&gt; sh_ptr = std::make_shared&lt;int&gt;(10); std::cout &lt;&lt; sh_ptr.use_count() &lt;&lt; std::endl; // 输出1 std::weak_ptr&lt;int&gt; wp(sh_ptr); std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl; // 赋值给weak_ptr后还是输出1 if(!wp.expired())&#123; // 检查sh_ptr是否还有效 std::shared_ptr&lt;int&gt; sh_ptr2 = wp.lock(); //将sh_ptr赋值给sh_ptr2 *sh_ptr = 100; std::cout &lt;&lt; wp.use_count() &lt;&lt; std::endl; // 输出2 &#125; &#125; //delete memory std::weak_ptr&lt;int&gt; wp; &#123; std::shared_ptr&lt;int&gt; sh_ptr = std::make_shared&lt;int&gt;(10); wp = sh_ptr; std::cout &lt;&lt; std::boolalpha &lt;&lt; wp.expired() &lt;&lt; std::endl; // 输出false，引用对象还没删除 &#125; //delete memory std::cout &lt;&lt; std::boolalpha &lt;&lt; wp.expired() &lt;&lt; std::endl; // 输出true，引用对象已经删除 return 0;&#125; weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()&#x3D;&#x3D;true的时候，lock()函数将返回一个存储空指针的shared_ptr。 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;memory&gt; int main(int argc, const char* argv[]) &#123; std::shared_ptr&lt;int&gt; sp(new int(10)); std::weak_ptr&lt;int&gt; wp(sp); //sp.reset(); if (std::shared_ptr&lt;int&gt; pa = wp.lock()) &#123; std::cout &lt;&lt; *pa &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;wp指向对象为空&quot; &lt;&lt; std::endl; &#125; sp.reset(); if (std::shared_ptr&lt;int&gt; pa = wp.lock()) &#123; std::cout &lt;&lt; *pa &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;wp指向对象为空&quot; &lt;&lt; std::endl; &#125; return 0;&#125; weak_ptr的一个作用是解决share_ptr的循环引用问题。如下面代码所示，class AA中含有指向class BB的shared指针, class BB 中含有指向class AA的shared指针，这样形成了循环引用。m_bb_ptr和m_aa_ptr的强引用计数永远大于等于1，所以直到程序退出前都不会被退出，这种情况有时候在正常的业务逻辑中是不可避免的，而解决循环引用的方法是改用weak_ptr： 12345678910111213141516171819202122232425262728293031class BB; class AA&#123;public: AA() &#123; cout &lt;&lt; &quot;AA::AA() called&quot; &lt;&lt; endl; &#125; ~AA() &#123; cout &lt;&lt; &quot;AA::~AA() called&quot; &lt;&lt; endl; &#125; shared_ptr&lt;BB&gt; m_bb_ptr;&#125;; class BB&#123; public: BB() &#123; cout &lt;&lt; &quot;BB::BB() called&quot; &lt;&lt; endl; &#125; ~BB() &#123; cout &lt;&lt; &quot;BB::~BB() called&quot; &lt;&lt; endl; &#125; shared_ptr&lt;AA&gt; m_aa_ptr;&#125;; int main()&#123; shared_ptr&lt;AA&gt; ptr_a(new AA); shared_ptr&lt;BB&gt; ptr_b(new BB); cout &lt;&lt; &quot;ptr_a use_count: &quot; &lt;&lt; ptr_a.use_count() &lt;&lt; endl; cout &lt;&lt; &quot;ptr_b use_count: &quot; &lt;&lt; ptr_b.use_count() &lt;&lt; endl; //下面两句导致了AA与BB的循环引用，结果就是AA和BB对象都不会析构 ptr_a-&gt;m_bb_ptr = ptr_b; ptr_b-&gt;m_aa_ptr = ptr_a; cout &lt;&lt; &quot;ptr_a use_count: &quot; &lt;&lt; ptr_a.use_count() &lt;&lt; endl; cout &lt;&lt; &quot;ptr_b use_count: &quot; &lt;&lt; ptr_b.use_count() &lt;&lt; endl; return 0;&#125; 可以看到由于AA和BB内部的shared_ptr各自保存了对方的一次引用，所以导致了ptr_a和ptr_b销毁的时候都认为内部保存的指针计数没有变成0，所以AA和BB的析构函数不会被调用。解决方法就是把一个shared_ptr替换成weak_ptr。 12345678910111213141516class BB;class AA&#123;public: AA() &#123; cout &lt;&lt; &quot;AA::AA() called&quot; &lt;&lt; endl; &#125; ~AA() &#123; cout &lt;&lt; &quot;AA::~AA() called&quot; &lt;&lt; endl; &#125; weak_ptr&lt;BB&gt; m_bb_ptr; //!&#125;; class BB&#123;public: BB() &#123; cout &lt;&lt; &quot;BB::BB() called&quot; &lt;&lt; endl; &#125; ~BB() &#123; cout &lt;&lt; &quot;BB::~BB() called&quot; &lt;&lt; endl; &#125; shared_ptr&lt;AA&gt; m_aa_ptr; //!&#125;; 总结：1.weak_ptr虽然是一个模板类，但是不能用来直接定义指向原始指针的对象。2.weak_ptr接受shared_ptr类型的变量赋值，但是反过来是行不通的，需要使用lock函数。3.weak_ptr设计之初就是为了服务于shared_ptr的，所以不增加引用计数就是它的核心功能。4.由于不知道什么之后weak_ptr所指向的对象就会被析构掉，所以使用之前请先使用expired函数检测一下。","comments":true,"tags":[{"name":"modern c++","slug":"modern-c","permalink":"https://kettycode.github.io/tags/modern-c/"}]},{"title":"现代C++学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/现代C++/base8/","text":"并行和并发该部分内容在并发编程里有详细讲解，这里就简单概括一下 1.并行基础std::thread 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含 头文件， 它提供了很多基本的线程操作，例如 get_id() 来获取所创建线程的线程 ID，使用 join() 来等待一个线程结束（与该线程汇合）等等 2.互斥区和临界区std::mutex 是 C++11 中最基本的 mutex 类，通过实例化 std::mutex 可以创建互斥量， 而通过其成员函数 lock() 可以进行上锁，unlock() 可以进行解锁。 但是在实际编写代码的过程中，最好不去直接调用成员函数， 因为调用成员函数就需要在每个临界区的出口处调用 unlock()，当然，还包括异常。 这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类 std::lock_guard。 RAII 在不失代码简洁性的同时，很好的保证了代码的异常安全性。 3.期物期物（Future）表现为 std::future，它提供了一个访问异步操作结果的途径，这句话很不好理解。 为了理解这个特性，我们需要先理解一下在 C++11 之前的多线程行为。 试想，如果我们的主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务，并返回我一个结果。 而这时候，线程 A 可能正在忙其他的事情，无暇顾及 B 的结果， 所以我们会很自然的希望能够在某个特定的时间获得线程 B 的结果。 在 C++11 的 std::future 被引入之前，通常的做法是： 创建一个线程 A，在线程 A 里启动任务 B，当准备完毕后发送一个事件，并将结果保存在全局变量中。 而主函数线程 A 里正在做其他的事情，当需要结果的时候，调用一个线程等待函数来获得执行的结果。 而 C++11 提供的 std::future 简化了这个流程，可以用来获取异步任务的结果。 自然地，我们很容易能够想象到把它作为一种简单的线程同步手段，即屏障（barrier）。 4.条件变量条件变量 std::condition_variable 是为了解决死锁而生，当互斥操作不够用而引入的。 比如，线程可能需要等待某个条件为真才能继续执行， 而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。 所以，condition_variable 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。 std::condition_variable的 notify_one() 用于唤醒一个线程； notify_all() 则是通知所有线程 5.原子操作和内存模型std::mutex 可以解决并发读写的问题，但互斥锁是操作系统级的功能， 这是因为一个互斥锁的实现通常包含两条基本原理：1.提供线程间自动的状态转换，即『锁住』这个状态2.保障在互斥锁操作期间，所操作变量的内存与临界区外进行隔离 这是一组非常强的同步条件，换句话说当最终编译为 CPU 指令时会表现为非常多的指令（我们之后再来看如何实现一个简单的互斥锁）。 这对于一个仅需原子级操作（没有中间态）的变量，似乎太苛刻了。 原子操作现代 CPU 体系结构提供了 CPU 指令级的原子操作， 因此在 C++11 中多线程下共享变量的读写这一问题上，还引入了 std::atomic 模板，使得我们实例化一个原子类型，将一个 原子类型读写操作从一组指令，最小化到单个 CPU 指令。 当然，并非所有的类型都能提供原子操作，这是因为原子操作的可行性取决于具体的 CPU 架构，以及所实例化的类型结构是否能够满足该 CPU 架构对内存对齐 条件的要求，因而我们总是可以通过 std::atomic::is_lock_free 来检查该原子类型是否需支持原子操作 一致性模型并行执行的多个线程，从某种宏观层面上讨论，可以粗略的视为一种分布式系统。 在分布式系统中，任何通信乃至本地操作都需要消耗一定时间，甚至出现不可靠的通信。 如果我们强行将一个变量 v 在多个线程之间的操作设为原子操作，即任何一个线程在操作完 v 后， 其他线程均能同步感知到 v 的变化，则对于变量 v 而言，表现为顺序执行的程序，它并没有由于引入多线程 而得到任何效率上的收益。对此有什么办法能够适当的加速呢？答案便是削弱原子操作的在进程间的同步条件。 从原理上看，每个线程可以对应为一个集群节点，而线程间的通信也几乎等价于集群节点间的通信。 削弱进程间的同步条件，通常我们会考虑四种不同的一致性模型：1.线性一致性：又称强一致性或原子一致性。它要求任何一次读操作都能读到某个数据的最近一次写的数据，并且所有线程的操作顺序与全局时钟下的顺序是一致的。2.顺序一致性：同样要求任何一次读操作都能读到数据最近一次写入的数据，但未要求与全局时钟的顺序一致。3.因果一致性：它的要求进一步降低，只需要有因果关系的操作顺序得到保障，而非因果关系的操作顺序则不做要求。4.最终一致性：是最弱的一致性要求，它只保障某个操作在未来的某个时间节点上会被观察到，但并未要求被观察到的时间。因此我们甚至可以对此条件稍作加强，例如规定某个操作被观察到的时间总是有界的。当然这已经不在我们的讨论范围之内了。 内存顺序为了追求极致的性能，实现各种强度要求的一致性，C++11 为原子操作定义了六种不同的内存顺序 std::memory_order 的选项，表达了四种多线程间的同步模型：1.宽松模型：在此模型下，单个线程内的原子操作都是顺序执行的，不允许指令重排，但不同线程间原子操作的顺序是任意的。类型通过std::memory_order_relaxed 指定 123456789101112std::atomic&lt;int&gt; counter = &#123;0&#125;;std::vector&lt;std::thread&gt; vt;for (int i = 0; i &lt; 100; ++i) &#123; vt.emplace_back([&amp;]()&#123; counter.fetch_add(1, std::memory_order_relaxed); &#125;);&#125;for (auto&amp; t : vt) &#123; t.join();&#125;std::cout &lt;&lt; &quot;current counter:&quot; &lt;&lt; counter &lt;&lt; std::endl; 2.释放&#x2F;消费模型：在此模型中，我们开始限制进程间的操作顺序，如果某个线程需要修改某个值，但另一个线程会对该值的某次操作产生依赖，即后者依赖前者。具体而言，线程 A 完成了三次对 x 的写操作，线程 B 仅依赖其中第三次 x 的写操作，与 x 的前两次写行为无关，则当 A 主动 x.release() 时候（即使用 std::memory_order_release），选项 std::memory_order_consume 能够确保 B 在调用 x.load() 时候观察到 A 中第三次对 x 的写操作 1234567891011121314151617// 初始化为 nullptr 防止 consumer 线程从野指针进行读取std::atomic&lt;int*&gt; ptr(nullptr);int v;std::thread producer([&amp;]() &#123; int* p = new int(42); v = 1024; ptr.store(p, std::memory_order_release);&#125;);std::thread consumer([&amp;]() &#123; int* p; while(!(p = ptr.load(std::memory_order_consume))); std::cout &lt;&lt; &quot;p: &quot; &lt;&lt; *p &lt;&lt; std::endl; std::cout &lt;&lt; &quot;v: &quot; &lt;&lt; v &lt;&lt; std::endl;&#125;);producer.join();consumer.join(); 3.释放&#x2F;获取模型：在此模型下，我们可以进一步加紧对不同线程间原子操作的顺序的限制，在释放 std::memory_order_release 和获取 std::memory_order_acquire 之间规定时序，即发生在释放（release）操作之前的所有写操作，对其他线程的任何获取（acquire）操作都是可见的，亦即发生顺序（happens-before）。 可以看到，std::memory_order_release 确保了它之前的写操作不会发生在释放操作之后，是一个向后的屏障（backward），而 std::memory_order_acquire 确保了它之前的写行为不会发生在该获取操作之后，是一个向前的屏障（forward）。对于选项 std::memory_order_acq_rel 而言，则结合了这两者的特点，唯一确定了一个内存屏障，使得当前线程对内存的读写不会被重排并越过此操作的前后 1234567891011121314151617181920std::vector&lt;int&gt; v;std::atomic&lt;int&gt; flag = &#123;0&#125;;std::thread release([&amp;]() &#123; v.push_back(42); flag.store(1, std::memory_order_release);&#125;);std::thread acqrel([&amp;]() &#123; int expected = 1; // must before compare_exchange_strong while(!flag.compare_exchange_strong(expected, 2, std::memory_order_acq_rel)) expected = 1; // must after compare_exchange_strong // flag has changed to 2&#125;);std::thread acquire([&amp;]() &#123; while(flag.load(std::memory_order_acquire) &lt; 2); std::cout &lt;&lt; v.at(0) &lt;&lt; std::endl; // must be 42&#125;);release.join();acqrel.join();acquire.join(); 在此例中我们使用了 compare_exchange_strong 比较交换原语（Compare-and-swap primitive），它有一个更弱的版本，即 compare_exchange_weak，它允许即便交换成功，也仍然返回 false 失败。其原因是因为在某些平台上虚假故障导致的，具体而言，当 CPU 进行上下文切换时，另一线程加载同一地址产生的不一致。除此之外，compare_exchange_strong 的性能可能稍差于 compare_exchange_weak，但大部分情况下，鉴于其使用的复杂度而言，compare_exchange_weak 应该被有限考虑 4.顺序一致模型：在此模型下，原子操作满足顺序一致性，进而可能对性能产生损耗。可显式的通过 std::memory_order_seq_cst 进行指定 123456789101112std::atomic&lt;int&gt; counter = &#123;0&#125;;std::vector&lt;std::thread&gt; vt;for (int i = 0; i &lt; 100; ++i) &#123; vt.emplace_back([&amp;]()&#123; counter.fetch_add(1, std::memory_order_seq_cst); &#125;);&#125;for (auto&amp; t : vt) &#123; t.join();&#125;std::cout &lt;&lt; &quot;current counter:&quot; &lt;&lt; counter &lt;&lt; std::endl;","comments":true,"tags":[{"name":"modern c++","slug":"modern-c","permalink":"https://kettycode.github.io/tags/modern-c/"}]},{"title":"现代C++学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/现代C++/base9/","text":"","comments":true,"tags":[{"name":"modern c++","slug":"modern-c","permalink":"https://kettycode.github.io/tags/modern-c/"}]},{"title":"现代C++学习","date":"2024-02-06T04:59:59.000Z","path":"2024/02/06/cpp/现代C++/base7/","text":"正则表达式正则表达式不是 C++ 语言的一部分，这里仅做简单的介绍。 正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求： 检查一个串是否包含某种形式的子串；将匹配的子串替换；从某个串中取出符合条件的子串。正则表达式是由普通字符（例如 a 到 z）以及特殊字符组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。 正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 普通字符普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 特殊字符 特别字符 描述 $ 匹配输入字符串的结尾位置。 (,) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。 * 匹配前面的子表达式零次或多次。 + 匹配前面的子表达式一次或多次。 . 匹配除换行符 \\n 之外的任何单字符。 [ 标记一个中括号表达式的开始。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， n 匹配字符 n。\\n 匹配换行符。序列 \\ 匹配 ‘&#39; 字符，而 ( 则匹配 ‘(‘ 字符。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。 { 标记限定符表达式的开始。 l(或符号) 指明两项之间的一个选择。 限定符 字符 描述 * 匹配前面的子表达式零次或多次。例如，foo* 能匹配 fo 以及 foooo。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，foo+ 能匹配 foo 以及 foooo，但不能匹配 fo。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，Your(s)? 可以匹配 Your 或 Yours 中的Your 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 for 中的 o，但是能匹配 foo 中的两个 o。 {n,} n 是一个非负整数。至少匹配 n 次。例如，o{2,} 不能匹配 for 中的 o，但能匹配 foooooo 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。 {n,m} m 和 n 均为非负整数，其中 n 小于等于 m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 foooooo 中的前三个 o。o{0,1} 等价于 o?。注意，在逗号和两个数之间不能有空格。 std::regex及其相关C++11 提供的正则表达式库操作 std::string 对象， 模式 std::regex (本质是 std::basic_regex)进行初始化， 通过 std::regex_match 进行匹配， 从而产生 std::smatch （本质是 std::match_results 对象）。 我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式: [a-z]+.txt: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多次， 因此 [a-z]+ 能够匹配一个小写字母组成的字符串。 在正则表达式中一个 . 表示匹配任意字符，而 . 则表示匹配字符 .， 最后的 txt 表示严格匹配 txt 则三个字母。因此这个正则表达式的所要匹配的内容就是由纯小写字母组成的文本文件。std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。 最简单的一个形式就是传入 std::string 以及一个 std::regex 进行匹配， 当匹配成功时，会返回 true，否则返回 false。例如： 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;regex&gt;int main() &#123; std::string fnames[] = &#123;&quot;foo.txt&quot;, &quot;bar.txt&quot;, &quot;test&quot;, &quot;a0.txt&quot;, &quot;AAA.txt&quot;&#125;; // 在 C++ 中 \\ 会被作为字符串内的转义符， // 为使 \\. 作为正则表达式传递进去生效，需要对 \\ 进行二次转义，从而有 \\\\. std::regex txt_regex(&quot;[a-z]+\\\\.txt&quot;); for (const auto &amp;fname: fnames) std::cout &lt;&lt; fname &lt;&lt; &quot;: &quot; &lt;&lt; std::regex_match(fname, txt_regex) &lt;&lt; std::endl;&#125; 另一种常用的形式就是依次传入 std::string&#x2F;std::smatch&#x2F;std::regex 三个参数， 其中 std::smatch 的本质其实是 std::match_results。 故而在标准库的实现中， std::smatch 被定义为了 std::match_resultsstd::string::const_iterator， 也就是一个子串迭代器类型的 match_results。 使用 std::smatch 可以方便的对匹配的结果进行获取 12345678910111213std::regex base_regex(&quot;([a-z]+)\\\\.txt&quot;);std::smatch base_match;for(const auto &amp;fname: fnames) &#123; if (std::regex_match(fname, base_match, base_regex)) &#123; // std::smatch 的第一个元素匹配整个字符串 // std::smatch 的第二个元素匹配了第一个括号表达式 if (base_match.size() == 2) &#123; std::string base = base_match[1].str(); std::cout &lt;&lt; &quot;sub-match[0]: &quot; &lt;&lt; base_match[0].str() &lt;&lt; std::endl; std::cout &lt;&lt; fname &lt;&lt; &quot; sub-match[1]: &quot; &lt;&lt; base &lt;&lt; std::endl; &#125; &#125;&#125; 12345678910//输出结果foo.txt: 1bar.txt: 1test: 0a0.txt: 0AAA.txt: 0sub-match[0]: foo.txtfoo.txt sub-match[1]: foosub-match[0]: bar.txtbar.txt sub-match[1]: bar","comments":true,"tags":[{"name":"modern c++","slug":"modern-c","permalink":"https://kettycode.github.io/tags/modern-c/"}]},{"title":"hazel具体实践遇到的一些小bug","date":"2023-10-25T06:59:59.000Z","path":"2023/10/25/Hazel_bug/bug/","text":"1.事件系统–未定义的标识符Hazel和sandBox预处理器设置错误。 2.日志系统错误 C2338 static_assert failed: ‘Cannot format an argument. To make type T formattable provide a formatter specialization: https://fmt.dev/latest/api.html#udt‘ Hazel C:\\Cpp_Dev\\Hazel\\Hazel\\vendor\\spdlog\\include\\spdlog\\fmt\\bundled\\core.h 1757 12HZ_CORE_TRACE(&quot;&#123;0&#125;&quot;, e.); =&gt; HZ_CORE_TRACE(&quot;&#123;0&#125;&quot;, e.ToString()); 3.GLFW这里的011的GLFW和现有库不同 会导致编译出错需要把GLFW的分支切到 git checkout -f b4b4319 这个是当时录制教程的一个中间commit然后把lua脚本中的systemversion改为latest然后premake 然后再编译 就可以避免LINK错误了","comments":true,"tags":[{"name":"Hazel_bug","slug":"Hazel-bug","permalink":"https://kettycode.github.io/tags/Hazel-bug/"}]},{"title":"无题","date":"2023-10-25T06:59:59.000Z","path":"2023/10/25/essay/2023-10-24/","text":"","comments":true,"tags":[{"name":"随笔","slug":"随笔","permalink":"https://kettycode.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"位运算基础——不需要额外空间交换两个数","date":"2023-10-23T12:59:59.000Z","path":"2023/10/23/bitSum/交换两个数/","text":"不用额外空间交换两个数基础位运算1234&amp;----与|----或!----非^----异或 简单交换算法123456void Swap(int&amp; num1, int&amp; num2)&#123; num1 = num1 ^ num2; num2 = num1 ^ num2; //num2 = num1 ^ num2 ^ num2 = num1; num1 = num1 ^ num2; //num1 = num1 ^ num2 ^ num1 = num2;&#125;","comments":true,"tags":[{"name":"位运算","slug":"位运算","permalink":"https://kettycode.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"位运算基础——找出数组中唯一一个只有一个的数","date":"2023-10-23T12:59:59.000Z","path":"2023/10/23/bitSum/找出单身狗/","text":"简单模式：数组中只有一个数出现一次，其他均出现两次，请找出这个数。12345678//原理：a ^ a = 0 a ^ 0 = aint FindOnlySum(vector&lt;int&gt;&amp; nums)&#123; int result = 0; for(auto&amp; num : nums)&#123; result ^= num; &#125; return result;&#125; 进阶模式：数组中只有一个数出现一次，其他均出现三次，请找出这个数。(题目来自力扣137)例：【1，2，3，2，4，4，3，4，2，3】0001001000110010010001000011010000100011++++0364%%%%30001 1234567891011121314//int FindOnlySum(vector&lt;int&gt;&amp; nums)&#123; int ans = 0; for (int i = 0; i &lt; 32; ++i) &#123; int total = 0; for (int num: nums) &#123; total += ((num &gt;&gt; i) &amp; 1);//(num &gt;&gt; i) &amp; 1 -&gt; num左移i位，然后与1与 == 取num的第i位 &#125; if (total % 3) &#123; //total % 3 = 0 / 1 ans |= (1 &lt;&lt; i); // ans | (1 &lt;&lt; i) -&gt; 1右移i位，与ans或 == 将ans的第i位变成1 &#125; &#125; return ans;&#125; 算法改进第i位(ai,bi)初始(00)连续经过三个零或三个1又变回(00) (00)-&gt;(01)-&gt;(10)-&gt;(00) (ai,bi) xi 新(ai,bi) 00 0 00 00 1 01 01 0 01 01 1 10 10 0 10 10 1 00 a &#x3D; (~a &amp; b &amp; x) | (a &amp; ~b &amp; ~x)b &#x3D; ~a &amp; (b ^ x) 最后结果:ai&#x3D;0 ,bi&#x3D;0&#x2F;1,即返回b即可。 1234567int FindOnlySum(vector&lt;int&gt;&amp; nums) &#123; int a = 0, b = 0; for (int num: nums) &#123; tie(a, b) = pair&#123;(~a &amp; b &amp; num) | (a &amp; ~b &amp; ~num), ~a &amp; (b ^ num)&#125;; &#125; return b;&#125; 进一步改进–同时计算改为分步计算因为bi计算更简单，所以我们先计算bi,再用新bi计算ai。(00)-&gt;(01) &#x3D;&gt; (00)-&gt;(01)-&gt;(01) (ai,bi) xi 新bi 00 0 0 00 1 1 01 0 1 01 1 0 10 0 0 10 1 0 (新ai,bi) xi 新ai 00 0 0 01 1 0 01 0 0 00 1 1 10 0 1 10 1 0 b &#x3D; ~a &amp; (b ˆ x)a &#x3D; ~b &amp; (a ˆ x)​ 1234567891011class Solution &#123;public: int FindOnlySum(vector&lt;int&gt;&amp; nums) &#123; int a = 0, b = 0; for (int num: nums) &#123; b = ~a &amp; (b ^ num); a = ~b &amp; (a ^ num); &#125; return b; &#125;&#125;;","comments":true,"tags":[{"name":"位运算","slug":"位运算","permalink":"https://kettycode.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"vue学习之路--基础知识","date":"2023-10-23T12:59:59.000Z","path":"2023/10/23/vue/vue-based/","text":"组合式vue31.reative,ref1234567891011&lt;script setup&gt;import &#123; reactive, ref &#125; from &#x27;vue&#x27;const counter = reactive(&#123; count: 0 &#125;)//reactive()只适用于对象 (包括数组和内置类型，如 Map 和 Set)const message = ref(&#x27;Hello World!&#x27;)//ref()则可以接受任何值类型。ref 会返回一个包裹对象，并在 .value 属性下暴露内部值。&lt;/script&gt;&lt;template&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt; &lt;p&gt;Count is: &#123;&#123; counter.count &#125;&#125;&lt;/p&gt;&lt;/template&gt; 2.Attrictive绑定 v-bind:id &#x3D;&gt; :idv-bind:id&#x3D;”dynamicId” 可简写成 :id&#x3D;”dynamicId”123456789101112131415&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const titleClass = ref(&#x27;title&#x27;)&lt;/script&gt;&lt;template&gt; &lt;h1 :class=&quot;titleClass&quot;&gt;Make me red&lt;/h1&gt;&lt;/template&gt;&lt;style&gt;.title &#123; color: red;&#125;&lt;/style&gt; 3.事件监听 v-on:click &#x3D;&gt; @clickv-on:click&#x3D;”increment”&gt; 简写成 @click&#x3D;”increment”&gt;12345678910111213&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)function increment() &#123; count.value++&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 12345678910&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;count++&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 4.表单绑定 v-bind:id &#x3D; “text” 和 v-on:input &#x3D; “onInput” &#x3D;&gt; v-model &#x3D; “text”v-bind 和 v-on 来在表单的输入元素上创建双向绑定,为了简化双向绑定，Vue 提供了一个 v-model 指令，它实际上是语法糖12345678&lt;input :value=&quot;text&quot; @input=&quot;onInput&quot;&gt;function onInput(e) &#123; // v-on 处理函数会接收原生 DOM 事件 // 作为其参数。 text.value = e.target.value&#125; 1&lt;input v-model=&quot;text&quot;&gt; 5.条件渲染 v-if和v-else12&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt; 123456789101112131415&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const awesome = ref(true)function toggle() &#123; awesome.value = !awesome.value&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;toggle&quot;&gt;toggle&lt;/button&gt; &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt; &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;&lt;/template&gt; 6.列表渲染 v-for12345&lt;ul&gt; &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;// 给每个 todo 对象一个唯一的 idlet id = 0const newTodo = ref(&#x27;&#x27;)const todos = ref([ &#123; id: id++, text: &#x27;Learn HTML&#x27; &#125;, &#123; id: id++, text: &#x27;Learn JavaScript&#x27; &#125;, &#123; id: id++, text: &#x27;Learn Vue&#x27; &#125;])function addTodo() &#123; todos.value.push(&#123; id: id++, text: newTodo.value &#125;) newTodo.value = &#x27;&#x27;&#125;function removeTodo(todo) &#123; todos.value = todos.value.filter((t) =&gt; t !== todo)&#125;&lt;/script&gt;&lt;template&gt; &lt;form @submit.prevent=&quot;addTodo&quot;&gt; &lt;input v-model=&quot;newTodo&quot;&gt; &lt;button&gt;Add Todo&lt;/button&gt; &lt;/form&gt; &lt;ul&gt; //使用了 filter 方法来过滤数组 todos.value 中的元素。 //通过匿名箭头函数 (t) =&gt; t !== todo，它保留了与 todo 不相等的元素，并返回一个过滤后的新数组。 &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt; &#123;&#123; todo.text &#125;&#125; &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; 7.计算属性介绍一个新 API：computed()。它可以让我们创建一个计算属性 ref，这个 ref 会动态地根据其他响应式数据源来计算其 .value123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;script setup&gt;import &#123; ref, computed &#125; from &#x27;vue&#x27;let id = 0const newTodo = ref(&#x27;&#x27;)const hideCompleted = ref(false)const todos = ref([ &#123; id: id++, text: &#x27;Learn HTML&#x27;, done: true &#125;, &#123; id: id++, text: &#x27;Learn JavaScript&#x27;, done: true &#125;, &#123; id: id++, text: &#x27;Learn Vue&#x27;, done: false &#125;])const filteredTodos = computed(() =&gt; &#123; return hideCompleted.value ? todos.value.filter((t) =&gt; !t.done) : todos.value&#125;)function addTodo() &#123; todos.value.push(&#123; id: id++, text: newTodo.value, done: false &#125;) newTodo.value = &#x27;&#x27;&#125;function removeTodo(todo) &#123; todos.value = todos.value.filter((t) =&gt; t !== todo)&#125;&lt;/script&gt;&lt;template&gt; &lt;form @submit.prevent=&quot;addTodo&quot;&gt; &lt;input v-model=&quot;newTodo&quot;&gt; &lt;button&gt;Add Todo&lt;/button&gt; &lt;/form&gt; &lt;ul&gt; &lt;li v-for=&quot;todo in filteredTodos&quot; :key=&quot;todo.id&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt; &lt;span :class=&quot;&#123; done: todo.done &#125;&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;/span&gt; &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;hideCompleted = !hideCompleted&quot;&gt; &#123;&#123; hideCompleted ? &#x27;Show all&#x27; : &#x27;Hide completed&#x27; &#125;&#125; &lt;/button&gt;&lt;/template&gt;&lt;style&gt;.done &#123; text-decoration: line-through;&#125;&lt;/style&gt;","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://kettycode.github.io/tags/vue/"}]},{"title":"vue学习之路--其他知识","date":"2023-10-23T12:59:59.000Z","path":"2023/10/23/vue/vue-learning/","text":"在script标签中写js代码，或者使用src引入js文件时，默认不能使用module形式，即不能使用import导入文件，但是我们可以再script标签上加上type&#x3D;module属性来改变方式。1234567//module.jsexport default function test()&#123; return &#x27;test&#x27;&#125;// index.jsimport test from &#x27;./module.js&#x27;;console.log(test()) 1234567891011// index.html&lt;body&gt; // 方法 1 ： 引入module.js，然后在script标签里面调用 &lt;script type=&quot;module&quot;&gt; import test from &#x27;./module.js&#x27;; console.log(test()) &lt;/script&gt; // 方法 2 ： 直接引入index.js，使用src引入 &lt;script type=&quot;module&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 鼠标悬停效果12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;a href=&quot;https://vitejs.dev&quot; target=&quot;_blank&quot;&gt; &lt;img src=&quot;/vite.svg&quot; class=&quot;logo&quot; alt=&quot;Vite logo&quot; /&gt; &lt;/a&gt; &lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot;&gt; &lt;img src=&quot;./assets/vue.svg&quot; class=&quot;logo vue&quot; alt=&quot;Vue logo&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;HelloWorld msg=&quot;Hello&quot; /&gt;&lt;/template&gt;&lt;style scoped&gt;.logo &#123; height: 6em; padding: 1.5em; will-change: filter; transition: filter 300ms;&#125;//hover : 鼠标悬停效果.logo:hover &#123; filter: drop-shadow(0 0 2em #646cffaa);&#125;.logo.vue:hover &#123; filter: drop-shadow(0 0 2em #42b883aa);&#125;&lt;/style&gt;","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://kettycode.github.io/tags/vue/"}]},{"title":"如何使用 makedown 编写个人博客","date":"2023-10-06T06:59:59.000Z","path":"2023/10/06/blog/博客编写/","text":"1.标题1234567891011一级标题=======二级标题--------或者# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 2.字体123456*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___ 3.一些特殊线123456789101112分割线**** * ******- - -----------删除线~~BAIDU.COM~~下划线&lt;u&gt;带下划线文本&lt;/u&gt; 4.脚注1234[^要注明的文本]如下：创建脚注格式类似这样 [^bilibili]。[^bilibili]: B站 创建脚注格式类似这样 ^bilibili。 5.列表12345678910111213141516171819202122* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项1. 第一项2. 第二项3. 第三项1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 6.区块12&gt;后加空格表示区块引用可与列表相互嵌套 7.代码12345678910如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：`printf()` 函数代码区块使用4个空格或者一个制表符（tab键），例如： &lt;c++ int main()&#123; return 0; &#125;也可以使用三个`包裹代码 &lt;c++ int main()&#123; return 0; &#125; 123int main()&#123; return 0;&#125; 8.链接12345678910111213141516171819[链接名称](链接地址)如：[bilibili](https://www.bilibili.com/)或者&lt;链接地址&gt;如：&lt;https://www.bilibili.com/&gt;高级链接:这个链接用 1 作为网址变量 [Google][1]这个链接用 bili 作为网址变量 [B站][bili]然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [bili]: https://www.bilibili.com/这个链接用 1 作为网址变量 [Google][1]这个链接用 bili 作为网址变量 [B站][bili]然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [bili]: https://www.bilibili.com/ 以下是高级链接生成的结果：这个链接用 1 作为网址变量 Google这个链接用 bili 作为网址变量 B站然后在文档的结尾为变量赋值（网址）1: http://www.google.com/bili: https://www.bilibili.com/ 这个链接用 1 作为网址变量 Google这个链接用 bili 作为网址变量 B站然后在文档的结尾为变量赋值（网址） 9.图片1234567891011![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)这个链接用 1 作为网址变量 [RUNOOB][1].然后在文档的结尾为变量赋值（网址）[1]: http://static.runoob.com/images/runoob-logo.png需要指定图片的高度与宽度，可以使用html里面的img标签：&lt;img decoding=&quot;async&quot; src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt; 10.表格123456789| 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 || 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 11.其他12不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ， 参考资料：菜鸟教程https://www.runoob.com/markdown/md-tutorial.html","comments":true,"tags":[{"name":"博客","slug":"博客","permalink":"https://kettycode.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hello World","date":"2023-10-03T05:21:14.098Z","path":"2023/10/03/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"tags":[]}]