<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>舍利子的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  
  
    <link rel="alternate" href="/atom.xml" title="舍利子的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="/localshare/css/share.css">

  
  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">舍利子的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">心事无人诉，苦、苦、苦！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/."><i class="fa fa-home"></i> 首页</a>
        
          <a class="main-nav-link" href="/archives/"><i class="fa fa-archive"></i> 归档</a>
        
          <a class="main-nav-link" href="/about/"><i class="fa fa-user"></i> 关于</a>
        
          <a class="main-nav-link" href="/atom.xml"><i class="fa fa-rss"></i> 订阅</a>
        
      </nav>
    </div>
    <div id="search-form">
      <div id="result-mask" class="hide"></div>
      <label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label>
      <div id="result-wrap" class="hide">
        <div id="search-result"></div>
      </div>
      <div class="hide">
        <template id="search-tpl">
          <div class="item">
            <a href="/{path}" title="{title}">
              <div class="title">{title}</div>
              <div class="time">{date}</div>
              <div class="tags">{tags}</div>
            </a>
          </div>
        </template>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  <article id="post-cpp/tip/char" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/19/cpp/tip/char/">cahr 和 wchar_t</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2024-02-19T04:59:59.000Z" itemprop="datePublished">2024年02月19日</time>
</span>
      
      
      
<a href="/2024/02/19/cpp/tip/char/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="char和wchar-t"><a href="#char和wchar-t" class="headerlink" title="char和wchar_t"></a>char和wchar_t</h1><h2 id="char-和-wchar-t-都是-C-中的字符类型，但它们之间有一些区别。char-是一个字节（8-位）长，而-wchar-t-是两个字节（16-位）或四个字节（32-位）长，具体取决于编译器和操作系统。因此，wchar-t-可以表示更多的字符，包括-Unicode-字符。"><a href="#char-和-wchar-t-都是-C-中的字符类型，但它们之间有一些区别。char-是一个字节（8-位）长，而-wchar-t-是两个字节（16-位）或四个字节（32-位）长，具体取决于编译器和操作系统。因此，wchar-t-可以表示更多的字符，包括-Unicode-字符。" class="headerlink" title="char 和 wchar_t 都是 C++ 中的字符类型，但它们之间有一些区别。char 是一个字节（8 位）长，而 wchar_t 是两个字节（16 位）或四个字节（32 位）长，具体取决于编译器和操作系统。因此，wchar_t 可以表示更多的字符，包括 Unicode 字符。"></a>char 和 wchar_t 都是 C++ 中的字符类型，但它们之间有一些区别。<br>char 是一个字节（8 位）长，而 wchar_t 是两个字节（16 位）或四个字节（32 位）长，具体取决于编译器和操作系统。<br>因此，wchar_t 可以表示更多的字符，包括 Unicode 字符。</h2><h2 id="在-Windows-操作系统中，许多-API-函数都使用-wchar-t-类型的字符串参数。如果需要处理-Unicode-字符或调用这些函数，则应使用-wchar-t-类型。否则，可以使用-char-类型。"><a href="#在-Windows-操作系统中，许多-API-函数都使用-wchar-t-类型的字符串参数。如果需要处理-Unicode-字符或调用这些函数，则应使用-wchar-t-类型。否则，可以使用-char-类型。" class="headerlink" title="在 Windows 操作系统中，许多 API 函数都使用 wchar_t 类型的字符串参数。如果需要处理 Unicode 字符或调用这些函数，则应使用 wchar_t 类型。否则，可以使用 char 类型。"></a>在 Windows 操作系统中，许多 API 函数都使用 wchar_t 类型的字符串参数。如果需要处理 Unicode 字符或调用这些函数，则应使用 wchar_t 类型。否则，可以使用 char 类型。</h2><h2 id="为了使程序适配多语言场景，不建议在代码中使用char或wchar-t，可直接使用TCHAR类型定义字符（串），需要包含对应头文件（在包含了Windows-h时则不需要）。TCHAR在源码中的定义如下："><a href="#为了使程序适配多语言场景，不建议在代码中使用char或wchar-t，可直接使用TCHAR类型定义字符（串），需要包含对应头文件（在包含了Windows-h时则不需要）。TCHAR在源码中的定义如下：" class="headerlink" title="为了使程序适配多语言场景，不建议在代码中使用char或wchar_t，可直接使用TCHAR类型定义字符（串），需要包含对应头文件&lt;TCHAR.H&gt;（在包含了Windows.h时则不需要）。TCHAR在源码中的定义如下："></a>为了使程序适配多语言场景，不建议在代码中使用char或wchar_t，可直接使用TCHAR类型定义字符（串），需要包含对应头文件&lt;TCHAR.H&gt;（在包含了Windows.h时则不需要）。TCHAR在源码中的定义如下：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _UNICODE</span></span><br><span class="line">     <span class="keyword">typedef</span> <span class="type">wchar_t</span> TCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> TCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="同理，在涉及到字符串操作的接口时，也推荐使用支持多语言场景的接口-tcscpy、-tcslen、-tcscat，而不是strcpy-s、strlen-s、strcat-s或wcscpy、wcslen、wcscat。头文件中有很多类似的宏定义。"><a href="#同理，在涉及到字符串操作的接口时，也推荐使用支持多语言场景的接口-tcscpy、-tcslen、-tcscat，而不是strcpy-s、strlen-s、strcat-s或wcscpy、wcslen、wcscat。头文件中有很多类似的宏定义。" class="headerlink" title="同理，在涉及到字符串操作的接口时，也推荐使用支持多语言场景的接口_tcscpy、_tcslen、_tcscat，而不是strcpy_s、strlen_s、strcat_s或wcscpy、wcslen、wcscat。头文件&lt;TCHAR.H&gt;中有很多类似的宏定义。"></a>同理，在涉及到字符串操作的接口时，也推荐使用支持多语言场景的接口_tcscpy、_tcslen、_tcscat，而不是strcpy_s、strlen_s、strcat_s或wcscpy、wcslen、wcscat。头文件&lt;TCHAR.H&gt;中有很多类似的宏定义。</h2><h1 id="前缀L-和-前缀-T"><a href="#前缀L-和-前缀-T" class="headerlink" title="前缀L 和 前缀_T"></a>前缀L 和 前缀_T</h1><h2 id="通常，我们使用双引号标识ANSI字符串，比如：”I’m-an-example-“-这种类型的字符串，每个字符占用一个字节。当我们想要标识UNICODE字符串时，需要添加前缀L，比如：L”I’m-an-example-“-。这种类型的字符串，每个字符占用两个字节。当然，为了适配多语言场景，也设计了一个通用的字符串前缀，即-T（或TEXT），这个前缀也是宏定义，其在源码中的定义如下："><a href="#通常，我们使用双引号标识ANSI字符串，比如：”I’m-an-example-“-这种类型的字符串，每个字符占用一个字节。当我们想要标识UNICODE字符串时，需要添加前缀L，比如：L”I’m-an-example-“-。这种类型的字符串，每个字符占用两个字节。当然，为了适配多语言场景，也设计了一个通用的字符串前缀，即-T（或TEXT），这个前缀也是宏定义，其在源码中的定义如下：" class="headerlink" title="通常，我们使用双引号标识ANSI字符串，比如：”I’m an example. “ 这种类型的字符串，每个字符占用一个字节。当我们想要标识UNICODE字符串时，需要添加前缀L，比如：L”I’m an example. “ 。这种类型的字符串，每个字符占用两个字节。当然，为了适配多语言场景，也设计了一个通用的字符串前缀，即_T（或TEXT），这个前缀也是宏定义，其在源码中的定义如下："></a>通常，我们使用双引号标识ANSI字符串，比如：”I’m an example. “ 这种类型的字符串，每个字符占用一个字节。当我们想要标识UNICODE字符串时，需要添加前缀L，比如：L”I’m an example. “ 。这种类型的字符串，每个字符占用两个字节。当然，为了适配多语言场景，也设计了一个通用的字符串前缀，即_T（或TEXT），这个前缀也是宏定义，其在源码中的定义如下：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _UNICODE </span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _T(c) L##c</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TEXT(c) L##c</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _T(c) c</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> TEXT(c) c</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="WCHAR-LPCTSTR-LPSTR-LPWSTR"><a href="#WCHAR-LPCTSTR-LPSTR-LPWSTR" class="headerlink" title="WCHAR LPCTSTR LPSTR LPWSTR"></a>WCHAR LPCTSTR LPSTR LPWSTR</h1><h2 id="WCHAR是一种Unicode编码类型，其在源码中的定义如下："><a href="#WCHAR是一种Unicode编码类型，其在源码中的定义如下：" class="headerlink" title="WCHAR是一种Unicode编码类型，其在源码中的定义如下："></a>WCHAR是一种Unicode编码类型，其在源码中的定义如下：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(_NATIVE_WCHAR_T_DEFINED)</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> WCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">     <span class="keyword">typedef</span> <span class="type">wchar_t</span> WCHAR;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="LPCTSTR是一种指针类型，该类型名可按照如下方式解读：LP-Pointer-C-Constant-T-TCHAR-STR-String-根据我们创建工程时的配置，LPCTSTR会映射为LPCSTR（ANSI）或LPCWSTR（Unicode）。"><a href="#LPCTSTR是一种指针类型，该类型名可按照如下方式解读：LP-Pointer-C-Constant-T-TCHAR-STR-String-根据我们创建工程时的配置，LPCTSTR会映射为LPCSTR（ANSI）或LPCWSTR（Unicode）。" class="headerlink" title="LPCTSTR是一种指针类型，该类型名可按照如下方式解读：LP - Pointer, C - Constant, T - TCHAR, STR - String.根据我们创建工程时的配置，LPCTSTR会映射为LPCSTR（ANSI）或LPCWSTR（Unicode）。"></a>LPCTSTR是一种指针类型，该类型名可按照如下方式解读：<br>LP - Pointer, C - Constant, T - TCHAR, STR - String.<br>根据我们创建工程时的配置，LPCTSTR会映射为LPCSTR（ANSI）或LPCWSTR（Unicode）。</h2><h2 id="LPSTR是一种指针类型，可能指向的数据编码类型为-ANSI-或-UTF-8，具体由protocol文件决定。LPSTR在源码中的定义如下：typedef-char-PSTR-LPSTR"><a href="#LPSTR是一种指针类型，可能指向的数据编码类型为-ANSI-或-UTF-8，具体由protocol文件决定。LPSTR在源码中的定义如下：typedef-char-PSTR-LPSTR" class="headerlink" title="LPSTR是一种指针类型，可能指向的数据编码类型为 ANSI 或 UTF-8，具体由protocol文件决定。LPSTR在源码中的定义如下：typedef char* PSTR, *LPSTR;"></a>LPSTR是一种指针类型，可能指向的数据编码类型为 ANSI 或 UTF-8，具体由protocol文件决定。LPSTR在源码中的定义如下：<br>typedef char* PSTR, *LPSTR;</h2><h2 id="LPWSTR也是一种指针类型，它用32位字符表示16位的Unicode字符，其在源码中的定义如下："><a href="#LPWSTR也是一种指针类型，它用32位字符表示16位的Unicode字符，其在源码中的定义如下：" class="headerlink" title="LPWSTR也是一种指针类型，它用32位字符表示16位的Unicode字符，其在源码中的定义如下："></a>LPWSTR也是一种指针类型，它用32位字符表示16位的Unicode字符，其在源码中的定义如下：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">wchar_t</span>* LPWSTR, *PWSTR;</span><br></pre></td></tr></table></figure>

<h1 id="stprintf-s"><a href="#stprintf-s" class="headerlink" title="_stprintf_s"></a>_stprintf_s</h1><h2 id="stprintf-s-函数的第一个参数是要格式化的字符串，第二个参数是要插入到字符串中的值。"><a href="#stprintf-s-函数的第一个参数是要格式化的字符串，第二个参数是要插入到字符串中的值。" class="headerlink" title="_stprintf_s() 函数的第一个参数是要格式化的字符串，第二个参数是要插入到字符串中的值。"></a>_stprintf_s() 函数的第一个参数是要格式化的字符串，第二个参数是要插入到字符串中的值。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _stprintf_s     swprintf_s</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _stprintf_s     sprintf_s</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCHAR str[<span class="number">256</span>];</span><br><span class="line">_stprintf_s(str, _T(<span class="string">&quot;(%f,%f,%f)&quot;</span>), pt[<span class="number">0</span>], pt[<span class="number">1</span>], pt[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
        
        
          <blockquote id="copyright">
              <p>原文链接: <a href="https://kettycode.github.io/index.html">https://kettycode.github.io/index.html</a></p>
              <p>版权声明: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tip/" rel="tag">tip</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-cpp/tip/hash" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/19/cpp/tip/hash/">哈希表小知识点及引申</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2024-02-19T04:59:59.000Z" itemprop="datePublished">2024年02月19日</time>
</span>
      
      
      
<a href="/2024/02/19/cpp/tip/hash/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="unordered-map中的小知识"><a href="#unordered-map中的小知识" class="headerlink" title="unordered_map中的小知识"></a>unordered_map中的小知识</h1><h2 id="unordered-map-将-key的某种类型-通过哈希函数映射成-size-t-即可-等价成数组"><a href="#unordered-map-将-key的某种类型-通过哈希函数映射成-size-t-即可-等价成数组" class="headerlink" title="unordered_map 将 key的某种类型 通过哈希函数映射成 size_t 即可 等价成数组"></a>unordered_map 将 key的某种类型 通过哈希函数映射成 size_t 即可 等价成数组</h2><h2 id="例如：unordered-map-map中的键（key）string-通过hash函数转化成特定的size-t-unsigned-int-类型，即和vector没太大区别"><a href="#例如：unordered-map-map中的键（key）string-通过hash函数转化成特定的size-t-unsigned-int-类型，即和vector没太大区别" class="headerlink" title="例如：unordered_map&lt;string,int&gt; map中的键（key）string 通过hash函数转化成特定的size_t(unsigned int)类型，即和vector没太大区别"></a>例如：unordered_map&lt;string,int&gt; map中的键（key）string 通过hash函数转化成特定的size_t(unsigned int)类型，即和vector<int>没太大区别</h2><h2 id="对某些没有默认哈希函数的类型可以自定义哈希函数，例如下列函数："><a href="#对某些没有默认哈希函数的类型可以自定义哈希函数，例如下列函数：" class="headerlink" title="对某些没有默认哈希函数的类型可以自定义哈希函数，例如下列函数："></a>对某些没有默认哈希函数的类型可以自定义哈希函数，例如下列函数：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 对int类型的默认哈希函数 自定义 对array&lt;int, 26&gt; 类型的哈希函数</span></span><br><span class="line"><span class="keyword">auto</span> arrayHash = [fn = hash&lt;<span class="type">int</span>&gt;&#123;&#125;] (<span class="type">const</span> array&lt;<span class="type">int</span>, <span class="number">26</span>&gt;&amp; arr) -&gt; <span class="type">size_t</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">accumulate</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">0u</span>, [&amp;](<span class="type">size_t</span> acc, <span class="type">int</span> num) &#123;</span><br><span class="line">            <span class="built_in">return</span> (acc &lt;&lt; <span class="number">1</span>) ^ <span class="built_in">fn</span>(num);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;array&lt;<span class="type">int</span>, 26&gt;, vector&lt;string&gt;, <span class="keyword">decltype</span>(arrayHash)&gt; <span class="built_in">mp</span>(<span class="number">0</span>, arrayHash);</span><br></pre></td></tr></table></figure>

<h1 id="上述函数用到的lambda表达式"><a href="#上述函数用到的lambda表达式" class="headerlink" title="上述函数用到的lambda表达式"></a>上述函数用到的lambda表达式</h1><h2 id="lambda-lambda本质上是一个普通的函数，只是它不像普通函数这样声明，它是我们的代码在过程中生成的，用完即弃的函数，不算一个真正的函数，是匿名函数-。格式：-形参表-函数内容-返回类型-函数内容"><a href="#lambda-lambda本质上是一个普通的函数，只是它不像普通函数这样声明，它是我们的代码在过程中生成的，用完即弃的函数，不算一个真正的函数，是匿名函数-。格式：-形参表-函数内容-返回类型-函数内容" class="headerlink" title="lambda:lambda本质上是一个普通的函数，只是它不像普通函数这样声明，它是我们的代码在过程中生成的，用完即弃的函数，不算一个真正的函数，是匿名函数 。格式：[] ({形参表}) {函数内容} &#x2F;  -&gt;返回类型{函数内容}"></a>lambda:lambda本质上是一个普通的函数，只是它不像普通函数这样声明，<br>它是我们的代码在过程中生成的，用完即弃的函数，不算一个真正的函数，是匿名函数 。<br>格式：[] ({形参表}) {函数内容} &#x2F;  <a href="%7B%E5%BD%A2%E5%8F%82%E8%A1%A8%7D"></a>-&gt;返回类型{函数内容}</h2><h2 id="中括号表示的是捕获，作用是如何传递变量-lambda使用外部（相对）的变量时，就要使用捕获。如果使用捕获-则："><a href="#中括号表示的是捕获，作用是如何传递变量-lambda使用外部（相对）的变量时，就要使用捕获。如果使用捕获-则：" class="headerlink" title="中括号表示的是捕获，作用是如何传递变量 lambda使用外部（相对）的变量时，就要使用捕获。如果使用捕获,则："></a>中括号表示的是捕获，作用是如何传递变量 lambda使用外部（相对）的变量时，就要使用捕获。<br>如果使用捕获,则：</h2><h2 id="添加头文件：-include-functional-捕获-使用方式：-，则是将所有变量值传递到lambda中-，则是将所有变量引用传递到lambda中-a-是将变量a通过值传递，如果是-a-就是将变量a引用传递它可以有0个或者多个捕获"><a href="#添加头文件：-include-functional-捕获-使用方式：-，则是将所有变量值传递到lambda中-，则是将所有变量引用传递到lambda中-a-是将变量a通过值传递，如果是-a-就是将变量a引用传递它可以有0个或者多个捕获" class="headerlink" title="添加头文件： #include&lt; functional &gt;捕获[]使用方式：[&#x3D;]，则是将所有变量值传递到lambda中[&amp;]，则是将所有变量引用传递到lambda中[a]是将变量a通过值传递，如果是[&amp;a]就是将变量a引用传递它可以有0个或者多个捕获"></a>添加头文件： #include&lt; functional &gt;<br>捕获[]使用方式：<br>[&#x3D;]，则是将所有变量值传递到lambda中<br>[&amp;]，则是将所有变量引用传递到lambda中<br>[a]是将变量a通过值传递，如果是[&amp;a]就是将变量a引用传递<br>它可以有0个或者多个捕获</h2>
        
        
          <blockquote id="copyright">
              <p>原文链接: <a href="https://kettycode.github.io/index.html">https://kettycode.github.io/index.html</a></p>
              <p>版权声明: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tip/" rel="tag">tip</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-cmake/cmake1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/06/cmake/cmake1/">cmake学习从0开始</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2024-02-06T04:59:59.000Z" itemprop="datePublished">2024年02月06日</time>
</span>
      
      
      
<a href="/2024/02/06/cmake/cmake1/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="step-1-a-basic-starting-point"><a href="#step-1-a-basic-starting-point" class="headerlink" title="step 1 : a basic starting point"></a>step 1 : a basic starting point</h1><h2 id="Exercise-1-building-a-basic-project"><a href="#Exercise-1-building-a-basic-project" class="headerlink" title="Exercise 1 - building a basic project"></a>Exercise 1 - building a basic project</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cmake版本最低要求</span></span><br><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line"></span><br><span class="line"><span class="comment">#项目名称</span></span><br><span class="line">project(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加项目所需的源代码文件</span></span><br><span class="line">add_executable(MyProject main.cpp)</span><br></pre></td></tr></table></figure>

<h2 id="Exercise-2-spacifying-the-C-Standard"><a href="#Exercise-2-spacifying-the-C-Standard" class="headerlink" title="Exercise 2 - spacifying the C++ Standard"></a>Exercise 2 - spacifying the C++ Standard</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cmake版本最低要求</span></span><br><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置C++标准</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD 11)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置C++标准为必须</span></span><br><span class="line"><span class="built_in">set</span>(CAMKE_CXX_STANDARD_REQUIRED True)</span><br><span class="line"></span><br><span class="line"><span class="comment">#项目名称</span></span><br><span class="line">project(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加项目所需的源代码文件</span></span><br><span class="line">add_executable(MyProject main.cpp)</span><br></pre></td></tr></table></figure>

<h2 id="Exercise-3-adding-a-version-number-and-configured-header-file"><a href="#Exercise-3-adding-a-version-number-and-configured-header-file" class="headerlink" title="Exercise 3 - adding a version number and configured header file"></a>Exercise 3 - adding a version number and configured header file</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cmake版本最低要求</span></span><br><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line"></span><br><span class="line"><span class="comment">#项目名称</span></span><br><span class="line">project(MyProject Version 1.0)</span><br><span class="line"></span><br><span class="line">configure_file(MyProjectConfig.h.in MyProjectConfig.h)</span><br><span class="line"></span><br><span class="line">target_include_directories(MyProject PUBLIC <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加项目所需的源代码文件</span></span><br><span class="line">add_executable(MyProject main.cpp)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MyProjectConfig.h.in</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define VERSION_MAJOR @MyProject_VERSION_MAJOR@</span></span><br><span class="line"><span class="comment">#define VERSION_MINOR @MyProject_VERSION_MINOR@</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#inlcude <span class="string">&lt;MyProjectconfig.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; Version &quot;</span> &lt;&lt; VERSION_MAJOR &lt;&lt; <span class="string">&quot; . &quot;</span> </span><br><span class="line">          &lt;&lt; VERSION_MINOR &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; number &quot;</span> &lt;&lt; std:: endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        
          <blockquote id="copyright">
              <p>原文链接: <a href="https://kettycode.github.io/index.html">https://kettycode.github.io/index.html</a></p>
              <p>版权声明: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cmake/" rel="tag">cmake</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-cmake/cmake2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/06/cmake/cmake2/">cmake学习从0开始</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2024-02-06T04:59:59.000Z" itemprop="datePublished">2024年02月06日</time>
</span>
      
      
      
<a href="/2024/02/06/cmake/cmake2/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Step-2-adding-a-library"><a href="#Step-2-adding-a-library" class="headerlink" title="Step 2:adding a library"></a>Step 2:adding a library</h1><h2 id="Exercise-1-creating-a-library"><a href="#Exercise-1-creating-a-library" class="headerlink" title="Exercise 1 - creating a library"></a>Exercise 1 - creating a library</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_library(MathFunctions MathFunctions.cxx mysqrt.cxx)</span><br><span class="line"></span><br><span class="line">add_subdirectory(MathFunctions)</span><br><span class="line"></span><br><span class="line">target_link_libraries(Tutorial PUBLIC MathFunctions)</span><br><span class="line"></span><br><span class="line">target_include_directories(Tutorial PUBLIC </span><br><span class="line">                        <span class="string">&quot;<span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>&quot;</span> </span><br><span class="line">                        <span class="string">&quot;<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/MathFunctions&quot;</span></span><br><span class="line">                        )</span><br></pre></td></tr></table></figure>

<h2 id="Exercise-2-adding-an-option"><a href="#Exercise-2-adding-an-option" class="headerlink" title="Exercise 2 - adding an option"></a>Exercise 2 - adding an option</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathFunctions/CMakeLists.txt</span></span><br><span class="line">option(USE_MYMATH <span class="string">&quot;Use tutorialc provided math implementation&quot;</span> ON)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(USE_MYMATH)</span><br><span class="line">    target_compile_definitions(MathFunctions PRIVATE <span class="string">&quot;USE_MYmATH&quot;</span>)</span><br><span class="line">    add_library(SqrtLibrary STATIC</span><br><span class="line">            mysqrt.cxx</span><br><span class="line">            )</span><br><span class="line">    target_link_libraries(MathFunctions PRIVATE SqrtLibrary)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">add_library(MathFunction MathFunctions.cxx)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathFunctions/MathFunctions.cxx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef USE_MYMATH</span></span><br><span class="line">    <span class="built_in">return</span> detail::mysqrt(x);</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">    <span class="built_in">return</span> std::sqrt(x);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef USE_MYMATH</span></span><br><span class="line"><span class="comment">#   include &quot;mysqrt.h&quot;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include  &lt;cmath&gt;</span></span><br></pre></td></tr></table></figure>
        
        
          <blockquote id="copyright">
              <p>原文链接: <a href="https://kettycode.github.io/index.html">https://kettycode.github.io/index.html</a></p>
              <p>版权声明: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cmake/" rel="tag">cmake</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-git/git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/06/git/git/">git学习从0开始</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2024-02-06T04:59:59.000Z" itemprop="datePublished">2024年02月06日</time>
</span>
      
      
      
<a href="/2024/02/06/git/git/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-初始化配置"><a href="#1-初始化配置" class="headerlink" title="1 初始化配置"></a>1 初始化配置</h1><h2 id="1-1-配置用户名和邮箱"><a href="#1-1-配置用户名和邮箱" class="headerlink" title="1.1 配置用户名和邮箱"></a>1.1 配置用户名和邮箱</h2><p>git config –global user.name  ketty(“ketty master”)<br>git config –global user.email <a href="mailto:&#x6b;&#101;&#116;&#x74;&#121;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;">&#x6b;&#101;&#116;&#x74;&#121;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;</a><br>参数含义：<br>省略(local) : 本地配置，只对本地仓库有效<br>–global : 全局配置，对所有仓库有效<br>–system : 系统配置，对所有用户有效</p>
<h2 id="1-2-保存用户名和密码"><a href="#1-2-保存用户名和密码" class="headerlink" title="1.2 保存用户名和密码"></a>1.2 保存用户名和密码</h2><p>git config –global credential.helper store</p>
<h2 id="1-3-查看git的配置信息"><a href="#1-3-查看git的配置信息" class="headerlink" title="1.3 查看git的配置信息"></a>1.3 查看git的配置信息</h2><p>git config –glabal –list</p>
<h1 id="2-新建仓库"><a href="#2-新建仓库" class="headerlink" title="2 新建仓库"></a>2 新建仓库</h1><h2 id="2-1-创建一个仓库"><a href="#2-1-创建一个仓库" class="headerlink" title="2.1 创建一个仓库"></a>2.1 创建一个仓库</h2><p>git init<br>git init my-repo</p>
<h2 id="2-2-克隆一个仓库"><a href="#2-2-克隆一个仓库" class="headerlink" title="2.2 克隆一个仓库"></a>2.2 克隆一个仓库</h2><p>git clone </p>
<h1 id="3-工作区域和文件状态"><a href="#3-工作区域和文件状态" class="headerlink" title="3 工作区域和文件状态"></a>3 工作区域和文件状态</h1><h2 id="3-1-工作区域"><a href="#3-1-工作区域" class="headerlink" title="3.1 工作区域"></a>3.1 工作区域</h2><p>工作区(Working Directory) : 实际操作的目录<br>暂存区(Staging Area&#x2F;Index) : 中间区域,临时存放即将提交的修改内容<br>本地仓库(Local Repository) : git存储代码和版本信息的主要位置<br>git add : 工作区 -&gt; 暂存区<br>git commit : 暂存区 -&gt; 本地仓库</p>
<h2 id="3-2-git中的文件状态"><a href="#3-2-git中的文件状态" class="headerlink" title="3.2 git中的文件状态"></a>3.2 git中的文件状态</h2><p>未跟踪(Untrack)<br>未修改(Unmodified)<br>已暂存(Modified)<br>已提交(Staged)</p>
<h1 id="4-添加和提交文件"><a href="#4-添加和提交文件" class="headerlink" title="4 添加和提交文件"></a>4 添加和提交文件</h1><p>git status &#x2F;&#x2F;查看仓库状态<br>git add <file>&#x2F;&#x2F;添加到暂存区<br>git add .&#x2F;&#x2F;添加所有文件<br>git commit -m “描述”&#x2F;&#x2F;提交<br>git commit -am “描述” &#x2F;&#x2F;工作区-&gt;本地仓库<br>git log &#x2F;&#x2F;打印git记录 ,– oneline 查看简洁的提交记录<br>git rm –cached <file>… &#x2F;&#x2F;将提交到暂存的文件移除出来</p>
<h1 id="5-回退版本"><a href="#5-回退版本" class="headerlink" title="5 回退版本"></a>5 回退版本</h1><p>git reset –soft &#x2F;&#x2F;回退到某个版本，保留工作区和暂存区的所有修改内容<br>git reset –hard &#x2F;&#x2F;回退到某个版本，丢弃工作区和暂存区的所有修改内容<br>git reset –mixed &#x2F;&#x2F;回退到某个版本，只保留工作区的修改内容</p>
<h1 id="6-查看差异"><a href="#6-查看差异" class="headerlink" title="6 查看差异"></a>6 查看差异</h1><p>git diff &#x2F;&#x2F; 工作区 vs 暂存区<br>git diff HEAD &#x2F;&#x2F;工作区 + 暂存区 vs 本地仓库<br>git diff cached &#x2F;&#x2F;暂存区 vs 本地仓库<br>git diff staged &#x2F;&#x2F;暂存区 vs 本地仓库<br>git diff <commit_hash> <commit_hash> &#x2F;&#x2F;提交之间的差异<br>git diff HEAD~HEAD &#x2F;&#x2F;提交之间的差异<br>git diff <branch_name> <branch_name> &#x2F;&#x2F;分支之间的差异</p>
<h1 id="7-删除文件"><a href="#7-删除文件" class="headerlink" title="7 删除文件"></a>7 删除文件</h1><p>&#x2F;&#x2F;删除之后记得提交<br>rm file ; gti add file &#x2F;&#x2F;删除工作区的文件，然后暂存删除文件<br>git rm <file> &#x2F;&#x2F;把文件从工作区和暂存区同时删除<br>git rm –cached <file> &#x2F;&#x2F;把文件从暂存区删除<br>git rm -r* &#x2F;&#x2F;递归删除某个目录下的所有子目录和文件</p>
<h1 id="8-忽略文件"><a href="#8-忽略文件" class="headerlink" title="8 忽略文件"></a>8 忽略文件</h1><p>.gitignore文件</p>
<h1 id="9-SSH配置和克隆仓库"><a href="#9-SSH配置和克隆仓库" class="headerlink" title="9 SSH配置和克隆仓库"></a>9 SSH配置和克隆仓库</h1><p>ssh-keygen -t rsa -b 4096<br>&#x2F;&#x2F;私匙文件：id_rsa<br>&#x2F;&#x2F;公匙文件：id_rsa.pub</p>
<p>git push <remote> <branch> &#x2F;&#x2F;推送更新内容<br>git pull <remote> &#x2F;&#x2F;拉取更新内容</p>
<h1 id="10-关联本地仓库和远程仓库"><a href="#10-关联本地仓库和远程仓库" class="headerlink" title="10 关联本地仓库和远程仓库"></a>10 关联本地仓库和远程仓库</h1><p>&#x2F;&#x2F;添加远程仓库<br>1.git remote add &lt;远程仓库别名&gt; &lt;远程仓库地址&gt;<br>2.git push -u &lt;远程仓库别名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p>
<p>git remote -v &#x2F;&#x2F;查看远程仓库<br>git pull &lt;远程仓库别名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; &#x2F;&#x2F;拉取远程仓库内容<br>(相同可省略冒号及后面的部分)</p>
<h1 id="分支基本操作"><a href="#分支基本操作" class="headerlink" title="分支基本操作"></a>分支基本操作</h1><p>git branch &#x2F;&#x2F;查看分支列表<br>git branch &lt;新分支名&gt; &#x2F;&#x2F;创建新分支<br>git checkout &lt;新分支名&gt; &#x2F;&#x2F;切换新分支<br>git switch &lt;新分支名&gt; &#x2F;&#x2F;切换新分支<br>git merge &lt;新分支名&gt; &#x2F;&#x2F;合并分支<br>git branch -d &lt;新分支名&gt; &#x2F;&#x2F;删除已合并分支<br>git branch -D &lt;新分支名&gt; &#x2F;&#x2F;删除未合并分支</p>
<h1 id="分支合并冲突"><a href="#分支合并冲突" class="headerlink" title="分支合并冲突"></a>分支合并冲突</h1><p>手动更改文件解决合并冲突<br>git merge –about &#x2F;&#x2F;终止合并</p>
<h1 id="回退和rebase"><a href="#回退和rebase" class="headerlink" title="回退和rebase"></a>回退和rebase</h1><p>git rebase &lt;分支名&gt;</p>

        
        
          <blockquote id="copyright">
              <p>原文链接: <a href="https://kettycode.github.io/index.html">https://kettycode.github.io/index.html</a></p>
              <p>版权声明: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-cpp/linux网络编程/base1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/06/cpp/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/base1/">linux网络编程基础知识</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2024-02-06T04:59:59.000Z" itemprop="datePublished">2024年02月06日</time>
</span>
      
      
      
<a href="/2024/02/06/cpp/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/base1/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-分层模型及典型协议"><a href="#1-分层模型及典型协议" class="headerlink" title="1.分层模型及典型协议"></a>1.分层模型及典型协议</h1><p>应用层 常见的协议有HTTP协议，FTP协议。<br>传输层 常见协议有TCP&#x2F;UDP协议。<br>网络层 常见协议有IP协议、ICMP协议、IGMP协议。<br>网络接口层 常见协议有ARP协议、RARP协议。<br>TCP传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。<br>UDP用户数据报协议（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。<br>HTTP超文本传输协议（Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议。<br>FTP文件传输协议（File Transfer Protocol）<br>IP协议是因特网互联协议（Internet Protocol）<br>ICMP协议是Internet控制报文协议（Internet Control Message Protocol）它是TCP&#x2F;IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。<br>IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。<br>ARP协议是正向地址解析协议（Address Resolution Protocol），通过已知的IP，寻找对应主机的MAC地址。<br>RARP是反向地址转换协议，通过MAC地址确定IP地址。</p>
<p>网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。</p>
<h1 id="2-TCP和UDP"><a href="#2-TCP和UDP" class="headerlink" title="2.TCP和UDP"></a>2.TCP和UDP</h1><p>TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。<br>UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。</p>
<p>应用程序所看到的数据是一个整体，或说是一个流（stream），在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。</p>
<p>3.tcp建立连接和断开连接-三次握手、四次挥手</p>
<p>建立连接（三次握手）的过程：<br>1.客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。<br>客户端发出段1，SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况，另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。<br>2.服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。<br>服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。<br>3.客户必须再次回应服务器端一个ACK报文，这是报文段3。<br>客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为“三方握手（three-way-handshake）”。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。</p>
<p>关闭连接（四次握手）的过程：<br>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。<br>1.客户端发出，FIN位表示关闭连接的请求。<br>2.服务器发出，应答客户端的关闭连接请求。<br>3.服务器发出，其中也包含FIN位，向客户端发送关闭连接请求。<br>4.客户端发出，应答服务器的关闭连接请求。<br>建立连接的过程是三方握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。</p>
<h1 id="4-滑动窗口"><a href="#4-滑动窗口" class="headerlink" title="4.滑动窗口"></a>4.滑动窗口</h1><p>滑动窗口:随着应用程序提走数据，虚线框（接收缓冲区）是向右滑动的，因此称为滑动窗口。</p>
<h1 id="5-tcp-状态转换"><a href="#5-tcp-状态转换" class="headerlink" title="5.tcp 状态转换"></a>5.tcp 状态转换</h1><p>CLOSED：表示初始状态。<br>LISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。<br>SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。<br>SYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。<br>ESTABLISHED：表示连接已经建立。<br>FIN_WAIT_1:  FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：<br>FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。<br>FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。<br>FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。<br>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。<br>CLOSING: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。<br>CLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。<br>LAST_ACK: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</p>
<h1 id="6-路由器和交换机"><a href="#6-路由器和交换机" class="headerlink" title="6.路由器和交换机"></a>6.路由器和交换机</h1><p>路由和交换之间的主要区别就是交换发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换在移动信息的过程 中需使用不同的控制信息，所以两者实现各自功能的方式是不同的。</p>
<h1 id="7-半关闭"><a href="#7-半关闭" class="headerlink" title="7.半关闭"></a>7.半关闭</h1><p>当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。<br>从程序的角度，可以使用API来控制实现半连接状态。<br>#include &lt;sys&#x2F;socket.h&gt;<br>int shutdown(int sockfd, int how);<br>sockfd: 需要关闭的socket的描述符<br>how:	允许为shutdown操作选择以下几种方式:<br>    SHUT_RD(0)：	关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。<br>                    该套接字不再接受数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。<br>    SHUT_WR(1):		关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。<br>    SHUT_RDWR(2):	关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。<br>使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。<br>shutdown不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。<br>注意:<br>1.如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。<br>2.在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但，如果一个进程close(sfd)将不会影响到其它进程。</p>

        
        
          <blockquote id="copyright">
              <p>原文链接: <a href="https://kettycode.github.io/index.html">https://kettycode.github.io/index.html</a></p>
              <p>版权声明: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">linux网络编程</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-cpp/linux网络编程/socket编程1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/06/cpp/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E7%BC%96%E7%A8%8B1/">Socket编程</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2024-02-06T04:59:59.000Z" itemprop="datePublished">2024年02月06日</time>
</span>
      
      
      
<a href="/2024/02/06/cpp/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E7%BC%96%E7%A8%8B1/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>#socket<br>Socket本身有“插座”的意思，在Linux环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。</p>
<p>在TCP&#x2F;IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p>
<p>在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。</p>
<p>#socket API<br>##为TCP&#x2F;IP协议设计的应用层编程接口</p>
<p>TCP&#x2F;IP协议规定，网络数据流应采用大端字节序，即低地址高字节<br>为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。<br>h表示host，n表示network，l表示32位长整数，s表示16位短整数。<br>如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br></pre></td></tr></table></figure>

<p>#IP地址转换函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//早期，只能处理IPv4的ip地址，不可重入函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span>;</span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持IPv4和IPv6，可重入函数，其中inet_pton和inet_ntop不仅可以转换IPv4的</span></span><br><span class="line"><span class="comment">//in_addr，还可以转换IPv6的in6_addr。因此函数接口是void *addrptr。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>#sockaddr数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span> sa_family; 		<span class="comment">/* address family, AF_xxx */</span></span><br><span class="line">	<span class="type">char</span> sa_data[<span class="number">14</span>];			<span class="comment">/* 14 bytes of protocol address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">	<span class="type">__kernel_sa_family_t</span> sin_family; 			<span class="comment">/* Address family */</span>  	地址结构类型</span><br><span class="line">	__be16 sin_port;					 		<span class="comment">/* Port number */</span>		端口号</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>					<span class="comment">/* Internet address */</span>	IP地址</span><br><span class="line">	<span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> __pad[__SOCK_SIZE__ - <span class="keyword">sizeof</span>(<span class="type">short</span> <span class="type">int</span>) -</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span>						<span class="comment">/* Internet address. */</span></span><br><span class="line">	__be32 s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin6_family; 		<span class="comment">/* AF_INET6 */</span></span><br><span class="line">	__be16 sin6_port; 					<span class="comment">/* Transport layer port # */</span></span><br><span class="line">	__be32 sin6_flowinfo; 				<span class="comment">/* IPv6 flow information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>			<span class="comment">/* IPv6 address */</span></span><br><span class="line">	__u32 sin6_scope_id; 				<span class="comment">/* scope id (new in RFC2553) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u8 u6_addr8[<span class="number">16</span>];</span><br><span class="line">		__be16 u6_addr16[<span class="number">8</span>];</span><br><span class="line">		__be32 u6_addr32[<span class="number">4</span>];</span><br><span class="line">	&#125; in6_u;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> s6_addr 		in6_u.u6_addr8</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> s6_addr16 	    in6_u.u6_addr16</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> s6_addr32	 	in6_u.u6_addr32</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">	<span class="type">__kernel_sa_family_t</span> sun_family; 	<span class="comment">/* AF_UNIX */</span></span><br><span class="line">	<span class="type">char</span> sun_path[UNIX_PATH_MAX]; 	<span class="comment">/* pathname */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Pv4和IPv6的地址格式定义在netinet&#x2F;in.h中，IPv4地址用sockaddr_in结构体表示，包括16位端口号和32位IP地址，IPv6地址用sockaddr_in6结构体表示，包括16位端口号、128位IP地址和一些控制字段</p>
<p>因此，socket API可以接受各种类型的sockaddr结构体指针做参数，例如bind、accept、connect等函数，这些函数的参数应该设计成void *类型以便接受各种类型的指针，但是sock API的实现早于ANSI C标准化，那时还没有void *类型，因此这些函数的参数都用struct sockaddr *类型表示，在传递参数之前要强制类型转换一下，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));		<span class="comment">/* initialize servaddr */</span></span><br></pre></td></tr></table></figure>

<p>TCP客户端：socket() -&gt; connect() -&gt; write() &lt;-&gt; read() -&gt; close()<br>TCP服务端：socket() -&gt; bind() -&gt; listen() -&gt; accept() -&gt; 阻塞直到有客户端连接 -&gt; read() &lt;-&gt; write() -&gt; read() -&gt; close()</p>
<p>##socket函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/types.h&gt; /* See NOTES */</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"></span><br><span class="line">int socket(int domain, int <span class="built_in">type</span>, int protocol);</span><br><span class="line">domain:</span><br><span class="line">	AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址</span><br><span class="line">	AF_INET6 与上面类似，不过是来用IPv6的地址</span><br><span class="line">	AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用</span><br><span class="line"><span class="built_in">type</span>:</span><br><span class="line">	SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。</span><br><span class="line">	SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。</span><br><span class="line">	SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。</span><br><span class="line">	SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议）</span><br><span class="line">	SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序</span><br><span class="line">protocol:</span><br><span class="line">	传0 表示使用默认协议。</span><br><span class="line">返回值：</span><br><span class="line">	成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno</span><br></pre></td></tr></table></figure>

<p>socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read&#x2F;write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。</p>
<p>##bind函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/types.h&gt; /* See NOTES */</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="built_in">bind</span>(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">sockfd：</span><br><span class="line">	socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">	构造出IP地址加端口号</span><br><span class="line">addrlen:</span><br><span class="line">	sizeof(addr)长度</span><br><span class="line">返回值：</span><br><span class="line">	成功返回0，失败返回-1, 设置errno</span><br></pre></td></tr></table></figure>
<p>服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。</p>
<p>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;</span><br><span class="line"><span class="built_in">bzero</span>(&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<p>##listen函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line">sockfd:</span><br><span class="line">	socket文件描述符</span><br><span class="line">backlog:</span><br><span class="line">	排队建立<span class="number">3</span>次握手队列和刚刚建立<span class="number">3</span>次握手队列的链接数和</span><br></pre></td></tr></table></figure>
<p>典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。</p>
<p>##accept函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/types.h&gt; 		/* See NOTES */</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"></span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">sockdf:</span><br><span class="line">	socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">	传出参数，返回链接客户端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">	传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小</span><br><span class="line">返回值：</span><br><span class="line">	成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno</span><br></pre></td></tr></table></figure>
<p>三次握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value-result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">	connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">	n = read(connfd, buf, MAXLINE);</span><br><span class="line">	......</span><br><span class="line">	close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的服务器程序结构整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭listenfd，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回-1</p>
<p>##connect函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> 					<span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">sockdf:</span><br><span class="line">	socket文件描述符</span><br><span class="line">addr:</span><br><span class="line">	传入参数，指定服务器端地址信息，含IP地址和端口号</span><br><span class="line">addrlen:</span><br><span class="line">	传入参数,传入<span class="keyword">sizeof</span>(addr)大小</span><br><span class="line">返回值：</span><br><span class="line">	成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>，设置errno</span><br></pre></td></tr></table></figure>
<p>客户端需要调用connect()连接服务器，connect和bind的参数形式一致，区别在于bind的参数是自己的地址，而connect的参数是对方的地址。connect()成功返回0，出错返回-1。</p>
<p>服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于监听端口的状态，客户端调用socket()初始化后，调用connect()发出SYN段并阻塞等待服务器应答，服务器应答一个SYN-ACK段，客户端收到后从connect()返回，同时应答一个ACK段，服务器收到后从accept()返回。<br>数据传输的过程：<br>建立连接后，TCP协议提供全双工的通信服务，但是一般的客户端&#x2F;服务器程序的流程是由客户端主动发起请求，服务器被动处理请求，一问一答的方式。因此，服务器从accept()返回后立刻调用read()，读socket就像读管道一样，如果没有数据到达就阻塞等待，这时客户端调用write()发送请求给服务器，服务器收到后从read()返回，对客户端的请求进行处理，在此期间客户端调用read()阻塞等待服务器的应答，服务器调用write()将处理结果发回给客户端，再次调用read()阻塞等待下一条请求，客户端收到后从read()返回，发送下一条请求，如此循环下去。<br>如果客户端没有更多的请求了，就调用close()关闭连接，就像写端关闭的管道一样，服务器的read()返回0，这样服务器就知道客户端关闭了连接，也调用close()关闭连接。注意，任何一方调用close()后，连接的两个传输方向都关闭，不能再发送数据了。如果一方调用shutdown()则连接处于半关闭状态，仍可接收对方发来的数据。<br>在学习socket API时要注意应用程序和TCP协议层是如何交互的： 应用程序调用某个socket函数时TCP协议层完成什么动作，比如调用connect()会发出SYN段 应用程序如何知道TCP协议层的状态变化，比如从某个阻塞的socket函数返回就表明TCP协议收到了某些段，再比如read()返回0就表明收到了FIN段</p>
<p>##最简单的客户端&#x2F;服务器程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Server</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="type">socklen_t</span> cliaddr_len;</span><br><span class="line">	<span class="type">int</span> listenfd, connfd;</span><br><span class="line">	<span class="type">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="type">int</span> i, n;</span><br><span class="line"></span><br><span class="line">	listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Accepting connections ...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">		connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">		n = read(connfd, buf, MAXLINE);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">		inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">		ntohs(cliaddr.sin_port));</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">		write(connfd, buf, n);</span><br><span class="line">		close(connfd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Client</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="type">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="type">int</span> sockfd, n;</span><br><span class="line"><span class="type">char</span> *str;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">fputs</span>(<span class="string">&quot;usage: ./client message\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">str = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;servaddr.sin_addr);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	write(sockfd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">	n = read(sockfd, buf, MAXLINE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Response from server:\n&quot;</span>);</span><br><span class="line">	write(STDOUT_FILENO, buf, n);</span><br><span class="line">	close(sockfd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##出错封装函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">//wrap.c</span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line">void perr_exit(const char *s)</span><br><span class="line">&#123;</span><br><span class="line">	perror(s);</span><br><span class="line">	<span class="built_in">exit</span>(1);</span><br><span class="line">&#125;</span><br><span class="line">int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	again:</span><br><span class="line">	<span class="keyword">if</span> ( (n = accept(fd, sa, salenptr)) &lt; 0) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line">			goto again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			perr_exit(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">int Bind(int fd, const struct sockaddr *sa, socklen_t salen)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	<span class="keyword">if</span> ((n = bind(fd, sa, salen)) &lt; 0)</span><br><span class="line">		perr_exit(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">	<span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">int Connect(int fd, const struct sockaddr *sa, socklen_t salen)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	<span class="keyword">if</span> ((n = connect(fd, sa, salen)) &lt; 0)</span><br><span class="line">		perr_exit(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">	<span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">int Listen(int fd, int backlog)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	<span class="keyword">if</span> ((n = listen(fd, backlog)) &lt; 0)</span><br><span class="line">		perr_exit(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">	<span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">int Socket(int family, int <span class="built_in">type</span>, int protocol)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	<span class="keyword">if</span> ( (n = socket(family, <span class="built_in">type</span>, protocol)) &lt; 0)</span><br><span class="line">		perr_exit(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">	<span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t Read(int fd, void *ptr, size_t nbytes)</span><br><span class="line">&#123;</span><br><span class="line">	ssize_t n;</span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ( (n = <span class="built_in">read</span>(fd, ptr, nbytes)) == -1) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			goto again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t Write(int fd, const void *ptr, size_t nbytes)</span><br><span class="line">&#123;</span><br><span class="line">	ssize_t n;</span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ( (n = write(fd, ptr, nbytes)) == -1) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			goto again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">int Close(int fd)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	<span class="keyword">if</span> ((n = close(fd)) == -1)</span><br><span class="line">		perr_exit(<span class="string">&quot;close error&quot;</span>);</span><br><span class="line">	<span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t Readn(int fd, void *vptr, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	size_t nleft;</span><br><span class="line">	ssize_t nread;</span><br><span class="line">	char *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; 0) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( (nread = <span class="built_in">read</span>(fd, ptr, nleft)) &lt; 0) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">				nread = 0;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">return</span> -1;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == 0)</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		nleft -= nread;</span><br><span class="line">		ptr += nread;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t Writen(int fd, const void *vptr, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">	size_t nleft;</span><br><span class="line">	ssize_t nwritten;</span><br><span class="line">	const char *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; 0) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( (nwritten = write(fd, ptr, nleft)) &lt;= 0) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nwritten &lt; 0 &amp;&amp; errno == EINTR)</span><br><span class="line">				nwritten = 0;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">return</span> -1;</span><br><span class="line">		&#125;</span><br><span class="line">		nleft -= nwritten;</span><br><span class="line">		ptr += nwritten;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t my_read(int fd, char *ptr)</span><br><span class="line">&#123;</span><br><span class="line">	static int read_cnt;</span><br><span class="line">	static char *read_ptr;</span><br><span class="line">	static char read_buf[100];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (read_cnt &lt;= 0) &#123;</span><br><span class="line">again:</span><br><span class="line">		<span class="keyword">if</span> ((read_cnt = read(fd, read_buf, sizeof(read_buf))) &lt; 0) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">				goto again;</span><br><span class="line">			<span class="built_in">return</span> -1;	</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == 0)</span><br><span class="line">			<span class="built_in">return</span> 0;</span><br><span class="line">		read_ptr = read_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	read_cnt--;</span><br><span class="line">	*ptr = *read_ptr++;</span><br><span class="line">	<span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t Readline(int fd, void *vptr, size_t maxlen)</span><br><span class="line">&#123;</span><br><span class="line">	ssize_t n, rc;</span><br><span class="line">	char c, *ptr;</span><br><span class="line">	ptr = vptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (n = 1; n &lt; maxlen; n++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( (rc = my_read(fd, &amp;c)) == 1) &#123;</span><br><span class="line">			*ptr++ = c;</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == 0) &#123;</span><br><span class="line">			*ptr = 0;</span><br><span class="line">			<span class="built_in">return</span> n - 1;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	*ptr = 0;</span><br><span class="line">	<span class="built_in">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WRAP_H_</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perr_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Accept</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> *salenptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">my_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *ptr)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readline</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>##多进程并发服务器</p>
<p>使用多进程并发服务器时要考虑以下几点：<br>1.父进程最大文件描述个数(父进程中需要close关闭accept返回的新文件描述符)<br>2.系统内创建进程个数(与内存大小相关)<br>3.进程创建过多是否降低整体服务性能(进程调度)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 800</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_sigchild</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">		;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="type">socklen_t</span> cliaddr_len;</span><br><span class="line">	<span class="type">int</span> listenfd, connfd;</span><br><span class="line">	<span class="type">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="type">int</span> i, n;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>;</span></span><br><span class="line">	newact.sa_handler = do_sigchild;</span><br><span class="line">	sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">	newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigaction(SIGCHLD, &amp;newact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Accepting connections ...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">		connfd = Accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line"></span><br><span class="line">		pid = fork();</span><br><span class="line">		<span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">			Close(listenfd);</span><br><span class="line">			<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">				n = Read(connfd, buf, MAXLINE);</span><br><span class="line">				<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;the other side has been closed.\n&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">						inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">						ntohs(cliaddr.sin_port));</span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">					buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">				Write(connfd, buf, n);</span><br><span class="line">			&#125;</span><br><span class="line">			Close(connfd);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			Close(connfd);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			perr_exit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(listenfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Client.c</span></span><br><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="type">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="type">int</span> sockfd, n;</span><br><span class="line"></span><br><span class="line">	sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;servaddr.sin_addr);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Write(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;the other side has been closed.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			Write(STDOUT_FILENO, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用线程模型开发服务器时需考虑以下问题：<br>1.调整进程内最大文件描述符上限<br>2.线程如有共享数据，考虑线程同步<br>3.服务于客户端线程退出时，退出处理。（退出值，分离态）<br>4.系统负载，随着链接客户端增加，导致其它线程不能及时得到CPU</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="type">int</span> connfd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">do_work</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n,i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> *<span class="title">ts</span> =</span> (<span class="keyword">struct</span> s_info*)arg;</span><br><span class="line">	<span class="type">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line">	<span class="comment">/* 可以在创建线程前设置线程创建属性,设为分离态,哪种效率高内？ */</span></span><br><span class="line">	pthread_detach(pthread_self());</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		n = Read(ts-&gt;connfd, buf, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;the other side has been closed.\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">				inet_ntop(AF_INET, &amp;(*ts).cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)),</span><br><span class="line">				ntohs((*ts).cliaddr.sin_port));</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">		Write(ts-&gt;connfd, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(ts-&gt;connfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	<span class="type">socklen_t</span> cliaddr_len;</span><br><span class="line">	<span class="type">int</span> listenfd, connfd;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">pthread_t</span> tid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> <span class="title">ts</span>[256];</span></span><br><span class="line"></span><br><span class="line">	listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Accepting connections ...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">		connfd = Accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">		ts[i].cliaddr = cliaddr;</span><br><span class="line">		ts[i].connfd = connfd;</span><br><span class="line">		<span class="comment">/* 达到线程最大数时，pthread_create出错处理, 增加服务器稳定性 */</span></span><br><span class="line">		pthread_create(&amp;tid, <span class="literal">NULL</span>, do_work, (<span class="type">void</span>*)&amp;ts[i]);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 6666</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	<span class="type">char</span> buf[MAXLINE];</span><br><span class="line">	<span class="type">int</span> sockfd, n;</span><br><span class="line"></span><br><span class="line">	sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;servaddr.sin_addr);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	Connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Write(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;the other side has been closed.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			Write(STDOUT_FILENO, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line">	Close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##多路I&#x2F;O转接服务器</p>

        
        
          <blockquote id="copyright">
              <p>原文链接: <a href="https://kettycode.github.io/index.html">https://kettycode.github.io/index.html</a></p>
              <p>版权声明: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">linux网络编程</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-cpp/并发编程/atomic" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/06/cpp/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/atomic/">C++并发编程学习</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2024-02-06T04:59:59.000Z" itemprop="datePublished">2024年02月06日</time>
</span>
      
      
      
<a href="/2024/02/06/cpp/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/atomic/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a>std::atomic</h1><h2 id="std-atomic-flag"><a href="#std-atomic-flag" class="headerlink" title="std::atomic_flag"></a>std::atomic_flag</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>std::atomic_flag 只有默认构造函数，拷贝构造函数已被禁用，因此不能从其他的 std::atomic_flag 对象构造一个新的 std::atomic_flag 对象。</p>
<p>如果在初始化时没有明确使用 ATOMIC_FLAG_INIT初始化，那么新创建的 std::atomic_flag 对象的状态是未指定的（unspecified）（既没有被 set 也没有被 clear。）另外，atomic_flag不能被拷贝，也不能 move 赋值。</p>
<p>ATOMIC_FLAG_INIT: 如果某个 std::atomic_flag 对象使用该宏初始化，那么可以保证该 std::atomic_flag 对象在创建时处于 clear 状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>              <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span>                <span class="comment">// std::atomic, std::atomic_flag, ATOMIC_FLAG_INIT</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                <span class="comment">// std::thread, std::this_thread::yield</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>                <span class="comment">// std::vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;    <span class="comment">// can be checked without being set</span></span><br><span class="line">std::atomic_flag winner = ATOMIC_FLAG_INIT;    <span class="comment">// always set when checked</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count1m</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125; <span class="comment">// 等待主线程中设置 ready 为 true.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    &#125; <span class="comment">// 计数.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果某个线程率先执行完上面的计数过程，则输出自己的 ID.</span></span><br><span class="line">    <span class="comment">// 此后其他线程执行 test_and_set 是 if 语句判断为 false，</span></span><br><span class="line">    <span class="comment">// 因此不会输出自身 ID.</span></span><br><span class="line">    <span class="keyword">if</span> (!winner.<span class="built_in">test_and_set</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread #&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; won!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;spawning 10 threads that count to 1 million...\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">        threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(count1m, i));</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; th:threads)</span><br><span class="line">        th.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-atomic-flag-text-and-set"><a href="#std-atomic-flag-text-and-set" class="headerlink" title="std::atomic_flag::text_and_set"></a>std::atomic_flag::text_and_set</h3><p>test_and_set() 函数检查 std::atomic_flag 标志，如果 std::atomic_flag 之前没有被设置过，则设置 std::atomic_flag 的标志，并返回先前该 std::atomic_flag 对象是否被设置过，如果之前 std::atomic_flag 对象已被设置，则返回 true，否则返回 false。</p>
<p>test-and-set 操作是原子的（因此 test-and-set 是原子 read-modify-write （RMW）操作）。</p>
<h3 id="std-atomic-flag-clear"><a href="#std-atomic-flag-clear" class="headerlink" title="std::atomic_flag::clear"></a>std::atomic_flag::clear</h3><p>清除 std::atomic_flag 对象的标志位，即设置 atomic_flag 的值为 false</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>结合 std::atomic_flag::test_and_set() 和 std::atomic_flag::clear()，std::atomic_flag 对象可以当作一个简单的自旋锁使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic_flag lock = ATOMIC_FLAG_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; <span class="number">100</span>; ++cnt) &#123;</span><br><span class="line">        <span class="keyword">while</span> (lock.<span class="built_in">test_and_set</span>(std::memory_order_acquire))  <span class="comment">// acquire lock</span></span><br><span class="line">             ; <span class="comment">// spin</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Output from thread &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        lock.<span class="built_in">clear</span>(std::memory_order_release);               <span class="comment">// release lock</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n) &#123;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(f, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : v) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的程序中，std::atomic_flag 对象 lock 的上锁操作可以理解为 lock.test_and_set(std::memory_order_acquire); (此处指定了 Memory Order，更多有关 Memory Order 的概念，我会在后续的文章中介绍)，解锁操作相当与 lock.clear(std::memory_order_release)。</p>
<p>在上锁的时候，如果 lock.test_and_set 返回 false，则表示上锁成功（此时 while 不会进入自旋状态），因为此前 lock 的标志位为 false(即没有线程对 lock 进行上锁操作)，但调用 test_and_set 后 lock 的标志位为 true，说明某一线程已经成功获得了 lock 锁。</p>
<p>如果在该线程解锁（即调用 lock.clear(std::memory_order_release)） 之前，另外一个线程也调用 lock.test_and_set(std::memory_order_acquire) 试图获得锁，则 test_and_set(std::memory_order_acquire) 返回 true，则 while 进入自旋状态。如果获得锁的线程解锁（即调用了 lock.clear(std::memory_order_release)）之后，某个线程试图调用 lock.test_and_set(std::memory_order_acquire) 并且返回 false，则 while 不会进入自旋，此时表明该线程成功地获得了锁。</p>
<p>按照上面的分析，我们知道在某种情况下 std::atomic_flag 对象可以当作一个简单的自旋锁使用。</p>
<h2 id="std-atomic-1"><a href="#std-atomic-1" class="headerlink" title="std::atomic"></a>std::atomic</h2><p>std::atomic 是模板类，一个模板类型为 T 的原子对象中封装了一个类型为 T 的值:  template <class T> struct atomic;<br>原子类型对象的主要特点就是从不同线程访问不会导致数据竞争(data race)。因此从不同线程访问某个原子对象是良性 (well-defined) 行为，而通常对于非原子类型而言，并发访问某个对象（如果不做任何同步操作）会导致未定义 (undifined) 行为发生。</p>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>默认构造函数，由默认构造函数创建的 std::atomic 对象处于未初始化(uninitialized)状态，对处于未初始化(uninitialized)状态 std::atomic对象可以由 atomic_init 函数进行初始化。<br>初始化构造函数，由类型 T初始化一个 std::atomic对象。<br>拷贝构造函数被禁用</p>
<h3 id="std-atomic-operator"><a href="#std-atomic-operator" class="headerlink" title="std::atomic::operator&#x3D;()"></a>std::atomic::operator&#x3D;()</h3><p>普通的赋值拷贝操作已经被禁用。但是一个类型为 T 的变量可以赋值给相应的原子类型变量（相当与隐式转换），该操作是原子的，内存序(Memory Order) 默认为顺序一致性(std::memory_order_seq_cst)，如果需要指定其他的内存序，需使用 std::atomic::store()。</p>
<h3 id="is-lock-free"><a href="#is-lock-free" class="headerlink" title="is_lock_free"></a>is_lock_free</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_lock_free</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_lock_free</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>判断该 std::atomic 对象是否具备 lock-free 的特性。如果某个对象满足 lock-free 特性，在多个线程访问该对象时不会导致线程阻塞。(可能使用某种事务内存transactional memory 方法实现 lock-free 的特性)。</p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>修改被封装的值，std::atomic::store 函数将类型为 T 的参数 val 复制给原子对象所封装的值。T 是 std::atomic 类模板参数。另外参数 sync 指定内存序(Memory Order)</p>
<h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">load</span> <span class="params">(memory_order sync = memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">T <span class="title">load</span> <span class="params">(memory_order sync = memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>读取被封装的值，参数 sync 设置内存序(Memory Order)</p>
<h3 id="operator-T"><a href="#operator-T" class="headerlink" title="operator T"></a>operator T</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">T</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>与 load 功能类似，也是读取被封装的值，operator T() 是类型转换(type-cast)操作，默认的内存序是 std::memory_order_seq_cst</p>
<h3 id="exchange"><a href="#exchange" class="headerlink" title="exchange"></a>exchange</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">exchange</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">T <span class="title">exchange</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>读取并修改被封装的值，exchange 会将 val 指定的值替换掉之前该原子对象封装的值，并返回之前该原子对象封装的值，整个过程是原子的(因此exchange 操作也称为 read-modify-write 操作)。sync参数指定内存序(Memory Order)</p>
<h3 id="compare-exchange-weak"><a href="#compare-exchange-weak" class="headerlink" title="compare_exchange_weak"></a>compare_exchange_weak</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T&amp; expected, T val,</span></span></span><br><span class="line"><span class="params"><span class="function">           memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T&amp; expected, T val,</span></span></span><br><span class="line"><span class="params"><span class="function">           memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T&amp; expected, T val,</span></span></span><br><span class="line"><span class="params"><span class="function">           memory_order success, memory_order failure)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T&amp; expected, T val,</span></span></span><br><span class="line"><span class="params"><span class="function">           memory_order success, memory_order failure)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>比较并交换被封装的值(weak)与参数 expected 所指定的值是否相等，如果：<br>相等，则用 val 替换原子对象的旧值。<br>不相等，则用原子对象的旧值替换 expected ，因此调用该函数之后，如果被该原子对象封装的值与参数 expected 所指定的值不相等，expected 中的内容就是原子对象的旧值。<br>该函数通常会读取原子对象封装的值，如果比较为 true(即原子对象的值等于 expected)，则替换原子对象的旧值，但整个操作是原子的，在某个线程读取和修改该原子对象时，另外的线程不能对读取和修改该原子对象。</p>
<p>在第(2)种情况下，内存序（Memory Order）的选择取决于比较操作结果，如果比较结果为 true(即原子对象的值等于 expected)，则选择参数 success 指定的内存序，否则选择参数 failure 所指定的内存序。</p>
<p>注意，该函数直接比较原子对象所封装的值与参数 expected 的物理内容，所以某些情况下，对象的比较操作在使用 operator&#x3D;&#x3D;() 判断时相等，但 compare_exchange_weak 判断时却可能失败，因为对象底层的物理内容中可能存在位对齐或其他逻辑表示相同但是物理表示不同的值(比如 true 和 2 或 3，它们在逻辑上都表示”真”，但在物理上两者的表示并不相同)。</p>
<p>与compare_exchange_strong 不同, weak 版本的 compare-and-exchange 操作允许(spuriously 地)返回 false(即原子对象所封装的值与参数 expected 的物理内容相同，但却仍然返回 false)，不过在某些需要循环操作的算法下这是可以接受的，并且在一些平台下 compare_exchange_weak 的性能更好 。如果 compare_exchange_weak 的判断确实发生了伪失败(spurious failures)——即使原子对象所封装的值与参数 expected 的物理内容相同，但判断操作的结果却为 false，compare_exchange_weak函数返回 false，并且参数 expected 的值不会改变。</p>
<p>对于某些不需要采用循环操作的算法而言, 通常采用compare_exchange_strong 更好。</p>
<h2 id="std-atomic特化版本的成员函数"><a href="#std-atomic特化版本的成员函数" class="headerlink" title="std::atomic特化版本的成员函数"></a>std::atomic特化版本的成员函数</h2><h3 id="fetch-add"><a href="#fetch-add" class="headerlink" title="fetch_add"></a>fetch_add</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> T is <span class="title">integral</span> <span class="params">(<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">T fetch_add (T val, memory_order sync =</span> memory_order_seq_cst) <span class="keyword">volatile</span> <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function">T <span class="title">fetch_add</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> T is <span class="title">pointer</span> <span class="params">(<span class="number">2</span>)</span>	:</span></span><br><span class="line"><span class="function">T fetch_add (ptrdiff_t val, memory_order sync =</span> memory_order_seq_cst) <span class="keyword">volatile</span> <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function">T <span class="title">fetch_add</span> <span class="params">(<span class="type">ptrdiff_t</span> val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>将原子对象的封装值加 val，并返回原子对象的旧值（适用于整形和指针类型的 std::atomic 特化版本），整个过程是原子的。另外，如果第二个参数不指定（取默认参数 memory_order_seq_cst），则 fetch_add 相当与 std::atomic::operator+&#x3D;。</p>
<h3 id="fetch-sub"><a href="#fetch-sub" class="headerlink" title="fetch_sub"></a>fetch_sub</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> T is <span class="title">integral</span> <span class="params">(<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">T fetch_sub (T val, memory_order sync =</span> memory_order_seq_cst) <span class="keyword">volatile</span> <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function">T <span class="title">fetch_sub</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> T is <span class="title">pointer</span> <span class="params">(<span class="number">2</span>)</span>:</span></span><br><span class="line"><span class="function">T fetch_sub (ptrdiff_t val, memory_order sync =</span> memory_order_seq_cst) <span class="keyword">volatile</span> <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function">T <span class="title">fetch_sub</span> <span class="params">(<span class="type">ptrdiff_t</span> val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>将原子对象的封装值减 val，并返回原子对象的旧值（适用于整形和指针类型的 std::atomic 特化版本），整个过程是原子的,另外，如果第二个参数不指定（取默认参数 memory_order_seq_cst），则 fetch_sub 相当与 std::atomic::operator-&#x3D;。</p>
<h3 id="fetch-and"><a href="#fetch-and" class="headerlink" title="fetch_and"></a>fetch_and</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fetch_and</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">T <span class="title">fetch_and</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>将原子对象的封装值按位与 val，并返回原子对象的旧值（只适用于整型的 std::atomic 特化版本），整个过程是原子的,另外，如果第二个参数不指定（取默认参数 memory_order_seq_cst），则 fetch_and 相当与 std::atomic::operator&amp;&#x3D;</p>
<h3 id="fetch-or"><a href="#fetch-or" class="headerlink" title="fetch_or"></a>fetch_or</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fetch_or</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">T <span class="title">fetch_or</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>将原子对象的封装值按位或 val，并返回原子对象的旧值（只适用于整型的 std::atomic 特化版本），整个过程是原子的,另外，如果第二个参数不指定（取默认参数 memory_order_seq_cst），则 fetch_or 相当与 std::atomic::operator|&#x3D;</p>
<h3 id="fetch-xor"><a href="#fetch-xor" class="headerlink" title="fetch_xor"></a>fetch_xor</h3><h3 id="operator"><a href="#operator" class="headerlink" title="operator++"></a>operator++</h3><h3 id="operator–"><a href="#operator–" class="headerlink" title="operator–"></a>operator–</h3><h3 id="operator-comp-assign"><a href="#operator-comp-assign" class="headerlink" title="operator(comp.assign.)"></a>operator(comp.assign.)</h3>
        
        
          <blockquote id="copyright">
              <p>原文链接: <a href="https://kettycode.github.io/index.html">https://kettycode.github.io/index.html</a></p>
              <p>版权声明: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-%E5%B9%B6%E5%8F%91/" rel="tag">c++并发</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-cpp/并发编程/base" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/06/cpp/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/base/">C++并发编程学习</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2024-02-06T04:59:59.000Z" itemprop="datePublished">2024年02月06日</time>
</span>
      
      
      
<a href="/2024/02/06/cpp/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/base/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="并发编程基础知识"><a href="#并发编程基础知识" class="headerlink" title="并发编程基础知识"></a>并发编程基础知识</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>并发：单个cpu在同一时间段内，多个任务同时执行，偏向于多个任务交替执行，在某一时刻其实只有一个任务在执行（单个CPU就可并发，比如时间片轮转机制）。指单个cpu同时处理多个线程任务，cpu在反复切换任务线程，实际还是串行化的。<br>并行：同一时刻，多个任务同时执行（并行需要有多个CPU）。指多个cpu同时处理多个线程任务，cpu可以同时处理不同的任务，异步处理。</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程，一个可执行程序运行起来就创建了一个进程。进程就是一个运行起来的可执行程序。<br>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>进程是具有独立功能的程序在一个数据集合上运行过程，它是系统进行资源分配和调度的一个独立单位。</p>
<p>在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”。<br>一切进程至少都有一个执行线程。<br>线程在进程内部运行，本质是在进程地址空间内运行。<br>在Linux系统中，在CPU眼中，看到的PCB都要比传统的进程更加轻量化。<br>透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程执行流。</p>
<h2 id="与多线程编程相关的头文件"><a href="#与多线程编程相关的头文件" class="headerlink" title="与多线程编程相关的头文件"></a>与多线程编程相关的头文件</h2><p><atomic>: std::atomic和std::atomic_flag<br><thread>: std::thread和std::this_thread<br><mutex>: std::mutex、std::lock_guard、std::unique_lock<br><condition_variable>: std::condition_variable、std::condition_variable_any<br><future>: std::promise、std::package_task、std::future、std::shared_future、std::async()</p>
<h1 id="简单的程序"><a href="#简单的程序" class="headerlink" title="简单的程序"></a>简单的程序</h1><h2 id="std-thread-“Hello-World”"><a href="#std-thread-“Hello-World”" class="headerlink" title="std::thread “Hello World”"></a>std::thread “Hello World”</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>   <span class="comment">// std::thread</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ===  FUNCTION  =========================================================</span></span><br><span class="line"><span class="comment"> *         Name:  main</span></span><br><span class="line"><span class="comment"> *  Description:  program entry routine.</span></span><br><span class="line"><span class="comment"> * ========================================================================</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(thread_task)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
        
        
          <blockquote id="copyright">
              <p>原文链接: <a href="https://kettycode.github.io/index.html">https://kettycode.github.io/index.html</a></p>
              <p>版权声明: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-%E5%B9%B6%E5%8F%91/" rel="tag">c++并发</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>


  <article id="post-cpp/并发编程/condition_variable" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/06/cpp/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/condition_variable/">C++并发编程学习</a>
    </h1>
  


      </header>
    
    <div class="article-meta">
      
      <span class="article-date">
  <i class="fa fa-date"></i>
  <time class="dt-published" datetime="2024-02-06T04:59:59.000Z" itemprop="datePublished">2024年02月06日</time>
</span>
      
      
      
<a href="/2024/02/06/cpp/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/condition_variable/#comments" class="article-comment-link">
  
  <i class="fa fa-commt"></i>
  留言
</a>


    </div>
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="std-condition-variable"><a href="#std-condition-variable" class="headerlink" title="std::condition_variable"></a>std::condition_variable</h1><p>当 std::condition_variable 对象的某个 wait 函数被调用的时候，它使用 std::unique_lock(通过 std::mutex) 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的 std::condition_variable 对象上调用了 notification 函数来唤醒当前线程。</p>
<p>std::condition_variable 对象通常使用 std::unique_lock<a href="std::mutex">std::mutex</a> 来等待，如果需要使用另外的 lockable 类型，可以使用 std::condition_variable_any 类，本文后面会讲到 std::condition_variable_any 的用法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>                <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>                <span class="comment">// std::mutex, std::unique_lock</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span>    <span class="comment">// std::condition_variable</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx; <span class="comment">// 全局互斥锁.</span></span><br><span class="line">std::condition_variable cv; <span class="comment">// 全局条件变量.</span></span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>; <span class="comment">// 全局标志位.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_print_id</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_lock &lt;std::mutex&gt; <span class="built_in">lck</span>(mtx);</span><br><span class="line">    <span class="keyword">while</span> (!ready) <span class="comment">// 如果标志位不为 true, 则等待...</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lck); <span class="comment">// 当前线程被阻塞, 当全局标志位变为 true 之后,</span></span><br><span class="line">    <span class="comment">// 线程被唤醒, 继续往下执行打印线程编号id.</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_lock &lt;std::mutex&gt; <span class="built_in">lck</span>(mtx);</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// 设置全局标志位为 true.</span></span><br><span class="line">    cv.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒所有线程.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread threads[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// spawn 10 threads:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(do_print_id, i);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;10 threads ready to race...\n&quot;</span>;</span><br><span class="line">    <span class="built_in">go</span>(); <span class="comment">// go!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; th:threads)</span><br><span class="line">        th.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="std-condition-variable-构造函数"><a href="#std-condition-variable-构造函数" class="headerlink" title="std::condition_variable 构造函数"></a>std::condition_variable 构造函数</h2><p>std::condition_variable 的拷贝构造函数被禁用，只提供了默认构造函数</p>
<h2 id="std-condition-variable-wait"><a href="#std-condition-variable-wait" class="headerlink" title="std::condition_variable::wait"></a>std::condition_variable::wait</h2><p>1.void wait(unique_lock<mutex>&amp; lck);<br>2.template <typename Predicate> void wait (unique_lock<mutex>&amp; lck, Predicate pred);<br>td::condition_variable 提供了两种 wait() 函数。</p>
<p>第一种情况，当前线程调用 wait() 后将被阻塞(此时当前线程应该获得了锁（mutex），不妨设获得锁 lck)，直到另外某个线程调用 notify_* 唤醒了当前线程。</p>
<p>在线程被阻塞时，该函数会自动调用 lck.unlock() 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知(notified，通常是另外某个线程调用 notify_* 唤醒了当前线程)，wait() 函数也是自动调用 lck.lock()，使得 lck 的状态和 wait 函数被调用时相同。</p>
<p>在第二种情况下（即设置了 Predicate），只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞。 类似while (!pred()) wait(lck);</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>                <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                <span class="comment">// std::thread, std::this_thread::yield</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>                <span class="comment">// std::mutex, std::unique_lock</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span>    <span class="comment">// std::condition_variable</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cargo = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">shipment_available</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cargo != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        std::unique_lock &lt;std::mutex&gt; <span class="built_in">lck</span>(mtx);</span><br><span class="line">        cv.<span class="built_in">wait</span>(lck, shipment_available);</span><br><span class="line">        std::cout &lt;&lt; cargo &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        cargo = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer_thread</span><span class="params">(consume, <span class="number">10</span>)</span></span>; <span class="comment">// 消费者线程.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程为生产者线程, 生产 10 个物品.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">shipment_available</span>())</span><br><span class="line">            std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">        std::unique_lock &lt;std::mutex&gt; <span class="built_in">lck</span>(mtx);</span><br><span class="line">        cargo = i + <span class="number">1</span>;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="std-condition-variable-wait-for"><a href="#std-condition-variable-wait-for" class="headerlink" title="std::condition_variable::wait_for"></a>std::condition_variable::wait_for</h2><p>与std::condition_variable::wait类似</p>
<h2 id="std-condition-variable-wait-until"><a href="#std-condition-variable-wait-until" class="headerlink" title="std::condition_variable::wait_until"></a>std::condition_variable::wait_until</h2><p>与std::condition_variable::wait_until类似</p>
<h2 id="std-condition-variable-notify-one"><a href="#std-condition-variable-notify-one" class="headerlink" title="std::condition_variable::notify_one"></a>std::condition_variable::notify_one</h2><p>唤醒某个等待(wait)线程。如果当前没有等待线程，则该函数什么也不做，如果同时存在多个等待线程，则唤醒某个线程是不确定的(unspecified)。</p>
<h2 id="std-condition-variable-notify-all"><a href="#std-condition-variable-notify-all" class="headerlink" title="std::condition_variable::notify_all"></a>std::condition_variable::notify_all</h2><p>唤醒所有的等待(wait)线程。如果当前没有等待线程，则该函数什么也不做。</p>
<h2 id="std-condition-variable-any"><a href="#std-condition-variable-any" class="headerlink" title="std::condition_variable_any"></a>std::condition_variable_any</h2><p>与 std::condition_variable 类似，只不过 std::condition_variable_any 的 wait 函数可以接受任何 lockable 参数，而 std::condition_variable 只能接受 std::unique_lock<a href="std::mutex">std::mutex</a> 类型的参数，除此以外，和 std::condition_variable 几乎完全一样。</p>
<h2 id="std-cv-status枚举类"><a href="#std-cv-status枚举类" class="headerlink" title="std::cv_status枚举类"></a>std::cv_status枚举类</h2><p>cv_status::no_timeout:	wait_for 或者 wait_until 没有超时，即在规定的时间段内线程收到了通知。<br>cv_status::timeout:	wait_for 或者 wait_until 超时。</p>
<h2 id="std-notify-all-at-thread-exit"><a href="#std-notify-all-at-thread-exit" class="headerlink" title="std::notify_all_at_thread_exit"></a>std::notify_all_at_thread_exit</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>           <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>             <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>              <span class="comment">// std::mutex, std::unique_lock</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// std::condition_variable</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_id</span> <span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (!ready) cv.<span class="built_in">wait</span>(lck);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">  std::<span class="built_in">notify_all_at_thread_exit</span>(cv,std::<span class="built_in">move</span>(lck));</span><br><span class="line">  ready = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::thread threads[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    threads[i] = std::<span class="built_in">thread</span>(print_id,i);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;10 threads ready to race...\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">thread</span>(go).<span class="built_in">detach</span>();   <span class="comment">// go!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        
          <blockquote id="copyright">
              <p>原文链接: <a href="https://kettycode.github.io/index.html">https://kettycode.github.io/index.html</a></p>
              <p>版权声明: 转载请注明出处.</p>
          </blockquote>
        
      
    </div>
    <footer class="article-footer">
      
        <div class="article-tag-wrap">
          

          
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c-%E5%B9%B6%E5%8F%91/" rel="tag">c++并发</a></li></ul>

          
    <div class="social-share">
      <span>分享到:</span>
    </div>



        </div>
      
      
      
    </footer>
  </div>
</article>



    <nav id="page-nav">

<span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
</nav>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-posts"></i> 最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/02/19/cpp/tip/char/">cahr 和 wchar_t</a>
          </li>
        
          <li>
            <a href="/2024/02/19/cpp/tip/hash/">哈希表小知识点及引申</a>
          </li>
        
          <li>
            <a href="/2024/02/06/cmake/cmake1/">cmake学习从0开始</a>
          </li>
        
          <li>
            <a href="/2024/02/06/cmake/cmake2/">cmake学习从0开始</a>
          </li>
        
          <li>
            <a href="/2024/02/06/git/git/">git学习从0开始</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> 标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Hazel-bug/" style="font-size: 10px;">Hazel_bug</a> <a href="/tags/c-template/" style="font-size: 10px;">c++ template</a> <a href="/tags/c-%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">c++并发</a> <a href="/tags/cmake/" style="font-size: 10px;">cmake</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">linux网络编程</a> <a href="/tags/modern-c/" style="font-size: 10px;">modern c++</a> <a href="/tags/tip/" style="font-size: 10px;">tip</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size: 10px;">位运算</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">博客</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-archive"></i> 归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024年</a><span class="archive-list-count">29</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023年</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-tag"></i> 标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hazel-bug/" rel="tag">Hazel_bug</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-template/" rel="tag">c++ template</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c-%E5%B9%B6%E5%8F%91/" rel="tag">c++并发</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cmake/" rel="tag">cmake</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">linux网络编程</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/modern-c/" rel="tag">modern c++</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tip/" rel="tag">tip</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2/" rel="tag">博客</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title"><i class="fa fa-link"></i> 友情链接</h3>
    <div class="widget">
      <ul>
      
        <li>
          <a target="_blank" rel="noopener" href="https://leetcode.cn/">力扣</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="https://www.cnblogs.com/">博客园</a>
        </li>
      
        <li>
          <a target="_blank" rel="noopener" href="https://www.bilibili.com/">b站</a>
        </li>
      
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <a id="totop" href="#top"></a>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <p>
        <a href="/sitemap.xml">网站地图</a>
        <span> | </span><a href="/atom.xml">订阅本站</a>
        <span> | </span><a href="/about/">联系博主</a>
      </p>
      
        <p>
          <i class="fa fa-visitors"></i>
          <i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>
          ，
          <i class="fa fa-views"></i>
          <i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>
        </p>
      
      <p>
        <span>Copyright &copy; 2024 ketty.</span>
        <span>Theme by <a href="https://github.com/chaooo/hexo-theme-BlueLake/" target="_blank">BlueLake.</a></span>
        <span>Powered by <a href="https://hexo.io/" target="_blank">Hexo.</a></span>
      </p>
    </div>
  </div>
</footer>

    </div>
  </div>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/search.json.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






  
<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  



</body>
</html>